// This code was AUTOGENERATED using the library.
// Please DO NOT EDIT THIS FILE.

package associated_token_account

import (
	"errors"
	common "github.com/donutnomad/solana-web3/common"
	binary "github.com/gagliardetto/binary"
	format "github.com/gagliardetto/solana-go/text/format"
	treeout "github.com/gagliardetto/treeout"
)

// Create Instruction
type Create struct {
	// [0] = [WRITE, SIGNER] account `Funding account (must be a system account)`
	// [1] = [WRITE] associatedAccount `Associated token account address to be created`
	// [2] = [] walletAddress `Wallet address for the new associated token account`
	// [3] = [] mint `The token mint for the new associated token account`
	// [4] = [] system `System program`
	// [5] = [] splTokenProgram `SPL Token program`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewCreateInstructionBuilder creates a new `Create` instruction builder.
func NewCreateInstructionBuilder() *Create {
	return &Create{
		AccountMetaSlice: make(common.AccountMetaSlice, 6),
	}
}

// NewCreateInstruction
//
// Parameters:
//
//	account: Funding account (must be a system account)
//	associatedAccount: Associated token account address to be created
//	walletAddress: Wallet address for the new associated token account
//	mint: The token mint for the new associated token account
//	system: System program
//	splTokenProgram: SPL Token program
func NewCreateInstruction(
	account common.PublicKey,
	associatedAccount common.PublicKey,
	walletAddress common.PublicKey,
	mint common.PublicKey,
	system common.PublicKey,
	splTokenProgram common.PublicKey,
) *Create {
	return NewCreateInstructionBuilder().
		SetAccountAccount(account).
		SetAssociatedAccountAccount(associatedAccount).
		SetWalletAddressAccount(walletAddress).
		SetMintAccount(mint).
		SetSystemAccount(system).
		SetSplTokenProgramAccount(splTokenProgram)
}

// SetAccountAccount sets the "account" parameter.
// Funding account (must be a system account)
func (obj *Create) SetAccountAccount(account common.PublicKey) *Create {
	obj.AccountMetaSlice[0] = common.Meta(account).WRITE().SIGNER()
	return obj
}

// GetAccountAccount gets the "account" parameter.
// Funding account (must be a system account)
func (obj *Create) GetAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetAssociatedAccountAccount sets the "associatedAccount" parameter.
// Associated token account address to be created
func (obj *Create) SetAssociatedAccountAccount(associatedAccount common.PublicKey) *Create {
	obj.AccountMetaSlice[1] = common.Meta(associatedAccount).WRITE()
	return obj
}

// GetAssociatedAccountAccount gets the "associatedAccount" parameter.
// Associated token account address to be created
func (obj *Create) GetAssociatedAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetWalletAddressAccount sets the "walletAddress" parameter.
// Wallet address for the new associated token account
func (obj *Create) SetWalletAddressAccount(walletAddress common.PublicKey) *Create {
	obj.AccountMetaSlice[2] = common.Meta(walletAddress)
	return obj
}

// GetWalletAddressAccount gets the "walletAddress" parameter.
// Wallet address for the new associated token account
func (obj *Create) GetWalletAddressAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMintAccount sets the "mint" parameter.
// The token mint for the new associated token account
func (obj *Create) SetMintAccount(mint common.PublicKey) *Create {
	obj.AccountMetaSlice[3] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The token mint for the new associated token account
func (obj *Create) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetSystemAccount sets the "system" parameter.
// System program
func (obj *Create) SetSystemAccount(system common.PublicKey) *Create {
	obj.AccountMetaSlice[4] = common.Meta(system)
	return obj
}

// GetSystemAccount gets the "system" parameter.
// System program
func (obj *Create) GetSystemAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token program
func (obj *Create) SetSplTokenProgramAccount(splTokenProgram common.PublicKey, multiSigners ...common.PublicKey) *Create {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[5] = common.Meta(splTokenProgram)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[5] = common.Meta(splTokenProgram)
	}
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token program
func (obj *Create) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

func (obj *Create) SetProgramId(programId *common.PublicKey) *Create {
	obj._programId = programId
	return obj
}

func (obj *Create) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Create}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Create) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Create] accounts.account is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Create] accounts.associatedAccount is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Create] accounts.walletAddress is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Create] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Create] accounts.system is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Create] accounts.splTokenProgram is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Create) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Create) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *Create) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *Create) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Create")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=6]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("          account", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("associatedAccount", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("    walletAddress", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("             mint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("           system", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("  splTokenProgram", obj.AccountMetaSlice.Get(5)))
					})
				})
		})
}

// CreateIdempotent Instruction
type CreateIdempotent struct {
	// [0] = [WRITE, SIGNER] account `Funding account (must be a system account)`
	// [1] = [WRITE] associatedAccount `Associated token account address to be created`
	// [2] = [] walletAddress `Wallet address for the new associated token account`
	// [3] = [] mint `The token mint for the new associated token account`
	// [4] = [] system `System program`
	// [5] = [] splTokenProgram `SPL Token program`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewCreateIdempotentInstructionBuilder creates a new `CreateIdempotent` instruction builder.
func NewCreateIdempotentInstructionBuilder() *CreateIdempotent {
	return &CreateIdempotent{
		AccountMetaSlice: make(common.AccountMetaSlice, 6),
	}
}

// NewCreateIdempotentInstruction
//
// Parameters:
//
//	account: Funding account (must be a system account)
//	associatedAccount: Associated token account address to be created
//	walletAddress: Wallet address for the new associated token account
//	mint: The token mint for the new associated token account
//	system: System program
//	splTokenProgram: SPL Token program
func NewCreateIdempotentInstruction(
	account common.PublicKey,
	associatedAccount common.PublicKey,
	walletAddress common.PublicKey,
	mint common.PublicKey,
	system common.PublicKey,
	splTokenProgram common.PublicKey,
) *CreateIdempotent {
	return NewCreateIdempotentInstructionBuilder().
		SetAccountAccount(account).
		SetAssociatedAccountAccount(associatedAccount).
		SetWalletAddressAccount(walletAddress).
		SetMintAccount(mint).
		SetSystemAccount(system).
		SetSplTokenProgramAccount(splTokenProgram)
}

// SetAccountAccount sets the "account" parameter.
// Funding account (must be a system account)
func (obj *CreateIdempotent) SetAccountAccount(account common.PublicKey) *CreateIdempotent {
	obj.AccountMetaSlice[0] = common.Meta(account).WRITE().SIGNER()
	return obj
}

// GetAccountAccount gets the "account" parameter.
// Funding account (must be a system account)
func (obj *CreateIdempotent) GetAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetAssociatedAccountAccount sets the "associatedAccount" parameter.
// Associated token account address to be created
func (obj *CreateIdempotent) SetAssociatedAccountAccount(associatedAccount common.PublicKey) *CreateIdempotent {
	obj.AccountMetaSlice[1] = common.Meta(associatedAccount).WRITE()
	return obj
}

// GetAssociatedAccountAccount gets the "associatedAccount" parameter.
// Associated token account address to be created
func (obj *CreateIdempotent) GetAssociatedAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetWalletAddressAccount sets the "walletAddress" parameter.
// Wallet address for the new associated token account
func (obj *CreateIdempotent) SetWalletAddressAccount(walletAddress common.PublicKey) *CreateIdempotent {
	obj.AccountMetaSlice[2] = common.Meta(walletAddress)
	return obj
}

// GetWalletAddressAccount gets the "walletAddress" parameter.
// Wallet address for the new associated token account
func (obj *CreateIdempotent) GetWalletAddressAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMintAccount sets the "mint" parameter.
// The token mint for the new associated token account
func (obj *CreateIdempotent) SetMintAccount(mint common.PublicKey) *CreateIdempotent {
	obj.AccountMetaSlice[3] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// The token mint for the new associated token account
func (obj *CreateIdempotent) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetSystemAccount sets the "system" parameter.
// System program
func (obj *CreateIdempotent) SetSystemAccount(system common.PublicKey) *CreateIdempotent {
	obj.AccountMetaSlice[4] = common.Meta(system)
	return obj
}

// GetSystemAccount gets the "system" parameter.
// System program
func (obj *CreateIdempotent) GetSystemAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token program
func (obj *CreateIdempotent) SetSplTokenProgramAccount(splTokenProgram common.PublicKey, multiSigners ...common.PublicKey) *CreateIdempotent {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[5] = common.Meta(splTokenProgram)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[5] = common.Meta(splTokenProgram)
	}
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token program
func (obj *CreateIdempotent) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

func (obj *CreateIdempotent) SetProgramId(programId *common.PublicKey) *CreateIdempotent {
	obj._programId = programId
	return obj
}

func (obj *CreateIdempotent) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_CreateIdempotent}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *CreateIdempotent) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[CreateIdempotent] accounts.account is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[CreateIdempotent] accounts.associatedAccount is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[CreateIdempotent] accounts.walletAddress is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[CreateIdempotent] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[CreateIdempotent] accounts.system is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[CreateIdempotent] accounts.splTokenProgram is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *CreateIdempotent) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *CreateIdempotent) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *CreateIdempotent) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *CreateIdempotent) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("CreateIdempotent")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=6]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("          account", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("associatedAccount", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("    walletAddress", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("             mint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("           system", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("  splTokenProgram", obj.AccountMetaSlice.Get(5)))
					})
				})
		})
}

// RecoverNested Instruction
type RecoverNested struct {
	// [0] = [WRITE] nestedAssociatedAccount `0. Nested associated token account, must be owned by `3“
	// [1] = [] mintNata `Token mint for the nested associated token account`
	// [2] = [WRITE] walletAssociatedAccount `Wallet's associated token account`
	// [3] = [] nestedAssociatedAccountOwner `Owner associated token account address, must be owned by `5“
	// [4] = [] mintOata `Token mint for the owner associated token account`
	// [5] = [WRITE, SIGNER] wallet `Wallet address for the owner associated token`
	// [6] = [] splTokenProgram `SPL Token program`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewRecoverNestedInstructionBuilder creates a new `RecoverNested` instruction builder.
func NewRecoverNestedInstructionBuilder() *RecoverNested {
	return &RecoverNested{
		AccountMetaSlice: make(common.AccountMetaSlice, 7),
	}
}

// NewRecoverNestedInstruction
//
// Parameters:
//
//	nestedAssociatedAccount: 0. Nested associated token account, must be owned by `3`
//	mintNata: Token mint for the nested associated token account
//	walletAssociatedAccount: Wallet's associated token account
//	nestedAssociatedAccountOwner: Owner associated token account address, must be owned by `5`
//	mintOata: Token mint for the owner associated token account
//	wallet: Wallet address for the owner associated token
//	splTokenProgram: SPL Token program
func NewRecoverNestedInstruction(
	nestedAssociatedAccount common.PublicKey,
	mintNata common.PublicKey,
	walletAssociatedAccount common.PublicKey,
	nestedAssociatedAccountOwner common.PublicKey,
	mintOata common.PublicKey,
	wallet common.PublicKey,
	splTokenProgram common.PublicKey,
) *RecoverNested {
	return NewRecoverNestedInstructionBuilder().
		SetNestedAssociatedAccountAccount(nestedAssociatedAccount).
		SetMintNataAccount(mintNata).
		SetWalletAssociatedAccountAccount(walletAssociatedAccount).
		SetNestedAssociatedAccountOwnerAccount(nestedAssociatedAccountOwner).
		SetMintOataAccount(mintOata).
		SetWalletAccount(wallet).
		SetSplTokenProgramAccount(splTokenProgram)
}

// SetNestedAssociatedAccountAccount sets the "nestedAssociatedAccount" parameter.
// 0. Nested associated token account, must be owned by `3`
func (obj *RecoverNested) SetNestedAssociatedAccountAccount(nestedAssociatedAccount common.PublicKey) *RecoverNested {
	obj.AccountMetaSlice[0] = common.Meta(nestedAssociatedAccount).WRITE()
	return obj
}

// GetNestedAssociatedAccountAccount gets the "nestedAssociatedAccount" parameter.
// 0. Nested associated token account, must be owned by `3`
func (obj *RecoverNested) GetNestedAssociatedAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintNataAccount sets the "mintNata" parameter.
// Token mint for the nested associated token account
func (obj *RecoverNested) SetMintNataAccount(mintNata common.PublicKey) *RecoverNested {
	obj.AccountMetaSlice[1] = common.Meta(mintNata)
	return obj
}

// GetMintNataAccount gets the "mintNata" parameter.
// Token mint for the nested associated token account
func (obj *RecoverNested) GetMintNataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetWalletAssociatedAccountAccount sets the "walletAssociatedAccount" parameter.
// Wallet's associated token account
func (obj *RecoverNested) SetWalletAssociatedAccountAccount(walletAssociatedAccount common.PublicKey) *RecoverNested {
	obj.AccountMetaSlice[2] = common.Meta(walletAssociatedAccount).WRITE()
	return obj
}

// GetWalletAssociatedAccountAccount gets the "walletAssociatedAccount" parameter.
// Wallet's associated token account
func (obj *RecoverNested) GetWalletAssociatedAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetNestedAssociatedAccountOwnerAccount sets the "nestedAssociatedAccountOwner" parameter.
// Owner associated token account address, must be owned by `5`
func (obj *RecoverNested) SetNestedAssociatedAccountOwnerAccount(nestedAssociatedAccountOwner common.PublicKey) *RecoverNested {
	obj.AccountMetaSlice[3] = common.Meta(nestedAssociatedAccountOwner)
	return obj
}

// GetNestedAssociatedAccountOwnerAccount gets the "nestedAssociatedAccountOwner" parameter.
// Owner associated token account address, must be owned by `5`
func (obj *RecoverNested) GetNestedAssociatedAccountOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetMintOataAccount sets the "mintOata" parameter.
// Token mint for the owner associated token account
func (obj *RecoverNested) SetMintOataAccount(mintOata common.PublicKey) *RecoverNested {
	obj.AccountMetaSlice[4] = common.Meta(mintOata)
	return obj
}

// GetMintOataAccount gets the "mintOata" parameter.
// Token mint for the owner associated token account
func (obj *RecoverNested) GetMintOataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetWalletAccount sets the "wallet" parameter.
// Wallet address for the owner associated token
func (obj *RecoverNested) SetWalletAccount(wallet common.PublicKey) *RecoverNested {
	obj.AccountMetaSlice[5] = common.Meta(wallet).WRITE().SIGNER()
	return obj
}

// GetWalletAccount gets the "wallet" parameter.
// Wallet address for the owner associated token
func (obj *RecoverNested) GetWalletAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token program
func (obj *RecoverNested) SetSplTokenProgramAccount(splTokenProgram common.PublicKey, multiSigners ...common.PublicKey) *RecoverNested {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[6] = common.Meta(splTokenProgram)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[6] = common.Meta(splTokenProgram)
	}
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token program
func (obj *RecoverNested) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

func (obj *RecoverNested) SetProgramId(programId *common.PublicKey) *RecoverNested {
	obj._programId = programId
	return obj
}

func (obj *RecoverNested) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_RecoverNested}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *RecoverNested) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[RecoverNested] accounts.nestedAssociatedAccount is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[RecoverNested] accounts.mintNata is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[RecoverNested] accounts.walletAssociatedAccount is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[RecoverNested] accounts.nestedAssociatedAccountOwner is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[RecoverNested] accounts.mintOata is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[RecoverNested] accounts.wallet is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[RecoverNested] accounts.splTokenProgram is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *RecoverNested) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *RecoverNested) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *RecoverNested) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *RecoverNested) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("RecoverNested")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=7]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("     nestedAssociatedAccount", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("                    mintNata", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("     walletAssociatedAccount", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("nestedAssociatedAccountOwner", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                    mintOata", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                      wallet", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("             splTokenProgram", obj.AccountMetaSlice.Get(6)))
					})
				})
		})
}
