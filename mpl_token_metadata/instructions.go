// This code was AUTOGENERATED using the library.
// Please DO NOT EDIT THIS FILE.

package mpl_token_metadata

import (
	"errors"
	common "github.com/donutnomad/solana-web3/common"
	binary "github.com/gagliardetto/binary"
	format "github.com/gagliardetto/solana-go/text/format"
	treeout "github.com/gagliardetto/treeout"
)

// CreateMetadataAccount Instruction
type CreateMetadataAccount struct {
	// [0] = [WRITE] metadata `Metadata key (pda of ['metadata', program id, mint id])`
	// [1] = [] mint `Mint of token asset`
	// [2] = [SIGNER] mintAuthority `Mint authority`
	// [3] = [WRITE, SIGNER] payer `payer`
	// [4] = [] updateAuthority `update authority info`
	// [5] = [] systemProgram `System program`
	// [6] = [] rent `Rent info`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewCreateMetadataAccountInstructionBuilder creates a new `CreateMetadataAccount` instruction builder.
func NewCreateMetadataAccountInstructionBuilder() *CreateMetadataAccount {
	return &CreateMetadataAccount{
		AccountMetaSlice: make(common.AccountMetaSlice, 7),
	}
}

// NewCreateMetadataAccountInstruction
//
// Parameters:
//
//	metadata: Metadata key (pda of ['metadata', program id, mint id])
//	mint: Mint of token asset
//	mintAuthority: Mint authority
//	payer: payer
//	updateAuthority: update authority info
//	systemProgram: System program
//	rent: Rent info
func NewCreateMetadataAccountInstruction(
	metadata common.PublicKey,
	mint common.PublicKey,
	mintAuthority common.PublicKey,
	payer common.PublicKey,
	updateAuthority common.PublicKey,
	systemProgram common.PublicKey,
	rent common.PublicKey,
) *CreateMetadataAccount {
	return NewCreateMetadataAccountInstructionBuilder().
		SetMetadataAccount(metadata).
		SetMintAccount(mint).
		SetMintAuthorityAccount(mintAuthority).
		SetPayerAccount(payer).
		SetUpdateAuthorityAccount(updateAuthority).
		SetSystemProgramAccount(systemProgram).
		SetRentAccount(rent)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata key (pda of ['metadata', program id, mint id])
func (obj *CreateMetadataAccount) SetMetadataAccount(metadata common.PublicKey) *CreateMetadataAccount {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata key (pda of ['metadata', program id, mint id])
func (obj *CreateMetadataAccount) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// Mint of token asset
func (obj *CreateMetadataAccount) SetMintAccount(mint common.PublicKey) *CreateMetadataAccount {
	obj.AccountMetaSlice[1] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of token asset
func (obj *CreateMetadataAccount) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMintAuthorityAccount sets the "mintAuthority" parameter.
// Mint authority
func (obj *CreateMetadataAccount) SetMintAuthorityAccount(mintAuthority common.PublicKey) *CreateMetadataAccount {
	obj.AccountMetaSlice[2] = common.Meta(mintAuthority).SIGNER()
	return obj
}

// GetMintAuthorityAccount gets the "mintAuthority" parameter.
// Mint authority
func (obj *CreateMetadataAccount) GetMintAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetPayerAccount sets the "payer" parameter.
// payer
func (obj *CreateMetadataAccount) SetPayerAccount(payer common.PublicKey) *CreateMetadataAccount {
	obj.AccountMetaSlice[3] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// payer
func (obj *CreateMetadataAccount) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// update authority info
func (obj *CreateMetadataAccount) SetUpdateAuthorityAccount(updateAuthority common.PublicKey) *CreateMetadataAccount {
	obj.AccountMetaSlice[4] = common.Meta(updateAuthority)
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// update authority info
func (obj *CreateMetadataAccount) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *CreateMetadataAccount) SetSystemProgramAccount(systemProgram common.PublicKey) *CreateMetadataAccount {
	obj.AccountMetaSlice[5] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *CreateMetadataAccount) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetRentAccount sets the "rent" parameter.
// Rent info
func (obj *CreateMetadataAccount) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *CreateMetadataAccount {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[6] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[6] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent info
func (obj *CreateMetadataAccount) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

func (obj *CreateMetadataAccount) SetProgramId(programId *common.PublicKey) *CreateMetadataAccount {
	obj._programId = programId
	return obj
}

func (obj *CreateMetadataAccount) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_CreateMetadataAccount}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *CreateMetadataAccount) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[CreateMetadataAccount] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[CreateMetadataAccount] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[CreateMetadataAccount] accounts.mintAuthority is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[CreateMetadataAccount] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[CreateMetadataAccount] accounts.updateAuthority is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[CreateMetadataAccount] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[CreateMetadataAccount] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *CreateMetadataAccount) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *CreateMetadataAccount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *CreateMetadataAccount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *CreateMetadataAccount) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("CreateMetadataAccount")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=7]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("       metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("           mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("  mintAuthority", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("          payer", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("updateAuthority", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("  systemProgram", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("           rent", obj.AccountMetaSlice.Get(6)))
					})
				})
		})
}

// UpdateMetadataAccount Instruction
type UpdateMetadataAccount struct {
	// [0] = [WRITE] metadata `Metadata account`
	// [1] = [SIGNER] updateAuthority `Update authority key`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewUpdateMetadataAccountInstructionBuilder creates a new `UpdateMetadataAccount` instruction builder.
func NewUpdateMetadataAccountInstructionBuilder() *UpdateMetadataAccount {
	return &UpdateMetadataAccount{
		AccountMetaSlice: make(common.AccountMetaSlice, 2),
	}
}

// NewUpdateMetadataAccountInstruction
//
// Parameters:
//
//	metadata: Metadata account
//	updateAuthority: Update authority key
func NewUpdateMetadataAccountInstruction(
	metadata common.PublicKey,
	updateAuthority common.PublicKey,
) *UpdateMetadataAccount {
	return NewUpdateMetadataAccountInstructionBuilder().
		SetMetadataAccount(metadata).
		SetUpdateAuthorityAccount(updateAuthority)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *UpdateMetadataAccount) SetMetadataAccount(metadata common.PublicKey) *UpdateMetadataAccount {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *UpdateMetadataAccount) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// Update authority key
func (obj *UpdateMetadataAccount) SetUpdateAuthorityAccount(updateAuthority common.PublicKey, multiSigners ...common.PublicKey) *UpdateMetadataAccount {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[1] = common.Meta(updateAuthority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[1] = common.Meta(updateAuthority).SIGNER()
	}
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// Update authority key
func (obj *UpdateMetadataAccount) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

func (obj *UpdateMetadataAccount) SetProgramId(programId *common.PublicKey) *UpdateMetadataAccount {
	obj._programId = programId
	return obj
}

func (obj *UpdateMetadataAccount) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_UpdateMetadataAccount}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *UpdateMetadataAccount) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[UpdateMetadataAccount] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[UpdateMetadataAccount] accounts.updateAuthority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *UpdateMetadataAccount) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *UpdateMetadataAccount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *UpdateMetadataAccount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *UpdateMetadataAccount) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("UpdateMetadataAccount")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=2]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("       metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("updateAuthority", obj.AccountMetaSlice.Get(1)))
					})
				})
		})
}

// DeprecatedCreateMasterEdition Instruction
type DeprecatedCreateMasterEdition struct {
	// [0] = [WRITE] edition `Unallocated edition V1 account with address as pda of ['metadata', program id, mint, 'edition']`
	// [1] = [WRITE] mint `Metadata mint`
	// [2] = [WRITE] printingMint `Printing mint - A mint you control that can mint tokens that can be exchanged for limited editions of your master edition via the MintNewEditionFromMasterEditionViaToken endpoint`
	// [3] = [WRITE] oneTimePrintingAuthorizationMint `One time authorization printing mint - A mint you control that prints tokens that gives the bearer permission to mint any number of tokens from the printing mint one time via an endpoint with the token-metadata program for your metadata. Also burns the token.`
	// [4] = [SIGNER] updateAuthority `Current Update authority key`
	// [5] = [SIGNER] printingMintAuthority `Printing mint authority - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY.`
	// [6] = [SIGNER] mintAuthority `Mint authority on the metadata's mint - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY`
	// [7] = [] metadata `Metadata account`
	// [8] = [SIGNER] payer `payer`
	// [9] = [] tokenProgram `Token program`
	// [10] = [] systemProgram `System program`
	// [11] = [] rent `Rent info`
	// [12] = [SIGNER] oneTimePrintingAuthorizationMintAuthority `One time authorization printing mint authority - must be provided if using max supply. THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewDeprecatedCreateMasterEditionInstructionBuilder creates a new `DeprecatedCreateMasterEdition` instruction builder.
func NewDeprecatedCreateMasterEditionInstructionBuilder() *DeprecatedCreateMasterEdition {
	return &DeprecatedCreateMasterEdition{
		AccountMetaSlice: make(common.AccountMetaSlice, 13),
	}
}

// NewDeprecatedCreateMasterEditionInstruction
//
// Parameters:
//
//	edition: Unallocated edition V1 account with address as pda of ['metadata', program id, mint, 'edition']
//	mint: Metadata mint
//	printingMint: Printing mint - A mint you control that can mint tokens that can be exchanged for limited editions of your master edition via the MintNewEditionFromMasterEditionViaToken endpoint
//	oneTimePrintingAuthorizationMint: One time authorization printing mint - A mint you control that prints tokens that gives the bearer permission to mint any number of tokens from the printing mint one time via an endpoint with the token-metadata program for your metadata. Also burns the token.
//	updateAuthority: Current Update authority key
//	printingMintAuthority: Printing mint authority - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY.
//	mintAuthority: Mint authority on the metadata's mint - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
//	metadata: Metadata account
//	payer: payer
//	tokenProgram: Token program
//	systemProgram: System program
//	rent: Rent info
//	oneTimePrintingAuthorizationMintAuthority: One time authorization printing mint authority - must be provided if using max supply. THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY.
func NewDeprecatedCreateMasterEditionInstruction(
	edition common.PublicKey,
	mint common.PublicKey,
	printingMint common.PublicKey,
	oneTimePrintingAuthorizationMint common.PublicKey,
	updateAuthority common.PublicKey,
	printingMintAuthority common.PublicKey,
	mintAuthority common.PublicKey,
	metadata common.PublicKey,
	payer common.PublicKey,
	tokenProgram common.PublicKey,
	systemProgram common.PublicKey,
	rent common.PublicKey,
	oneTimePrintingAuthorizationMintAuthority common.PublicKey,
) *DeprecatedCreateMasterEdition {
	return NewDeprecatedCreateMasterEditionInstructionBuilder().
		SetEditionAccount(edition).
		SetMintAccount(mint).
		SetPrintingMintAccount(printingMint).
		SetOneTimePrintingAuthorizationMintAccount(oneTimePrintingAuthorizationMint).
		SetUpdateAuthorityAccount(updateAuthority).
		SetPrintingMintAuthorityAccount(printingMintAuthority).
		SetMintAuthorityAccount(mintAuthority).
		SetMetadataAccount(metadata).
		SetPayerAccount(payer).
		SetTokenProgramAccount(tokenProgram).
		SetSystemProgramAccount(systemProgram).
		SetRentAccount(rent).
		SetOneTimePrintingAuthorizationMintAuthorityAccount(oneTimePrintingAuthorizationMintAuthority)
}

// SetEditionAccount sets the "edition" parameter.
// Unallocated edition V1 account with address as pda of ['metadata', program id, mint, 'edition']
func (obj *DeprecatedCreateMasterEdition) SetEditionAccount(edition common.PublicKey) *DeprecatedCreateMasterEdition {
	obj.AccountMetaSlice[0] = common.Meta(edition).WRITE()
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Unallocated edition V1 account with address as pda of ['metadata', program id, mint, 'edition']
func (obj *DeprecatedCreateMasterEdition) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// Metadata mint
func (obj *DeprecatedCreateMasterEdition) SetMintAccount(mint common.PublicKey) *DeprecatedCreateMasterEdition {
	obj.AccountMetaSlice[1] = common.Meta(mint).WRITE()
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Metadata mint
func (obj *DeprecatedCreateMasterEdition) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetPrintingMintAccount sets the "printingMint" parameter.
// Printing mint - A mint you control that can mint tokens that can be exchanged for limited editions of your master edition via the MintNewEditionFromMasterEditionViaToken endpoint
func (obj *DeprecatedCreateMasterEdition) SetPrintingMintAccount(printingMint common.PublicKey) *DeprecatedCreateMasterEdition {
	obj.AccountMetaSlice[2] = common.Meta(printingMint).WRITE()
	return obj
}

// GetPrintingMintAccount gets the "printingMint" parameter.
// Printing mint - A mint you control that can mint tokens that can be exchanged for limited editions of your master edition via the MintNewEditionFromMasterEditionViaToken endpoint
func (obj *DeprecatedCreateMasterEdition) GetPrintingMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetOneTimePrintingAuthorizationMintAccount sets the "oneTimePrintingAuthorizationMint" parameter.
// One time authorization printing mint - A mint you control that prints tokens that gives the bearer permission to mint any number of tokens from the printing mint one time via an endpoint with the token-metadata program for your metadata. Also burns the token.
func (obj *DeprecatedCreateMasterEdition) SetOneTimePrintingAuthorizationMintAccount(oneTimePrintingAuthorizationMint common.PublicKey) *DeprecatedCreateMasterEdition {
	obj.AccountMetaSlice[3] = common.Meta(oneTimePrintingAuthorizationMint).WRITE()
	return obj
}

// GetOneTimePrintingAuthorizationMintAccount gets the "oneTimePrintingAuthorizationMint" parameter.
// One time authorization printing mint - A mint you control that prints tokens that gives the bearer permission to mint any number of tokens from the printing mint one time via an endpoint with the token-metadata program for your metadata. Also burns the token.
func (obj *DeprecatedCreateMasterEdition) GetOneTimePrintingAuthorizationMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// Current Update authority key
func (obj *DeprecatedCreateMasterEdition) SetUpdateAuthorityAccount(updateAuthority common.PublicKey) *DeprecatedCreateMasterEdition {
	obj.AccountMetaSlice[4] = common.Meta(updateAuthority).SIGNER()
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// Current Update authority key
func (obj *DeprecatedCreateMasterEdition) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetPrintingMintAuthorityAccount sets the "printingMintAuthority" parameter.
// Printing mint authority - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY.
func (obj *DeprecatedCreateMasterEdition) SetPrintingMintAuthorityAccount(printingMintAuthority common.PublicKey) *DeprecatedCreateMasterEdition {
	obj.AccountMetaSlice[5] = common.Meta(printingMintAuthority).SIGNER()
	return obj
}

// GetPrintingMintAuthorityAccount gets the "printingMintAuthority" parameter.
// Printing mint authority - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY.
func (obj *DeprecatedCreateMasterEdition) GetPrintingMintAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetMintAuthorityAccount sets the "mintAuthority" parameter.
// Mint authority on the metadata's mint - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
func (obj *DeprecatedCreateMasterEdition) SetMintAuthorityAccount(mintAuthority common.PublicKey) *DeprecatedCreateMasterEdition {
	obj.AccountMetaSlice[6] = common.Meta(mintAuthority).SIGNER()
	return obj
}

// GetMintAuthorityAccount gets the "mintAuthority" parameter.
// Mint authority on the metadata's mint - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
func (obj *DeprecatedCreateMasterEdition) GetMintAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *DeprecatedCreateMasterEdition) SetMetadataAccount(metadata common.PublicKey) *DeprecatedCreateMasterEdition {
	obj.AccountMetaSlice[7] = common.Meta(metadata)
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *DeprecatedCreateMasterEdition) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetPayerAccount sets the "payer" parameter.
// payer
func (obj *DeprecatedCreateMasterEdition) SetPayerAccount(payer common.PublicKey) *DeprecatedCreateMasterEdition {
	obj.AccountMetaSlice[8] = common.Meta(payer).SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// payer
func (obj *DeprecatedCreateMasterEdition) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetTokenProgramAccount sets the "tokenProgram" parameter.
// Token program
func (obj *DeprecatedCreateMasterEdition) SetTokenProgramAccount(tokenProgram common.PublicKey) *DeprecatedCreateMasterEdition {
	obj.AccountMetaSlice[9] = common.Meta(tokenProgram)
	return obj
}

// GetTokenProgramAccount gets the "tokenProgram" parameter.
// Token program
func (obj *DeprecatedCreateMasterEdition) GetTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *DeprecatedCreateMasterEdition) SetSystemProgramAccount(systemProgram common.PublicKey) *DeprecatedCreateMasterEdition {
	obj.AccountMetaSlice[10] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *DeprecatedCreateMasterEdition) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetRentAccount sets the "rent" parameter.
// Rent info
func (obj *DeprecatedCreateMasterEdition) SetRentAccount(rent common.PublicKey) *DeprecatedCreateMasterEdition {
	obj.AccountMetaSlice[11] = common.Meta(rent)
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent info
func (obj *DeprecatedCreateMasterEdition) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

// SetOneTimePrintingAuthorizationMintAuthorityAccount sets the "oneTimePrintingAuthorizationMintAuthority" parameter.
// One time authorization printing mint authority - must be provided if using max supply. THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY.
func (obj *DeprecatedCreateMasterEdition) SetOneTimePrintingAuthorizationMintAuthorityAccount(oneTimePrintingAuthorizationMintAuthority common.PublicKey, multiSigners ...common.PublicKey) *DeprecatedCreateMasterEdition {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[12] = common.Meta(oneTimePrintingAuthorizationMintAuthority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[12] = common.Meta(oneTimePrintingAuthorizationMintAuthority).SIGNER()
	}
	return obj
}

// GetOneTimePrintingAuthorizationMintAuthorityAccount gets the "oneTimePrintingAuthorizationMintAuthority" parameter.
// One time authorization printing mint authority - must be provided if using max supply. THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY.
func (obj *DeprecatedCreateMasterEdition) GetOneTimePrintingAuthorizationMintAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(12)
}

func (obj *DeprecatedCreateMasterEdition) SetProgramId(programId *common.PublicKey) *DeprecatedCreateMasterEdition {
	obj._programId = programId
	return obj
}

func (obj *DeprecatedCreateMasterEdition) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_DeprecatedCreateMasterEdition}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *DeprecatedCreateMasterEdition) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[DeprecatedCreateMasterEdition] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[DeprecatedCreateMasterEdition] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[DeprecatedCreateMasterEdition] accounts.printingMint is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[DeprecatedCreateMasterEdition] accounts.oneTimePrintingAuthorizationMint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[DeprecatedCreateMasterEdition] accounts.updateAuthority is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[DeprecatedCreateMasterEdition] accounts.printingMintAuthority is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[DeprecatedCreateMasterEdition] accounts.mintAuthority is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[DeprecatedCreateMasterEdition] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[DeprecatedCreateMasterEdition] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[DeprecatedCreateMasterEdition] accounts.tokenProgram is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[DeprecatedCreateMasterEdition] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[DeprecatedCreateMasterEdition] accounts.rent is not set")
	}
	if obj.AccountMetaSlice[12] == nil {
		return errors.New("[DeprecatedCreateMasterEdition] accounts.oneTimePrintingAuthorizationMintAuthority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *DeprecatedCreateMasterEdition) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *DeprecatedCreateMasterEdition) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *DeprecatedCreateMasterEdition) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *DeprecatedCreateMasterEdition) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("DeprecatedCreateMasterEdition")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=13]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                                  edition", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("                                     mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                             printingMint", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("         oneTimePrintingAuthorizationMint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                          updateAuthority", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                    printingMintAuthority", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("                            mintAuthority", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("                                 metadata", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("                                    payer", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("                             tokenProgram", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("                            systemProgram", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("                                     rent", obj.AccountMetaSlice.Get(11)))
						accountsBranch.Child(common.FormatMeta("oneTimePrintingAuthorizationMintAuthority", obj.AccountMetaSlice.Get(12)))
					})
				})
		})
}

// DeprecatedMintNewEditionFromMasterEditionViaPrintingToken Instruction
type DeprecatedMintNewEditionFromMasterEditionViaPrintingToken struct {
	// [0] = [WRITE] metadata `New Metadata key (pda of ['metadata', program id, mint id])`
	// [1] = [WRITE] edition `New Edition V1 (pda of ['metadata', program id, mint id, 'edition'])`
	// [2] = [WRITE] masterEdition `Master Record Edition V1 (pda of ['metadata', program id, master metadata mint id, 'edition'])`
	// [3] = [WRITE] mint `Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY`
	// [4] = [SIGNER] mintAuthority `Mint authority of new mint`
	// [5] = [WRITE] printingMint `Printing Mint of master record edition`
	// [6] = [WRITE] masterTokenAccount `Token account containing Printing mint token to be transferred`
	// [7] = [WRITE] editionMarker `Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master mint id, edition_number])`
	// [8] = [SIGNER] burnAuthority `Burn authority for this token`
	// [9] = [SIGNER] payer `payer`
	// [10] = [] masterUpdateAuthority `update authority info for new metadata account`
	// [11] = [] masterMetadata `Master record metadata account`
	// [12] = [] tokenProgram `Token program`
	// [13] = [] systemProgram `System program`
	// [14] = [] rent `Rent info`
	// [15] = [WRITE] reservationList `Reservation List - If present, and you are on this list, you can get an edition number given by your position on the list.`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionBuilder creates a new `DeprecatedMintNewEditionFromMasterEditionViaPrintingToken` instruction builder.
func NewDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionBuilder() *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	return &DeprecatedMintNewEditionFromMasterEditionViaPrintingToken{
		AccountMetaSlice: make(common.AccountMetaSlice, 16),
	}
}

// NewDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction
//
// Parameters:
//
//	metadata: New Metadata key (pda of ['metadata', program id, mint id])
//	edition: New Edition V1 (pda of ['metadata', program id, mint id, 'edition'])
//	masterEdition: Master Record Edition V1 (pda of ['metadata', program id, master metadata mint id, 'edition'])
//	mint: Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
//	mintAuthority: Mint authority of new mint
//	printingMint: Printing Mint of master record edition
//	masterTokenAccount: Token account containing Printing mint token to be transferred
//	editionMarker: Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master mint id, edition_number])
//	burnAuthority: Burn authority for this token
//	payer: payer
//	masterUpdateAuthority: update authority info for new metadata account
//	masterMetadata: Master record metadata account
//	tokenProgram: Token program
//	systemProgram: System program
//	rent: Rent info
//	reservationList: Reservation List - If present, and you are on this list, you can get an edition number given by your position on the list.
func NewDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction(
	metadata common.PublicKey,
	edition common.PublicKey,
	masterEdition common.PublicKey,
	mint common.PublicKey,
	mintAuthority common.PublicKey,
	printingMint common.PublicKey,
	masterTokenAccount common.PublicKey,
	editionMarker common.PublicKey,
	burnAuthority common.PublicKey,
	payer common.PublicKey,
	masterUpdateAuthority common.PublicKey,
	masterMetadata common.PublicKey,
	tokenProgram common.PublicKey,
	systemProgram common.PublicKey,
	rent common.PublicKey,
	reservationList common.PublicKey,
) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	return NewDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionBuilder().
		SetMetadataAccount(metadata).
		SetEditionAccount(edition).
		SetMasterEditionAccount(masterEdition).
		SetMintAccount(mint).
		SetMintAuthorityAccount(mintAuthority).
		SetPrintingMintAccount(printingMint).
		SetMasterTokenAccountAccount(masterTokenAccount).
		SetEditionMarkerAccount(editionMarker).
		SetBurnAuthorityAccount(burnAuthority).
		SetPayerAccount(payer).
		SetMasterUpdateAuthorityAccount(masterUpdateAuthority).
		SetMasterMetadataAccount(masterMetadata).
		SetTokenProgramAccount(tokenProgram).
		SetSystemProgramAccount(systemProgram).
		SetRentAccount(rent).
		SetReservationListAccount(reservationList)
}

// SetMetadataAccount sets the "metadata" parameter.
// New Metadata key (pda of ['metadata', program id, mint id])
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetMetadataAccount(metadata common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// New Metadata key (pda of ['metadata', program id, mint id])
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetEditionAccount sets the "edition" parameter.
// New Edition V1 (pda of ['metadata', program id, mint id, 'edition'])
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetEditionAccount(edition common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[1] = common.Meta(edition).WRITE()
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// New Edition V1 (pda of ['metadata', program id, mint id, 'edition'])
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMasterEditionAccount sets the "masterEdition" parameter.
// Master Record Edition V1 (pda of ['metadata', program id, master metadata mint id, 'edition'])
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetMasterEditionAccount(masterEdition common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[2] = common.Meta(masterEdition).WRITE()
	return obj
}

// GetMasterEditionAccount gets the "masterEdition" parameter.
// Master Record Edition V1 (pda of ['metadata', program id, master metadata mint id, 'edition'])
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMintAccount sets the "mint" parameter.
// Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetMintAccount(mint common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[3] = common.Meta(mint).WRITE()
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetMintAuthorityAccount sets the "mintAuthority" parameter.
// Mint authority of new mint
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetMintAuthorityAccount(mintAuthority common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[4] = common.Meta(mintAuthority).SIGNER()
	return obj
}

// GetMintAuthorityAccount gets the "mintAuthority" parameter.
// Mint authority of new mint
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetMintAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetPrintingMintAccount sets the "printingMint" parameter.
// Printing Mint of master record edition
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetPrintingMintAccount(printingMint common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[5] = common.Meta(printingMint).WRITE()
	return obj
}

// GetPrintingMintAccount gets the "printingMint" parameter.
// Printing Mint of master record edition
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetPrintingMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetMasterTokenAccountAccount sets the "masterTokenAccount" parameter.
// Token account containing Printing mint token to be transferred
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetMasterTokenAccountAccount(masterTokenAccount common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[6] = common.Meta(masterTokenAccount).WRITE()
	return obj
}

// GetMasterTokenAccountAccount gets the "masterTokenAccount" parameter.
// Token account containing Printing mint token to be transferred
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetMasterTokenAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetEditionMarkerAccount sets the "editionMarker" parameter.
// Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master mint id, edition_number])
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetEditionMarkerAccount(editionMarker common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[7] = common.Meta(editionMarker).WRITE()
	return obj
}

// GetEditionMarkerAccount gets the "editionMarker" parameter.
// Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master mint id, edition_number])
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetEditionMarkerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetBurnAuthorityAccount sets the "burnAuthority" parameter.
// Burn authority for this token
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetBurnAuthorityAccount(burnAuthority common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[8] = common.Meta(burnAuthority).SIGNER()
	return obj
}

// GetBurnAuthorityAccount gets the "burnAuthority" parameter.
// Burn authority for this token
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetBurnAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetPayerAccount sets the "payer" parameter.
// payer
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetPayerAccount(payer common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[9] = common.Meta(payer).SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// payer
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetMasterUpdateAuthorityAccount sets the "masterUpdateAuthority" parameter.
// update authority info for new metadata account
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetMasterUpdateAuthorityAccount(masterUpdateAuthority common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[10] = common.Meta(masterUpdateAuthority)
	return obj
}

// GetMasterUpdateAuthorityAccount gets the "masterUpdateAuthority" parameter.
// update authority info for new metadata account
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetMasterUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetMasterMetadataAccount sets the "masterMetadata" parameter.
// Master record metadata account
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetMasterMetadataAccount(masterMetadata common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[11] = common.Meta(masterMetadata)
	return obj
}

// GetMasterMetadataAccount gets the "masterMetadata" parameter.
// Master record metadata account
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetMasterMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

// SetTokenProgramAccount sets the "tokenProgram" parameter.
// Token program
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetTokenProgramAccount(tokenProgram common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[12] = common.Meta(tokenProgram)
	return obj
}

// GetTokenProgramAccount gets the "tokenProgram" parameter.
// Token program
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(12)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetSystemProgramAccount(systemProgram common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[13] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(13)
}

// SetRentAccount sets the "rent" parameter.
// Rent info
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetRentAccount(rent common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj.AccountMetaSlice[14] = common.Meta(rent)
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent info
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(14)
}

// SetReservationListAccount sets the "reservationList" parameter.
// Reservation List - If present, and you are on this list, you can get an edition number given by your position on the list.
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetReservationListAccount(reservationList common.PublicKey, multiSigners ...common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[15] = common.Meta(reservationList)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[15] = common.Meta(reservationList).WRITE()
	}
	return obj
}

// GetReservationListAccount gets the "reservationList" parameter.
// Reservation List - If present, and you are on this list, you can get an edition number given by your position on the list.
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) GetReservationListAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(15)
}

func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) SetProgramId(programId *common.PublicKey) *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken {
	obj._programId = programId
	return obj
}

func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_DeprecatedMintNewEditionFromMasterEditionViaPrintingToken}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.masterEdition is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.mintAuthority is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.printingMint is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.masterTokenAccount is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.editionMarker is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.burnAuthority is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.masterUpdateAuthority is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.masterMetadata is not set")
	}
	if obj.AccountMetaSlice[12] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.tokenProgram is not set")
	}
	if obj.AccountMetaSlice[13] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[14] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.rent is not set")
	}
	if obj.AccountMetaSlice[15] == nil {
		return errors.New("[DeprecatedMintNewEditionFromMasterEditionViaPrintingToken] accounts.reservationList is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *DeprecatedMintNewEditionFromMasterEditionViaPrintingToken) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("DeprecatedMintNewEditionFromMasterEditionViaPrintingToken")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=16]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("             metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("              edition", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("        masterEdition", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("                 mint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("        mintAuthority", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("         printingMint", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("   masterTokenAccount", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("        editionMarker", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("        burnAuthority", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("                payer", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("masterUpdateAuthority", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("       masterMetadata", obj.AccountMetaSlice.Get(11)))
						accountsBranch.Child(common.FormatMeta("         tokenProgram", obj.AccountMetaSlice.Get(12)))
						accountsBranch.Child(common.FormatMeta("        systemProgram", obj.AccountMetaSlice.Get(13)))
						accountsBranch.Child(common.FormatMeta("                 rent", obj.AccountMetaSlice.Get(14)))
						accountsBranch.Child(common.FormatMeta("      reservationList", obj.AccountMetaSlice.Get(15)))
					})
				})
		})
}

// UpdatePrimarySaleHappenedViaToken Instruction
type UpdatePrimarySaleHappenedViaToken struct {
	// [0] = [WRITE] metadata `Metadata key (pda of ['metadata', program id, mint id])`
	// [1] = [SIGNER] owner `Owner on the token account`
	// [2] = [] token `Account containing tokens from the metadata's mint`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewUpdatePrimarySaleHappenedViaTokenInstructionBuilder creates a new `UpdatePrimarySaleHappenedViaToken` instruction builder.
func NewUpdatePrimarySaleHappenedViaTokenInstructionBuilder() *UpdatePrimarySaleHappenedViaToken {
	return &UpdatePrimarySaleHappenedViaToken{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewUpdatePrimarySaleHappenedViaTokenInstruction
//
// Parameters:
//
//	metadata: Metadata key (pda of ['metadata', program id, mint id])
//	owner: Owner on the token account
//	token: Account containing tokens from the metadata's mint
func NewUpdatePrimarySaleHappenedViaTokenInstruction(
	metadata common.PublicKey,
	owner common.PublicKey,
	token common.PublicKey,
) *UpdatePrimarySaleHappenedViaToken {
	return NewUpdatePrimarySaleHappenedViaTokenInstructionBuilder().
		SetMetadataAccount(metadata).
		SetOwnerAccount(owner).
		SetTokenAccount(token)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata key (pda of ['metadata', program id, mint id])
func (obj *UpdatePrimarySaleHappenedViaToken) SetMetadataAccount(metadata common.PublicKey) *UpdatePrimarySaleHappenedViaToken {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata key (pda of ['metadata', program id, mint id])
func (obj *UpdatePrimarySaleHappenedViaToken) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetOwnerAccount sets the "owner" parameter.
// Owner on the token account
func (obj *UpdatePrimarySaleHappenedViaToken) SetOwnerAccount(owner common.PublicKey) *UpdatePrimarySaleHappenedViaToken {
	obj.AccountMetaSlice[1] = common.Meta(owner).SIGNER()
	return obj
}

// GetOwnerAccount gets the "owner" parameter.
// Owner on the token account
func (obj *UpdatePrimarySaleHappenedViaToken) GetOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetTokenAccount sets the "token" parameter.
// Account containing tokens from the metadata's mint
func (obj *UpdatePrimarySaleHappenedViaToken) SetTokenAccount(token common.PublicKey, multiSigners ...common.PublicKey) *UpdatePrimarySaleHappenedViaToken {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(token)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(token)
	}
	return obj
}

// GetTokenAccount gets the "token" parameter.
// Account containing tokens from the metadata's mint
func (obj *UpdatePrimarySaleHappenedViaToken) GetTokenAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *UpdatePrimarySaleHappenedViaToken) SetProgramId(programId *common.PublicKey) *UpdatePrimarySaleHappenedViaToken {
	obj._programId = programId
	return obj
}

func (obj *UpdatePrimarySaleHappenedViaToken) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_UpdatePrimarySaleHappenedViaToken}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *UpdatePrimarySaleHappenedViaToken) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[UpdatePrimarySaleHappenedViaToken] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[UpdatePrimarySaleHappenedViaToken] accounts.owner is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[UpdatePrimarySaleHappenedViaToken] accounts.token is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *UpdatePrimarySaleHappenedViaToken) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *UpdatePrimarySaleHappenedViaToken) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *UpdatePrimarySaleHappenedViaToken) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *UpdatePrimarySaleHappenedViaToken) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("UpdatePrimarySaleHappenedViaToken")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("   owner", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("   token", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// DeprecatedSetReservationList Instruction
type DeprecatedSetReservationList struct {
	// [0] = [WRITE] masterEdition `Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])`
	// [1] = [WRITE] reservationList `PDA for ReservationList of ['metadata', program id, master edition key, 'reservation', resource-key]`
	// [2] = [SIGNER] resource `The resource you tied the reservation list too`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewDeprecatedSetReservationListInstructionBuilder creates a new `DeprecatedSetReservationList` instruction builder.
func NewDeprecatedSetReservationListInstructionBuilder() *DeprecatedSetReservationList {
	return &DeprecatedSetReservationList{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewDeprecatedSetReservationListInstruction
//
// Parameters:
//
//	masterEdition: Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])
//	reservationList: PDA for ReservationList of ['metadata', program id, master edition key, 'reservation', resource-key]
//	resource: The resource you tied the reservation list too
func NewDeprecatedSetReservationListInstruction(
	masterEdition common.PublicKey,
	reservationList common.PublicKey,
	resource common.PublicKey,
) *DeprecatedSetReservationList {
	return NewDeprecatedSetReservationListInstructionBuilder().
		SetMasterEditionAccount(masterEdition).
		SetReservationListAccount(reservationList).
		SetResourceAccount(resource)
}

// SetMasterEditionAccount sets the "masterEdition" parameter.
// Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])
func (obj *DeprecatedSetReservationList) SetMasterEditionAccount(masterEdition common.PublicKey) *DeprecatedSetReservationList {
	obj.AccountMetaSlice[0] = common.Meta(masterEdition).WRITE()
	return obj
}

// GetMasterEditionAccount gets the "masterEdition" parameter.
// Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])
func (obj *DeprecatedSetReservationList) GetMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetReservationListAccount sets the "reservationList" parameter.
// PDA for ReservationList of ['metadata', program id, master edition key, 'reservation', resource-key]
func (obj *DeprecatedSetReservationList) SetReservationListAccount(reservationList common.PublicKey) *DeprecatedSetReservationList {
	obj.AccountMetaSlice[1] = common.Meta(reservationList).WRITE()
	return obj
}

// GetReservationListAccount gets the "reservationList" parameter.
// PDA for ReservationList of ['metadata', program id, master edition key, 'reservation', resource-key]
func (obj *DeprecatedSetReservationList) GetReservationListAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetResourceAccount sets the "resource" parameter.
// The resource you tied the reservation list too
func (obj *DeprecatedSetReservationList) SetResourceAccount(resource common.PublicKey, multiSigners ...common.PublicKey) *DeprecatedSetReservationList {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(resource)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(resource).SIGNER()
	}
	return obj
}

// GetResourceAccount gets the "resource" parameter.
// The resource you tied the reservation list too
func (obj *DeprecatedSetReservationList) GetResourceAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *DeprecatedSetReservationList) SetProgramId(programId *common.PublicKey) *DeprecatedSetReservationList {
	obj._programId = programId
	return obj
}

func (obj *DeprecatedSetReservationList) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_DeprecatedSetReservationList}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *DeprecatedSetReservationList) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[DeprecatedSetReservationList] accounts.masterEdition is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[DeprecatedSetReservationList] accounts.reservationList is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[DeprecatedSetReservationList] accounts.resource is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *DeprecatedSetReservationList) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *DeprecatedSetReservationList) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *DeprecatedSetReservationList) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *DeprecatedSetReservationList) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("DeprecatedSetReservationList")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("  masterEdition", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("reservationList", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("       resource", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// DeprecatedCreateReservationList Instruction
type DeprecatedCreateReservationList struct {
	// [0] = [WRITE] reservationList `PDA for ReservationList of ['metadata', program id, master edition key, 'reservation', resource-key]`
	// [1] = [SIGNER] payer `Payer`
	// [2] = [SIGNER] updateAuthority `Update authority`
	// [3] = [] masterEdition ` Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])`
	// [4] = [] resource `A resource you wish to tie the reservation list to. This is so your later visitors who come to redeem can derive your reservation list PDA with something they can easily get at. You choose what this should be.`
	// [5] = [] metadata `Metadata key (pda of ['metadata', program id, mint id])`
	// [6] = [] systemProgram `System program`
	// [7] = [] rent `Rent info`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewDeprecatedCreateReservationListInstructionBuilder creates a new `DeprecatedCreateReservationList` instruction builder.
func NewDeprecatedCreateReservationListInstructionBuilder() *DeprecatedCreateReservationList {
	return &DeprecatedCreateReservationList{
		AccountMetaSlice: make(common.AccountMetaSlice, 8),
	}
}

// NewDeprecatedCreateReservationListInstruction
//
// Parameters:
//
//	reservationList: PDA for ReservationList of ['metadata', program id, master edition key, 'reservation', resource-key]
//	payer: Payer
//	updateAuthority: Update authority
//	masterEdition:  Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])
//	resource: A resource you wish to tie the reservation list to. This is so your later visitors who come to redeem can derive your reservation list PDA with something they can easily get at. You choose what this should be.
//	metadata: Metadata key (pda of ['metadata', program id, mint id])
//	systemProgram: System program
//	rent: Rent info
func NewDeprecatedCreateReservationListInstruction(
	reservationList common.PublicKey,
	payer common.PublicKey,
	updateAuthority common.PublicKey,
	masterEdition common.PublicKey,
	resource common.PublicKey,
	metadata common.PublicKey,
	systemProgram common.PublicKey,
	rent common.PublicKey,
) *DeprecatedCreateReservationList {
	return NewDeprecatedCreateReservationListInstructionBuilder().
		SetReservationListAccount(reservationList).
		SetPayerAccount(payer).
		SetUpdateAuthorityAccount(updateAuthority).
		SetMasterEditionAccount(masterEdition).
		SetResourceAccount(resource).
		SetMetadataAccount(metadata).
		SetSystemProgramAccount(systemProgram).
		SetRentAccount(rent)
}

// SetReservationListAccount sets the "reservationList" parameter.
// PDA for ReservationList of ['metadata', program id, master edition key, 'reservation', resource-key]
func (obj *DeprecatedCreateReservationList) SetReservationListAccount(reservationList common.PublicKey) *DeprecatedCreateReservationList {
	obj.AccountMetaSlice[0] = common.Meta(reservationList).WRITE()
	return obj
}

// GetReservationListAccount gets the "reservationList" parameter.
// PDA for ReservationList of ['metadata', program id, master edition key, 'reservation', resource-key]
func (obj *DeprecatedCreateReservationList) GetReservationListAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetPayerAccount sets the "payer" parameter.
// Payer
func (obj *DeprecatedCreateReservationList) SetPayerAccount(payer common.PublicKey) *DeprecatedCreateReservationList {
	obj.AccountMetaSlice[1] = common.Meta(payer).SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Payer
func (obj *DeprecatedCreateReservationList) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// Update authority
func (obj *DeprecatedCreateReservationList) SetUpdateAuthorityAccount(updateAuthority common.PublicKey) *DeprecatedCreateReservationList {
	obj.AccountMetaSlice[2] = common.Meta(updateAuthority).SIGNER()
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// Update authority
func (obj *DeprecatedCreateReservationList) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMasterEditionAccount sets the "masterEdition" parameter.
//
//	Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])
func (obj *DeprecatedCreateReservationList) SetMasterEditionAccount(masterEdition common.PublicKey) *DeprecatedCreateReservationList {
	obj.AccountMetaSlice[3] = common.Meta(masterEdition)
	return obj
}

// GetMasterEditionAccount gets the "masterEdition" parameter.
//
//	Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])
func (obj *DeprecatedCreateReservationList) GetMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetResourceAccount sets the "resource" parameter.
// A resource you wish to tie the reservation list to. This is so your later visitors who come to redeem can derive your reservation list PDA with something they can easily get at. You choose what this should be.
func (obj *DeprecatedCreateReservationList) SetResourceAccount(resource common.PublicKey) *DeprecatedCreateReservationList {
	obj.AccountMetaSlice[4] = common.Meta(resource)
	return obj
}

// GetResourceAccount gets the "resource" parameter.
// A resource you wish to tie the reservation list to. This is so your later visitors who come to redeem can derive your reservation list PDA with something they can easily get at. You choose what this should be.
func (obj *DeprecatedCreateReservationList) GetResourceAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata key (pda of ['metadata', program id, mint id])
func (obj *DeprecatedCreateReservationList) SetMetadataAccount(metadata common.PublicKey) *DeprecatedCreateReservationList {
	obj.AccountMetaSlice[5] = common.Meta(metadata)
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata key (pda of ['metadata', program id, mint id])
func (obj *DeprecatedCreateReservationList) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *DeprecatedCreateReservationList) SetSystemProgramAccount(systemProgram common.PublicKey) *DeprecatedCreateReservationList {
	obj.AccountMetaSlice[6] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *DeprecatedCreateReservationList) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetRentAccount sets the "rent" parameter.
// Rent info
func (obj *DeprecatedCreateReservationList) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *DeprecatedCreateReservationList {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[7] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[7] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent info
func (obj *DeprecatedCreateReservationList) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

func (obj *DeprecatedCreateReservationList) SetProgramId(programId *common.PublicKey) *DeprecatedCreateReservationList {
	obj._programId = programId
	return obj
}

func (obj *DeprecatedCreateReservationList) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_DeprecatedCreateReservationList}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *DeprecatedCreateReservationList) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[DeprecatedCreateReservationList] accounts.reservationList is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[DeprecatedCreateReservationList] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[DeprecatedCreateReservationList] accounts.updateAuthority is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[DeprecatedCreateReservationList] accounts.masterEdition is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[DeprecatedCreateReservationList] accounts.resource is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[DeprecatedCreateReservationList] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[DeprecatedCreateReservationList] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[DeprecatedCreateReservationList] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *DeprecatedCreateReservationList) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *DeprecatedCreateReservationList) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *DeprecatedCreateReservationList) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *DeprecatedCreateReservationList) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("DeprecatedCreateReservationList")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=8]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("reservationList", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("          payer", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("updateAuthority", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("  masterEdition", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("       resource", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("       metadata", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("  systemProgram", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("           rent", obj.AccountMetaSlice.Get(7)))
					})
				})
		})
}

// SignMetadata Instruction
type SignMetadata struct {
	// [0] = [WRITE] metadata `Metadata (pda of ['metadata', program id, mint id])`
	// [1] = [SIGNER] creator `Creator`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewSignMetadataInstructionBuilder creates a new `SignMetadata` instruction builder.
func NewSignMetadataInstructionBuilder() *SignMetadata {
	return &SignMetadata{
		AccountMetaSlice: make(common.AccountMetaSlice, 2),
	}
}

// NewSignMetadataInstruction
//
// Parameters:
//
//	metadata: Metadata (pda of ['metadata', program id, mint id])
//	creator: Creator
func NewSignMetadataInstruction(
	metadata common.PublicKey,
	creator common.PublicKey,
) *SignMetadata {
	return NewSignMetadataInstructionBuilder().
		SetMetadataAccount(metadata).
		SetCreatorAccount(creator)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata (pda of ['metadata', program id, mint id])
func (obj *SignMetadata) SetMetadataAccount(metadata common.PublicKey) *SignMetadata {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata (pda of ['metadata', program id, mint id])
func (obj *SignMetadata) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetCreatorAccount sets the "creator" parameter.
// Creator
func (obj *SignMetadata) SetCreatorAccount(creator common.PublicKey, multiSigners ...common.PublicKey) *SignMetadata {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[1] = common.Meta(creator)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[1] = common.Meta(creator).SIGNER()
	}
	return obj
}

// GetCreatorAccount gets the "creator" parameter.
// Creator
func (obj *SignMetadata) GetCreatorAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

func (obj *SignMetadata) SetProgramId(programId *common.PublicKey) *SignMetadata {
	obj._programId = programId
	return obj
}

func (obj *SignMetadata) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_SignMetadata}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *SignMetadata) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[SignMetadata] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[SignMetadata] accounts.creator is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *SignMetadata) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *SignMetadata) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *SignMetadata) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *SignMetadata) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("SignMetadata")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=2]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta(" creator", obj.AccountMetaSlice.Get(1)))
					})
				})
		})
}

// DeprecatedMintPrintingTokensViaToken Instruction
type DeprecatedMintPrintingTokensViaToken struct {
	// [0] = [WRITE] destination `Destination account`
	// [1] = [WRITE] token `Token account containing one time authorization token`
	// [2] = [WRITE] oneTimePrintingAuthorizationMint `One time authorization mint`
	// [3] = [WRITE] printingMint `Printing mint`
	// [4] = [SIGNER] burnAuthority `Burn authority`
	// [5] = [] metadata `Metadata key (pda of ['metadata', program id, mint id])`
	// [6] = [] masterEdition `Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])`
	// [7] = [] tokenProgram `Token program`
	// [8] = [] rent `Rent`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewDeprecatedMintPrintingTokensViaTokenInstructionBuilder creates a new `DeprecatedMintPrintingTokensViaToken` instruction builder.
func NewDeprecatedMintPrintingTokensViaTokenInstructionBuilder() *DeprecatedMintPrintingTokensViaToken {
	return &DeprecatedMintPrintingTokensViaToken{
		AccountMetaSlice: make(common.AccountMetaSlice, 9),
	}
}

// NewDeprecatedMintPrintingTokensViaTokenInstruction
//
// Parameters:
//
//	destination: Destination account
//	token: Token account containing one time authorization token
//	oneTimePrintingAuthorizationMint: One time authorization mint
//	printingMint: Printing mint
//	burnAuthority: Burn authority
//	metadata: Metadata key (pda of ['metadata', program id, mint id])
//	masterEdition: Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])
//	tokenProgram: Token program
//	rent: Rent
func NewDeprecatedMintPrintingTokensViaTokenInstruction(
	destination common.PublicKey,
	token common.PublicKey,
	oneTimePrintingAuthorizationMint common.PublicKey,
	printingMint common.PublicKey,
	burnAuthority common.PublicKey,
	metadata common.PublicKey,
	masterEdition common.PublicKey,
	tokenProgram common.PublicKey,
	rent common.PublicKey,
) *DeprecatedMintPrintingTokensViaToken {
	return NewDeprecatedMintPrintingTokensViaTokenInstructionBuilder().
		SetDestinationAccount(destination).
		SetTokenAccount(token).
		SetOneTimePrintingAuthorizationMintAccount(oneTimePrintingAuthorizationMint).
		SetPrintingMintAccount(printingMint).
		SetBurnAuthorityAccount(burnAuthority).
		SetMetadataAccount(metadata).
		SetMasterEditionAccount(masterEdition).
		SetTokenProgramAccount(tokenProgram).
		SetRentAccount(rent)
}

// SetDestinationAccount sets the "destination" parameter.
// Destination account
func (obj *DeprecatedMintPrintingTokensViaToken) SetDestinationAccount(destination common.PublicKey) *DeprecatedMintPrintingTokensViaToken {
	obj.AccountMetaSlice[0] = common.Meta(destination).WRITE()
	return obj
}

// GetDestinationAccount gets the "destination" parameter.
// Destination account
func (obj *DeprecatedMintPrintingTokensViaToken) GetDestinationAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetTokenAccount sets the "token" parameter.
// Token account containing one time authorization token
func (obj *DeprecatedMintPrintingTokensViaToken) SetTokenAccount(token common.PublicKey) *DeprecatedMintPrintingTokensViaToken {
	obj.AccountMetaSlice[1] = common.Meta(token).WRITE()
	return obj
}

// GetTokenAccount gets the "token" parameter.
// Token account containing one time authorization token
func (obj *DeprecatedMintPrintingTokensViaToken) GetTokenAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetOneTimePrintingAuthorizationMintAccount sets the "oneTimePrintingAuthorizationMint" parameter.
// One time authorization mint
func (obj *DeprecatedMintPrintingTokensViaToken) SetOneTimePrintingAuthorizationMintAccount(oneTimePrintingAuthorizationMint common.PublicKey) *DeprecatedMintPrintingTokensViaToken {
	obj.AccountMetaSlice[2] = common.Meta(oneTimePrintingAuthorizationMint).WRITE()
	return obj
}

// GetOneTimePrintingAuthorizationMintAccount gets the "oneTimePrintingAuthorizationMint" parameter.
// One time authorization mint
func (obj *DeprecatedMintPrintingTokensViaToken) GetOneTimePrintingAuthorizationMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetPrintingMintAccount sets the "printingMint" parameter.
// Printing mint
func (obj *DeprecatedMintPrintingTokensViaToken) SetPrintingMintAccount(printingMint common.PublicKey) *DeprecatedMintPrintingTokensViaToken {
	obj.AccountMetaSlice[3] = common.Meta(printingMint).WRITE()
	return obj
}

// GetPrintingMintAccount gets the "printingMint" parameter.
// Printing mint
func (obj *DeprecatedMintPrintingTokensViaToken) GetPrintingMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetBurnAuthorityAccount sets the "burnAuthority" parameter.
// Burn authority
func (obj *DeprecatedMintPrintingTokensViaToken) SetBurnAuthorityAccount(burnAuthority common.PublicKey) *DeprecatedMintPrintingTokensViaToken {
	obj.AccountMetaSlice[4] = common.Meta(burnAuthority).SIGNER()
	return obj
}

// GetBurnAuthorityAccount gets the "burnAuthority" parameter.
// Burn authority
func (obj *DeprecatedMintPrintingTokensViaToken) GetBurnAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata key (pda of ['metadata', program id, mint id])
func (obj *DeprecatedMintPrintingTokensViaToken) SetMetadataAccount(metadata common.PublicKey) *DeprecatedMintPrintingTokensViaToken {
	obj.AccountMetaSlice[5] = common.Meta(metadata)
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata key (pda of ['metadata', program id, mint id])
func (obj *DeprecatedMintPrintingTokensViaToken) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetMasterEditionAccount sets the "masterEdition" parameter.
// Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])
func (obj *DeprecatedMintPrintingTokensViaToken) SetMasterEditionAccount(masterEdition common.PublicKey) *DeprecatedMintPrintingTokensViaToken {
	obj.AccountMetaSlice[6] = common.Meta(masterEdition)
	return obj
}

// GetMasterEditionAccount gets the "masterEdition" parameter.
// Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])
func (obj *DeprecatedMintPrintingTokensViaToken) GetMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetTokenProgramAccount sets the "tokenProgram" parameter.
// Token program
func (obj *DeprecatedMintPrintingTokensViaToken) SetTokenProgramAccount(tokenProgram common.PublicKey) *DeprecatedMintPrintingTokensViaToken {
	obj.AccountMetaSlice[7] = common.Meta(tokenProgram)
	return obj
}

// GetTokenProgramAccount gets the "tokenProgram" parameter.
// Token program
func (obj *DeprecatedMintPrintingTokensViaToken) GetTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetRentAccount sets the "rent" parameter.
// Rent
func (obj *DeprecatedMintPrintingTokensViaToken) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *DeprecatedMintPrintingTokensViaToken {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[8] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[8] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent
func (obj *DeprecatedMintPrintingTokensViaToken) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

func (obj *DeprecatedMintPrintingTokensViaToken) SetProgramId(programId *common.PublicKey) *DeprecatedMintPrintingTokensViaToken {
	obj._programId = programId
	return obj
}

func (obj *DeprecatedMintPrintingTokensViaToken) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_DeprecatedMintPrintingTokensViaToken}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *DeprecatedMintPrintingTokensViaToken) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[DeprecatedMintPrintingTokensViaToken] accounts.destination is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[DeprecatedMintPrintingTokensViaToken] accounts.token is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[DeprecatedMintPrintingTokensViaToken] accounts.oneTimePrintingAuthorizationMint is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[DeprecatedMintPrintingTokensViaToken] accounts.printingMint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[DeprecatedMintPrintingTokensViaToken] accounts.burnAuthority is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[DeprecatedMintPrintingTokensViaToken] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[DeprecatedMintPrintingTokensViaToken] accounts.masterEdition is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[DeprecatedMintPrintingTokensViaToken] accounts.tokenProgram is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[DeprecatedMintPrintingTokensViaToken] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *DeprecatedMintPrintingTokensViaToken) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *DeprecatedMintPrintingTokensViaToken) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *DeprecatedMintPrintingTokensViaToken) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *DeprecatedMintPrintingTokensViaToken) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("DeprecatedMintPrintingTokensViaToken")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=9]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                     destination", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("                           token", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("oneTimePrintingAuthorizationMint", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("                    printingMint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                   burnAuthority", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                        metadata", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("                   masterEdition", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("                    tokenProgram", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("                            rent", obj.AccountMetaSlice.Get(8)))
					})
				})
		})
}

// DeprecatedMintPrintingTokens Instruction
type DeprecatedMintPrintingTokens struct {
	// [0] = [WRITE] destination `Destination account`
	// [1] = [WRITE] printingMint `Printing mint`
	// [2] = [SIGNER] updateAuthority `Update authority`
	// [3] = [] metadata `Metadata key (pda of ['metadata', program id, mint id])`
	// [4] = [] masterEdition `Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])`
	// [5] = [] tokenProgram `Token program`
	// [6] = [] rent `Rent`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewDeprecatedMintPrintingTokensInstructionBuilder creates a new `DeprecatedMintPrintingTokens` instruction builder.
func NewDeprecatedMintPrintingTokensInstructionBuilder() *DeprecatedMintPrintingTokens {
	return &DeprecatedMintPrintingTokens{
		AccountMetaSlice: make(common.AccountMetaSlice, 7),
	}
}

// NewDeprecatedMintPrintingTokensInstruction
//
// Parameters:
//
//	destination: Destination account
//	printingMint: Printing mint
//	updateAuthority: Update authority
//	metadata: Metadata key (pda of ['metadata', program id, mint id])
//	masterEdition: Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])
//	tokenProgram: Token program
//	rent: Rent
func NewDeprecatedMintPrintingTokensInstruction(
	destination common.PublicKey,
	printingMint common.PublicKey,
	updateAuthority common.PublicKey,
	metadata common.PublicKey,
	masterEdition common.PublicKey,
	tokenProgram common.PublicKey,
	rent common.PublicKey,
) *DeprecatedMintPrintingTokens {
	return NewDeprecatedMintPrintingTokensInstructionBuilder().
		SetDestinationAccount(destination).
		SetPrintingMintAccount(printingMint).
		SetUpdateAuthorityAccount(updateAuthority).
		SetMetadataAccount(metadata).
		SetMasterEditionAccount(masterEdition).
		SetTokenProgramAccount(tokenProgram).
		SetRentAccount(rent)
}

// SetDestinationAccount sets the "destination" parameter.
// Destination account
func (obj *DeprecatedMintPrintingTokens) SetDestinationAccount(destination common.PublicKey) *DeprecatedMintPrintingTokens {
	obj.AccountMetaSlice[0] = common.Meta(destination).WRITE()
	return obj
}

// GetDestinationAccount gets the "destination" parameter.
// Destination account
func (obj *DeprecatedMintPrintingTokens) GetDestinationAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetPrintingMintAccount sets the "printingMint" parameter.
// Printing mint
func (obj *DeprecatedMintPrintingTokens) SetPrintingMintAccount(printingMint common.PublicKey) *DeprecatedMintPrintingTokens {
	obj.AccountMetaSlice[1] = common.Meta(printingMint).WRITE()
	return obj
}

// GetPrintingMintAccount gets the "printingMint" parameter.
// Printing mint
func (obj *DeprecatedMintPrintingTokens) GetPrintingMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// Update authority
func (obj *DeprecatedMintPrintingTokens) SetUpdateAuthorityAccount(updateAuthority common.PublicKey) *DeprecatedMintPrintingTokens {
	obj.AccountMetaSlice[2] = common.Meta(updateAuthority).SIGNER()
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// Update authority
func (obj *DeprecatedMintPrintingTokens) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata key (pda of ['metadata', program id, mint id])
func (obj *DeprecatedMintPrintingTokens) SetMetadataAccount(metadata common.PublicKey) *DeprecatedMintPrintingTokens {
	obj.AccountMetaSlice[3] = common.Meta(metadata)
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata key (pda of ['metadata', program id, mint id])
func (obj *DeprecatedMintPrintingTokens) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetMasterEditionAccount sets the "masterEdition" parameter.
// Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])
func (obj *DeprecatedMintPrintingTokens) SetMasterEditionAccount(masterEdition common.PublicKey) *DeprecatedMintPrintingTokens {
	obj.AccountMetaSlice[4] = common.Meta(masterEdition)
	return obj
}

// GetMasterEditionAccount gets the "masterEdition" parameter.
// Master Edition V1 key (pda of ['metadata', program id, mint id, 'edition'])
func (obj *DeprecatedMintPrintingTokens) GetMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetTokenProgramAccount sets the "tokenProgram" parameter.
// Token program
func (obj *DeprecatedMintPrintingTokens) SetTokenProgramAccount(tokenProgram common.PublicKey) *DeprecatedMintPrintingTokens {
	obj.AccountMetaSlice[5] = common.Meta(tokenProgram)
	return obj
}

// GetTokenProgramAccount gets the "tokenProgram" parameter.
// Token program
func (obj *DeprecatedMintPrintingTokens) GetTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetRentAccount sets the "rent" parameter.
// Rent
func (obj *DeprecatedMintPrintingTokens) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *DeprecatedMintPrintingTokens {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[6] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[6] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent
func (obj *DeprecatedMintPrintingTokens) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

func (obj *DeprecatedMintPrintingTokens) SetProgramId(programId *common.PublicKey) *DeprecatedMintPrintingTokens {
	obj._programId = programId
	return obj
}

func (obj *DeprecatedMintPrintingTokens) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_DeprecatedMintPrintingTokens}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *DeprecatedMintPrintingTokens) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[DeprecatedMintPrintingTokens] accounts.destination is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[DeprecatedMintPrintingTokens] accounts.printingMint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[DeprecatedMintPrintingTokens] accounts.updateAuthority is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[DeprecatedMintPrintingTokens] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[DeprecatedMintPrintingTokens] accounts.masterEdition is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[DeprecatedMintPrintingTokens] accounts.tokenProgram is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[DeprecatedMintPrintingTokens] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *DeprecatedMintPrintingTokens) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *DeprecatedMintPrintingTokens) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *DeprecatedMintPrintingTokens) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *DeprecatedMintPrintingTokens) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("DeprecatedMintPrintingTokens")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=7]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("    destination", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("   printingMint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("updateAuthority", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("       metadata", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("  masterEdition", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("   tokenProgram", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("           rent", obj.AccountMetaSlice.Get(6)))
					})
				})
		})
}

// CreateMasterEdition Instruction
type CreateMasterEdition struct {
	// [0] = [WRITE] edition `Unallocated edition V2 account with address as pda of ['metadata', program id, mint, 'edition']`
	// [1] = [WRITE] mint `Metadata mint`
	// [2] = [SIGNER] updateAuthority `Update authority`
	// [3] = [SIGNER] mintAuthority `Mint authority on the metadata's mint - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY`
	// [4] = [WRITE, SIGNER] payer `payer`
	// [5] = [] metadata `Metadata account`
	// [6] = [] tokenProgram `Token program`
	// [7] = [] systemProgram `System program`
	// [8] = [] rent `Rent info`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewCreateMasterEditionInstructionBuilder creates a new `CreateMasterEdition` instruction builder.
func NewCreateMasterEditionInstructionBuilder() *CreateMasterEdition {
	return &CreateMasterEdition{
		AccountMetaSlice: make(common.AccountMetaSlice, 9),
	}
}

// NewCreateMasterEditionInstruction
//
// Parameters:
//
//	edition: Unallocated edition V2 account with address as pda of ['metadata', program id, mint, 'edition']
//	mint: Metadata mint
//	updateAuthority: Update authority
//	mintAuthority: Mint authority on the metadata's mint - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
//	payer: payer
//	metadata: Metadata account
//	tokenProgram: Token program
//	systemProgram: System program
//	rent: Rent info
func NewCreateMasterEditionInstruction(
	edition common.PublicKey,
	mint common.PublicKey,
	updateAuthority common.PublicKey,
	mintAuthority common.PublicKey,
	payer common.PublicKey,
	metadata common.PublicKey,
	tokenProgram common.PublicKey,
	systemProgram common.PublicKey,
	rent common.PublicKey,
) *CreateMasterEdition {
	return NewCreateMasterEditionInstructionBuilder().
		SetEditionAccount(edition).
		SetMintAccount(mint).
		SetUpdateAuthorityAccount(updateAuthority).
		SetMintAuthorityAccount(mintAuthority).
		SetPayerAccount(payer).
		SetMetadataAccount(metadata).
		SetTokenProgramAccount(tokenProgram).
		SetSystemProgramAccount(systemProgram).
		SetRentAccount(rent)
}

// SetEditionAccount sets the "edition" parameter.
// Unallocated edition V2 account with address as pda of ['metadata', program id, mint, 'edition']
func (obj *CreateMasterEdition) SetEditionAccount(edition common.PublicKey) *CreateMasterEdition {
	obj.AccountMetaSlice[0] = common.Meta(edition).WRITE()
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Unallocated edition V2 account with address as pda of ['metadata', program id, mint, 'edition']
func (obj *CreateMasterEdition) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// Metadata mint
func (obj *CreateMasterEdition) SetMintAccount(mint common.PublicKey) *CreateMasterEdition {
	obj.AccountMetaSlice[1] = common.Meta(mint).WRITE()
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Metadata mint
func (obj *CreateMasterEdition) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// Update authority
func (obj *CreateMasterEdition) SetUpdateAuthorityAccount(updateAuthority common.PublicKey) *CreateMasterEdition {
	obj.AccountMetaSlice[2] = common.Meta(updateAuthority).SIGNER()
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// Update authority
func (obj *CreateMasterEdition) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMintAuthorityAccount sets the "mintAuthority" parameter.
// Mint authority on the metadata's mint - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
func (obj *CreateMasterEdition) SetMintAuthorityAccount(mintAuthority common.PublicKey) *CreateMasterEdition {
	obj.AccountMetaSlice[3] = common.Meta(mintAuthority).SIGNER()
	return obj
}

// GetMintAuthorityAccount gets the "mintAuthority" parameter.
// Mint authority on the metadata's mint - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
func (obj *CreateMasterEdition) GetMintAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetPayerAccount sets the "payer" parameter.
// payer
func (obj *CreateMasterEdition) SetPayerAccount(payer common.PublicKey) *CreateMasterEdition {
	obj.AccountMetaSlice[4] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// payer
func (obj *CreateMasterEdition) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *CreateMasterEdition) SetMetadataAccount(metadata common.PublicKey) *CreateMasterEdition {
	obj.AccountMetaSlice[5] = common.Meta(metadata)
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *CreateMasterEdition) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetTokenProgramAccount sets the "tokenProgram" parameter.
// Token program
func (obj *CreateMasterEdition) SetTokenProgramAccount(tokenProgram common.PublicKey) *CreateMasterEdition {
	obj.AccountMetaSlice[6] = common.Meta(tokenProgram)
	return obj
}

// GetTokenProgramAccount gets the "tokenProgram" parameter.
// Token program
func (obj *CreateMasterEdition) GetTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *CreateMasterEdition) SetSystemProgramAccount(systemProgram common.PublicKey) *CreateMasterEdition {
	obj.AccountMetaSlice[7] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *CreateMasterEdition) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetRentAccount sets the "rent" parameter.
// Rent info
func (obj *CreateMasterEdition) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *CreateMasterEdition {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[8] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[8] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent info
func (obj *CreateMasterEdition) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

func (obj *CreateMasterEdition) SetProgramId(programId *common.PublicKey) *CreateMasterEdition {
	obj._programId = programId
	return obj
}

func (obj *CreateMasterEdition) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_CreateMasterEdition}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *CreateMasterEdition) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[CreateMasterEdition] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[CreateMasterEdition] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[CreateMasterEdition] accounts.updateAuthority is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[CreateMasterEdition] accounts.mintAuthority is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[CreateMasterEdition] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[CreateMasterEdition] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[CreateMasterEdition] accounts.tokenProgram is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[CreateMasterEdition] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[CreateMasterEdition] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *CreateMasterEdition) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *CreateMasterEdition) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *CreateMasterEdition) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *CreateMasterEdition) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("CreateMasterEdition")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=9]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("        edition", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("           mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("updateAuthority", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("  mintAuthority", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("          payer", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("       metadata", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("   tokenProgram", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("  systemProgram", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("           rent", obj.AccountMetaSlice.Get(8)))
					})
				})
		})
}

// MintNewEditionFromMasterEditionViaToken Instruction
type MintNewEditionFromMasterEditionViaToken struct {
	MintNewEditionFromMasterEditionViaTokenArgs *MintNewEditionFromMasterEditionViaTokenArgs
	// [0] = [WRITE] newMetadata `New Metadata key (pda of ['metadata', program id, mint id])`
	// [1] = [WRITE] newEdition `New Edition (pda of ['metadata', program id, mint id, 'edition'])`
	// [2] = [WRITE] masterEdition `Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition'])`
	// [3] = [WRITE] newMint `Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY`
	// [4] = [WRITE] editionMarkPda `Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE).`
	// [5] = [SIGNER] newMintAuthority `Mint authority of new mint`
	// [6] = [WRITE, SIGNER] payer `payer`
	// [7] = [SIGNER] tokenAccountOwner `owner of token account containing master token (#8)`
	// [8] = [] tokenAccount `token account containing token from master metadata mint`
	// [9] = [] newMetadataUpdateAuthority `Update authority info for new metadata`
	// [10] = [] metadata `Master record metadata account`
	// [11] = [] tokenProgram `Token program`
	// [12] = [] systemProgram `System program`
	// [13] = [] rent `Rent info`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewMintNewEditionFromMasterEditionViaTokenInstructionBuilder creates a new `MintNewEditionFromMasterEditionViaToken` instruction builder.
func NewMintNewEditionFromMasterEditionViaTokenInstructionBuilder() *MintNewEditionFromMasterEditionViaToken {
	return &MintNewEditionFromMasterEditionViaToken{
		AccountMetaSlice: make(common.AccountMetaSlice, 14),
	}
}

// NewMintNewEditionFromMasterEditionViaTokenInstruction
//
// Parameters:
//
//	mintNewEditionFromMasterEditionViaTokenArgs:
//	newMetadata: New Metadata key (pda of ['metadata', program id, mint id])
//	newEdition: New Edition (pda of ['metadata', program id, mint id, 'edition'])
//	masterEdition: Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition'])
//	newMint: Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
//	editionMarkPda: Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE).
//	newMintAuthority: Mint authority of new mint
//	payer: payer
//	tokenAccountOwner: owner of token account containing master token (#8)
//	tokenAccount: token account containing token from master metadata mint
//	newMetadataUpdateAuthority: Update authority info for new metadata
//	metadata: Master record metadata account
//	tokenProgram: Token program
//	systemProgram: System program
//	rent: Rent info
func NewMintNewEditionFromMasterEditionViaTokenInstruction(
	mintNewEditionFromMasterEditionViaTokenArgs MintNewEditionFromMasterEditionViaTokenArgs,
	newMetadata common.PublicKey,
	newEdition common.PublicKey,
	masterEdition common.PublicKey,
	newMint common.PublicKey,
	editionMarkPda common.PublicKey,
	newMintAuthority common.PublicKey,
	payer common.PublicKey,
	tokenAccountOwner common.PublicKey,
	tokenAccount common.PublicKey,
	newMetadataUpdateAuthority common.PublicKey,
	metadata common.PublicKey,
	tokenProgram common.PublicKey,
	systemProgram common.PublicKey,
	rent common.PublicKey,
) *MintNewEditionFromMasterEditionViaToken {
	return NewMintNewEditionFromMasterEditionViaTokenInstructionBuilder().
		SetMintNewEditionFromMasterEditionViaTokenArgs(mintNewEditionFromMasterEditionViaTokenArgs).
		SetNewMetadataAccount(newMetadata).
		SetNewEditionAccount(newEdition).
		SetMasterEditionAccount(masterEdition).
		SetNewMintAccount(newMint).
		SetEditionMarkPdaAccount(editionMarkPda).
		SetNewMintAuthorityAccount(newMintAuthority).
		SetPayerAccount(payer).
		SetTokenAccountOwnerAccount(tokenAccountOwner).
		SetTokenAccountAccount(tokenAccount).
		SetNewMetadataUpdateAuthorityAccount(newMetadataUpdateAuthority).
		SetMetadataAccount(metadata).
		SetTokenProgramAccount(tokenProgram).
		SetSystemProgramAccount(systemProgram).
		SetRentAccount(rent)
}

// SetMintNewEditionFromMasterEditionViaTokenArgs sets the "mintNewEditionFromMasterEditionViaTokenArgs" parameter.
func (obj *MintNewEditionFromMasterEditionViaToken) SetMintNewEditionFromMasterEditionViaTokenArgs(mintNewEditionFromMasterEditionViaTokenArgs MintNewEditionFromMasterEditionViaTokenArgs) *MintNewEditionFromMasterEditionViaToken {
	obj.MintNewEditionFromMasterEditionViaTokenArgs = &mintNewEditionFromMasterEditionViaTokenArgs
	return obj
}

// SetNewMetadataAccount sets the "newMetadata" parameter.
// New Metadata key (pda of ['metadata', program id, mint id])
func (obj *MintNewEditionFromMasterEditionViaToken) SetNewMetadataAccount(newMetadata common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	obj.AccountMetaSlice[0] = common.Meta(newMetadata).WRITE()
	return obj
}

// GetNewMetadataAccount gets the "newMetadata" parameter.
// New Metadata key (pda of ['metadata', program id, mint id])
func (obj *MintNewEditionFromMasterEditionViaToken) GetNewMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetNewEditionAccount sets the "newEdition" parameter.
// New Edition (pda of ['metadata', program id, mint id, 'edition'])
func (obj *MintNewEditionFromMasterEditionViaToken) SetNewEditionAccount(newEdition common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	obj.AccountMetaSlice[1] = common.Meta(newEdition).WRITE()
	return obj
}

// GetNewEditionAccount gets the "newEdition" parameter.
// New Edition (pda of ['metadata', program id, mint id, 'edition'])
func (obj *MintNewEditionFromMasterEditionViaToken) GetNewEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMasterEditionAccount sets the "masterEdition" parameter.
// Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition'])
func (obj *MintNewEditionFromMasterEditionViaToken) SetMasterEditionAccount(masterEdition common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	obj.AccountMetaSlice[2] = common.Meta(masterEdition).WRITE()
	return obj
}

// GetMasterEditionAccount gets the "masterEdition" parameter.
// Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition'])
func (obj *MintNewEditionFromMasterEditionViaToken) GetMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetNewMintAccount sets the "newMint" parameter.
// Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
func (obj *MintNewEditionFromMasterEditionViaToken) SetNewMintAccount(newMint common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	obj.AccountMetaSlice[3] = common.Meta(newMint).WRITE()
	return obj
}

// GetNewMintAccount gets the "newMint" parameter.
// Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
func (obj *MintNewEditionFromMasterEditionViaToken) GetNewMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetEditionMarkPdaAccount sets the "editionMarkPda" parameter.
// Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE).
func (obj *MintNewEditionFromMasterEditionViaToken) SetEditionMarkPdaAccount(editionMarkPda common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	obj.AccountMetaSlice[4] = common.Meta(editionMarkPda).WRITE()
	return obj
}

// GetEditionMarkPdaAccount gets the "editionMarkPda" parameter.
// Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE).
func (obj *MintNewEditionFromMasterEditionViaToken) GetEditionMarkPdaAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetNewMintAuthorityAccount sets the "newMintAuthority" parameter.
// Mint authority of new mint
func (obj *MintNewEditionFromMasterEditionViaToken) SetNewMintAuthorityAccount(newMintAuthority common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	obj.AccountMetaSlice[5] = common.Meta(newMintAuthority).SIGNER()
	return obj
}

// GetNewMintAuthorityAccount gets the "newMintAuthority" parameter.
// Mint authority of new mint
func (obj *MintNewEditionFromMasterEditionViaToken) GetNewMintAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetPayerAccount sets the "payer" parameter.
// payer
func (obj *MintNewEditionFromMasterEditionViaToken) SetPayerAccount(payer common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	obj.AccountMetaSlice[6] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// payer
func (obj *MintNewEditionFromMasterEditionViaToken) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetTokenAccountOwnerAccount sets the "tokenAccountOwner" parameter.
// owner of token account containing master token (#8)
func (obj *MintNewEditionFromMasterEditionViaToken) SetTokenAccountOwnerAccount(tokenAccountOwner common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	obj.AccountMetaSlice[7] = common.Meta(tokenAccountOwner).SIGNER()
	return obj
}

// GetTokenAccountOwnerAccount gets the "tokenAccountOwner" parameter.
// owner of token account containing master token (#8)
func (obj *MintNewEditionFromMasterEditionViaToken) GetTokenAccountOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetTokenAccountAccount sets the "tokenAccount" parameter.
// token account containing token from master metadata mint
func (obj *MintNewEditionFromMasterEditionViaToken) SetTokenAccountAccount(tokenAccount common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	obj.AccountMetaSlice[8] = common.Meta(tokenAccount)
	return obj
}

// GetTokenAccountAccount gets the "tokenAccount" parameter.
// token account containing token from master metadata mint
func (obj *MintNewEditionFromMasterEditionViaToken) GetTokenAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetNewMetadataUpdateAuthorityAccount sets the "newMetadataUpdateAuthority" parameter.
// Update authority info for new metadata
func (obj *MintNewEditionFromMasterEditionViaToken) SetNewMetadataUpdateAuthorityAccount(newMetadataUpdateAuthority common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	obj.AccountMetaSlice[9] = common.Meta(newMetadataUpdateAuthority)
	return obj
}

// GetNewMetadataUpdateAuthorityAccount gets the "newMetadataUpdateAuthority" parameter.
// Update authority info for new metadata
func (obj *MintNewEditionFromMasterEditionViaToken) GetNewMetadataUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetMetadataAccount sets the "metadata" parameter.
// Master record metadata account
func (obj *MintNewEditionFromMasterEditionViaToken) SetMetadataAccount(metadata common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	obj.AccountMetaSlice[10] = common.Meta(metadata)
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Master record metadata account
func (obj *MintNewEditionFromMasterEditionViaToken) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetTokenProgramAccount sets the "tokenProgram" parameter.
// Token program
func (obj *MintNewEditionFromMasterEditionViaToken) SetTokenProgramAccount(tokenProgram common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	obj.AccountMetaSlice[11] = common.Meta(tokenProgram)
	return obj
}

// GetTokenProgramAccount gets the "tokenProgram" parameter.
// Token program
func (obj *MintNewEditionFromMasterEditionViaToken) GetTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *MintNewEditionFromMasterEditionViaToken) SetSystemProgramAccount(systemProgram common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	obj.AccountMetaSlice[12] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *MintNewEditionFromMasterEditionViaToken) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(12)
}

// SetRentAccount sets the "rent" parameter.
// Rent info
func (obj *MintNewEditionFromMasterEditionViaToken) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[13] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[13] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent info
func (obj *MintNewEditionFromMasterEditionViaToken) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(13)
}

func (obj *MintNewEditionFromMasterEditionViaToken) SetProgramId(programId *common.PublicKey) *MintNewEditionFromMasterEditionViaToken {
	obj._programId = programId
	return obj
}

func (obj *MintNewEditionFromMasterEditionViaToken) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_MintNewEditionFromMasterEditionViaToken}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *MintNewEditionFromMasterEditionViaToken) Validate() error {
	if obj.MintNewEditionFromMasterEditionViaTokenArgs == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] mintNewEditionFromMasterEditionViaTokenArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] accounts.newMetadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] accounts.newEdition is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] accounts.masterEdition is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] accounts.newMint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] accounts.editionMarkPda is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] accounts.newMintAuthority is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] accounts.tokenAccountOwner is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] accounts.tokenAccount is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] accounts.newMetadataUpdateAuthority is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] accounts.tokenProgram is not set")
	}
	if obj.AccountMetaSlice[12] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[13] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaToken] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *MintNewEditionFromMasterEditionViaToken) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *MintNewEditionFromMasterEditionViaToken) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.MintNewEditionFromMasterEditionViaTokenArgs); err != nil {
		return err
	}
	return nil
}

func (obj *MintNewEditionFromMasterEditionViaToken) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.MintNewEditionFromMasterEditionViaTokenArgs); err != nil {
		return err
	}
	return nil
}

func (obj *MintNewEditionFromMasterEditionViaToken) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("MintNewEditionFromMasterEditionViaToken")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("MintNewEditionFromMasterEditionViaTokenArgs", *obj.MintNewEditionFromMasterEditionViaTokenArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=14]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("               newMetadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("                newEdition", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("             masterEdition", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("                   newMint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("            editionMarkPda", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("          newMintAuthority", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("                     payer", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("         tokenAccountOwner", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("              tokenAccount", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("newMetadataUpdateAuthority", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("                  metadata", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("              tokenProgram", obj.AccountMetaSlice.Get(11)))
						accountsBranch.Child(common.FormatMeta("             systemProgram", obj.AccountMetaSlice.Get(12)))
						accountsBranch.Child(common.FormatMeta("                      rent", obj.AccountMetaSlice.Get(13)))
					})
				})
		})
}

// ConvertMasterEditionV1ToV2 Instruction
type ConvertMasterEditionV1ToV2 struct {
	// [0] = [WRITE] masterEdition `Master Record Edition V1 (pda of ['metadata', program id, master metadata mint id, 'edition'])`
	// [1] = [WRITE] oneTimeAuth `One time authorization mint`
	// [2] = [WRITE] printingMint `Printing mint`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewConvertMasterEditionV1ToV2InstructionBuilder creates a new `ConvertMasterEditionV1ToV2` instruction builder.
func NewConvertMasterEditionV1ToV2InstructionBuilder() *ConvertMasterEditionV1ToV2 {
	return &ConvertMasterEditionV1ToV2{
		AccountMetaSlice: make(common.AccountMetaSlice, 3),
	}
}

// NewConvertMasterEditionV1ToV2Instruction
//
// Parameters:
//
//	masterEdition: Master Record Edition V1 (pda of ['metadata', program id, master metadata mint id, 'edition'])
//	oneTimeAuth: One time authorization mint
//	printingMint: Printing mint
func NewConvertMasterEditionV1ToV2Instruction(
	masterEdition common.PublicKey,
	oneTimeAuth common.PublicKey,
	printingMint common.PublicKey,
) *ConvertMasterEditionV1ToV2 {
	return NewConvertMasterEditionV1ToV2InstructionBuilder().
		SetMasterEditionAccount(masterEdition).
		SetOneTimeAuthAccount(oneTimeAuth).
		SetPrintingMintAccount(printingMint)
}

// SetMasterEditionAccount sets the "masterEdition" parameter.
// Master Record Edition V1 (pda of ['metadata', program id, master metadata mint id, 'edition'])
func (obj *ConvertMasterEditionV1ToV2) SetMasterEditionAccount(masterEdition common.PublicKey) *ConvertMasterEditionV1ToV2 {
	obj.AccountMetaSlice[0] = common.Meta(masterEdition).WRITE()
	return obj
}

// GetMasterEditionAccount gets the "masterEdition" parameter.
// Master Record Edition V1 (pda of ['metadata', program id, master metadata mint id, 'edition'])
func (obj *ConvertMasterEditionV1ToV2) GetMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetOneTimeAuthAccount sets the "oneTimeAuth" parameter.
// One time authorization mint
func (obj *ConvertMasterEditionV1ToV2) SetOneTimeAuthAccount(oneTimeAuth common.PublicKey) *ConvertMasterEditionV1ToV2 {
	obj.AccountMetaSlice[1] = common.Meta(oneTimeAuth).WRITE()
	return obj
}

// GetOneTimeAuthAccount gets the "oneTimeAuth" parameter.
// One time authorization mint
func (obj *ConvertMasterEditionV1ToV2) GetOneTimeAuthAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetPrintingMintAccount sets the "printingMint" parameter.
// Printing mint
func (obj *ConvertMasterEditionV1ToV2) SetPrintingMintAccount(printingMint common.PublicKey, multiSigners ...common.PublicKey) *ConvertMasterEditionV1ToV2 {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[2] = common.Meta(printingMint)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[2] = common.Meta(printingMint).WRITE()
	}
	return obj
}

// GetPrintingMintAccount gets the "printingMint" parameter.
// Printing mint
func (obj *ConvertMasterEditionV1ToV2) GetPrintingMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

func (obj *ConvertMasterEditionV1ToV2) SetProgramId(programId *common.PublicKey) *ConvertMasterEditionV1ToV2 {
	obj._programId = programId
	return obj
}

func (obj *ConvertMasterEditionV1ToV2) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_ConvertMasterEditionV1ToV2}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *ConvertMasterEditionV1ToV2) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[ConvertMasterEditionV1ToV2] accounts.masterEdition is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[ConvertMasterEditionV1ToV2] accounts.oneTimeAuth is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[ConvertMasterEditionV1ToV2] accounts.printingMint is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *ConvertMasterEditionV1ToV2) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *ConvertMasterEditionV1ToV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *ConvertMasterEditionV1ToV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *ConvertMasterEditionV1ToV2) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("ConvertMasterEditionV1ToV2")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=3]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("masterEdition", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("  oneTimeAuth", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta(" printingMint", obj.AccountMetaSlice.Get(2)))
					})
				})
		})
}

// MintNewEditionFromMasterEditionViaVaultProxy Instruction
type MintNewEditionFromMasterEditionViaVaultProxy struct {
	MintNewEditionFromMasterEditionViaTokenArgs *MintNewEditionFromMasterEditionViaTokenArgs
	// [0] = [WRITE] newMetadata `New Metadata key (pda of ['metadata', program id, mint id])`
	// [1] = [WRITE] newEdition `New Edition (pda of ['metadata', program id, mint id, 'edition'])`
	// [2] = [WRITE] masterEdition `Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition']`
	// [3] = [WRITE] newMint `Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY`
	// [4] = [WRITE] editionMarkPda `Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE).`
	// [5] = [SIGNER] newMintAuthority `Mint authority of new mint`
	// [6] = [WRITE, SIGNER] payer `payer`
	// [7] = [SIGNER] vaultAuthority `Vault authority`
	// [8] = [] safetyDepositStore `Safety deposit token store account`
	// [9] = [] safetyDepositBox `Safety deposit box`
	// [10] = [] vault `Vault`
	// [11] = [] newMetadataUpdateAuthority `Update authority info for new metadata`
	// [12] = [] metadata `Master record metadata account`
	// [13] = [] tokenProgram `Token program`
	// [14] = [] tokenVaultProgram `Token vault program`
	// [15] = [] systemProgram `System program`
	// [16] = [] rent `Rent info`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewMintNewEditionFromMasterEditionViaVaultProxyInstructionBuilder creates a new `MintNewEditionFromMasterEditionViaVaultProxy` instruction builder.
func NewMintNewEditionFromMasterEditionViaVaultProxyInstructionBuilder() *MintNewEditionFromMasterEditionViaVaultProxy {
	return &MintNewEditionFromMasterEditionViaVaultProxy{
		AccountMetaSlice: make(common.AccountMetaSlice, 17),
	}
}

// NewMintNewEditionFromMasterEditionViaVaultProxyInstruction
//
// Parameters:
//
//	mintNewEditionFromMasterEditionViaTokenArgs:
//	newMetadata: New Metadata key (pda of ['metadata', program id, mint id])
//	newEdition: New Edition (pda of ['metadata', program id, mint id, 'edition'])
//	masterEdition: Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition']
//	newMint: Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
//	editionMarkPda: Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE).
//	newMintAuthority: Mint authority of new mint
//	payer: payer
//	vaultAuthority: Vault authority
//	safetyDepositStore: Safety deposit token store account
//	safetyDepositBox: Safety deposit box
//	vault: Vault
//	newMetadataUpdateAuthority: Update authority info for new metadata
//	metadata: Master record metadata account
//	tokenProgram: Token program
//	tokenVaultProgram: Token vault program
//	systemProgram: System program
//	rent: Rent info
func NewMintNewEditionFromMasterEditionViaVaultProxyInstruction(
	mintNewEditionFromMasterEditionViaTokenArgs MintNewEditionFromMasterEditionViaTokenArgs,
	newMetadata common.PublicKey,
	newEdition common.PublicKey,
	masterEdition common.PublicKey,
	newMint common.PublicKey,
	editionMarkPda common.PublicKey,
	newMintAuthority common.PublicKey,
	payer common.PublicKey,
	vaultAuthority common.PublicKey,
	safetyDepositStore common.PublicKey,
	safetyDepositBox common.PublicKey,
	vault common.PublicKey,
	newMetadataUpdateAuthority common.PublicKey,
	metadata common.PublicKey,
	tokenProgram common.PublicKey,
	tokenVaultProgram common.PublicKey,
	systemProgram common.PublicKey,
	rent common.PublicKey,
) *MintNewEditionFromMasterEditionViaVaultProxy {
	return NewMintNewEditionFromMasterEditionViaVaultProxyInstructionBuilder().
		SetMintNewEditionFromMasterEditionViaTokenArgs(mintNewEditionFromMasterEditionViaTokenArgs).
		SetNewMetadataAccount(newMetadata).
		SetNewEditionAccount(newEdition).
		SetMasterEditionAccount(masterEdition).
		SetNewMintAccount(newMint).
		SetEditionMarkPdaAccount(editionMarkPda).
		SetNewMintAuthorityAccount(newMintAuthority).
		SetPayerAccount(payer).
		SetVaultAuthorityAccount(vaultAuthority).
		SetSafetyDepositStoreAccount(safetyDepositStore).
		SetSafetyDepositBoxAccount(safetyDepositBox).
		SetVaultAccount(vault).
		SetNewMetadataUpdateAuthorityAccount(newMetadataUpdateAuthority).
		SetMetadataAccount(metadata).
		SetTokenProgramAccount(tokenProgram).
		SetTokenVaultProgramAccount(tokenVaultProgram).
		SetSystemProgramAccount(systemProgram).
		SetRentAccount(rent)
}

// SetMintNewEditionFromMasterEditionViaTokenArgs sets the "mintNewEditionFromMasterEditionViaTokenArgs" parameter.
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetMintNewEditionFromMasterEditionViaTokenArgs(mintNewEditionFromMasterEditionViaTokenArgs MintNewEditionFromMasterEditionViaTokenArgs) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.MintNewEditionFromMasterEditionViaTokenArgs = &mintNewEditionFromMasterEditionViaTokenArgs
	return obj
}

// SetNewMetadataAccount sets the "newMetadata" parameter.
// New Metadata key (pda of ['metadata', program id, mint id])
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetNewMetadataAccount(newMetadata common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[0] = common.Meta(newMetadata).WRITE()
	return obj
}

// GetNewMetadataAccount gets the "newMetadata" parameter.
// New Metadata key (pda of ['metadata', program id, mint id])
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetNewMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetNewEditionAccount sets the "newEdition" parameter.
// New Edition (pda of ['metadata', program id, mint id, 'edition'])
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetNewEditionAccount(newEdition common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[1] = common.Meta(newEdition).WRITE()
	return obj
}

// GetNewEditionAccount gets the "newEdition" parameter.
// New Edition (pda of ['metadata', program id, mint id, 'edition'])
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetNewEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMasterEditionAccount sets the "masterEdition" parameter.
// Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition']
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetMasterEditionAccount(masterEdition common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[2] = common.Meta(masterEdition).WRITE()
	return obj
}

// GetMasterEditionAccount gets the "masterEdition" parameter.
// Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition']
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetNewMintAccount sets the "newMint" parameter.
// Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetNewMintAccount(newMint common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[3] = common.Meta(newMint).WRITE()
	return obj
}

// GetNewMintAccount gets the "newMint" parameter.
// Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetNewMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetEditionMarkPdaAccount sets the "editionMarkPda" parameter.
// Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE).
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetEditionMarkPdaAccount(editionMarkPda common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[4] = common.Meta(editionMarkPda).WRITE()
	return obj
}

// GetEditionMarkPdaAccount gets the "editionMarkPda" parameter.
// Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE).
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetEditionMarkPdaAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetNewMintAuthorityAccount sets the "newMintAuthority" parameter.
// Mint authority of new mint
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetNewMintAuthorityAccount(newMintAuthority common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[5] = common.Meta(newMintAuthority).SIGNER()
	return obj
}

// GetNewMintAuthorityAccount gets the "newMintAuthority" parameter.
// Mint authority of new mint
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetNewMintAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetPayerAccount sets the "payer" parameter.
// payer
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetPayerAccount(payer common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[6] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// payer
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetVaultAuthorityAccount sets the "vaultAuthority" parameter.
// Vault authority
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetVaultAuthorityAccount(vaultAuthority common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[7] = common.Meta(vaultAuthority).SIGNER()
	return obj
}

// GetVaultAuthorityAccount gets the "vaultAuthority" parameter.
// Vault authority
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetVaultAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetSafetyDepositStoreAccount sets the "safetyDepositStore" parameter.
// Safety deposit token store account
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetSafetyDepositStoreAccount(safetyDepositStore common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[8] = common.Meta(safetyDepositStore)
	return obj
}

// GetSafetyDepositStoreAccount gets the "safetyDepositStore" parameter.
// Safety deposit token store account
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetSafetyDepositStoreAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetSafetyDepositBoxAccount sets the "safetyDepositBox" parameter.
// Safety deposit box
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetSafetyDepositBoxAccount(safetyDepositBox common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[9] = common.Meta(safetyDepositBox)
	return obj
}

// GetSafetyDepositBoxAccount gets the "safetyDepositBox" parameter.
// Safety deposit box
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetSafetyDepositBoxAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetVaultAccount sets the "vault" parameter.
// Vault
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetVaultAccount(vault common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[10] = common.Meta(vault)
	return obj
}

// GetVaultAccount gets the "vault" parameter.
// Vault
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetVaultAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetNewMetadataUpdateAuthorityAccount sets the "newMetadataUpdateAuthority" parameter.
// Update authority info for new metadata
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetNewMetadataUpdateAuthorityAccount(newMetadataUpdateAuthority common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[11] = common.Meta(newMetadataUpdateAuthority)
	return obj
}

// GetNewMetadataUpdateAuthorityAccount gets the "newMetadataUpdateAuthority" parameter.
// Update authority info for new metadata
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetNewMetadataUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

// SetMetadataAccount sets the "metadata" parameter.
// Master record metadata account
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetMetadataAccount(metadata common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[12] = common.Meta(metadata)
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Master record metadata account
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(12)
}

// SetTokenProgramAccount sets the "tokenProgram" parameter.
// Token program
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetTokenProgramAccount(tokenProgram common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[13] = common.Meta(tokenProgram)
	return obj
}

// GetTokenProgramAccount gets the "tokenProgram" parameter.
// Token program
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(13)
}

// SetTokenVaultProgramAccount sets the "tokenVaultProgram" parameter.
// Token vault program
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetTokenVaultProgramAccount(tokenVaultProgram common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[14] = common.Meta(tokenVaultProgram)
	return obj
}

// GetTokenVaultProgramAccount gets the "tokenVaultProgram" parameter.
// Token vault program
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetTokenVaultProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(14)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetSystemProgramAccount(systemProgram common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj.AccountMetaSlice[15] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(15)
}

// SetRentAccount sets the "rent" parameter.
// Rent info
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[16] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[16] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent info
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(16)
}

func (obj *MintNewEditionFromMasterEditionViaVaultProxy) SetProgramId(programId *common.PublicKey) *MintNewEditionFromMasterEditionViaVaultProxy {
	obj._programId = programId
	return obj
}

func (obj *MintNewEditionFromMasterEditionViaVaultProxy) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_MintNewEditionFromMasterEditionViaVaultProxy}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *MintNewEditionFromMasterEditionViaVaultProxy) Validate() error {
	if obj.MintNewEditionFromMasterEditionViaTokenArgs == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] mintNewEditionFromMasterEditionViaTokenArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.newMetadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.newEdition is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.masterEdition is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.newMint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.editionMarkPda is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.newMintAuthority is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.vaultAuthority is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.safetyDepositStore is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.safetyDepositBox is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.vault is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.newMetadataUpdateAuthority is not set")
	}
	if obj.AccountMetaSlice[12] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[13] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.tokenProgram is not set")
	}
	if obj.AccountMetaSlice[14] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.tokenVaultProgram is not set")
	}
	if obj.AccountMetaSlice[15] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[16] == nil {
		return errors.New("[MintNewEditionFromMasterEditionViaVaultProxy] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *MintNewEditionFromMasterEditionViaVaultProxy) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *MintNewEditionFromMasterEditionViaVaultProxy) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.MintNewEditionFromMasterEditionViaTokenArgs); err != nil {
		return err
	}
	return nil
}

func (obj *MintNewEditionFromMasterEditionViaVaultProxy) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.MintNewEditionFromMasterEditionViaTokenArgs); err != nil {
		return err
	}
	return nil
}

func (obj *MintNewEditionFromMasterEditionViaVaultProxy) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("MintNewEditionFromMasterEditionViaVaultProxy")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("MintNewEditionFromMasterEditionViaTokenArgs", *obj.MintNewEditionFromMasterEditionViaTokenArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=17]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("               newMetadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("                newEdition", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("             masterEdition", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("                   newMint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("            editionMarkPda", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("          newMintAuthority", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("                     payer", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("            vaultAuthority", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("        safetyDepositStore", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("          safetyDepositBox", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("                     vault", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("newMetadataUpdateAuthority", obj.AccountMetaSlice.Get(11)))
						accountsBranch.Child(common.FormatMeta("                  metadata", obj.AccountMetaSlice.Get(12)))
						accountsBranch.Child(common.FormatMeta("              tokenProgram", obj.AccountMetaSlice.Get(13)))
						accountsBranch.Child(common.FormatMeta("         tokenVaultProgram", obj.AccountMetaSlice.Get(14)))
						accountsBranch.Child(common.FormatMeta("             systemProgram", obj.AccountMetaSlice.Get(15)))
						accountsBranch.Child(common.FormatMeta("                      rent", obj.AccountMetaSlice.Get(16)))
					})
				})
		})
}

// PuffMetadata Instruction
type PuffMetadata struct {
	// [0] = [WRITE] metadata `Metadata account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewPuffMetadataInstructionBuilder creates a new `PuffMetadata` instruction builder.
func NewPuffMetadataInstructionBuilder() *PuffMetadata {
	return &PuffMetadata{
		AccountMetaSlice: make(common.AccountMetaSlice, 1),
	}
}

// NewPuffMetadataInstruction
//
// Parameters:
//
//	metadata: Metadata account
func NewPuffMetadataInstruction(
	metadata common.PublicKey,
) *PuffMetadata {
	return NewPuffMetadataInstructionBuilder().
		SetMetadataAccount(metadata)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *PuffMetadata) SetMetadataAccount(metadata common.PublicKey, multiSigners ...common.PublicKey) *PuffMetadata {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[0] = common.Meta(metadata)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	}
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *PuffMetadata) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

func (obj *PuffMetadata) SetProgramId(programId *common.PublicKey) *PuffMetadata {
	obj._programId = programId
	return obj
}

func (obj *PuffMetadata) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_PuffMetadata}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *PuffMetadata) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[PuffMetadata] accounts.metadata is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *PuffMetadata) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *PuffMetadata) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *PuffMetadata) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *PuffMetadata) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("PuffMetadata")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=1]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("metadata", obj.AccountMetaSlice.Get(0)))
					})
				})
		})
}

// UpdateMetadataAccountV2 Instruction
type UpdateMetadataAccountV2 struct {
	UpdateMetadataAccountArgsV2 *UpdateMetadataAccountArgsV2
	// [0] = [WRITE] metadata `Metadata account`
	// [1] = [SIGNER] updateAuthority `Update authority key`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewUpdateMetadataAccountV2InstructionBuilder creates a new `UpdateMetadataAccountV2` instruction builder.
func NewUpdateMetadataAccountV2InstructionBuilder() *UpdateMetadataAccountV2 {
	return &UpdateMetadataAccountV2{
		AccountMetaSlice: make(common.AccountMetaSlice, 2),
	}
}

// NewUpdateMetadataAccountV2Instruction
//
// Parameters:
//
//	updateMetadataAccountArgsV2:
//	metadata: Metadata account
//	updateAuthority: Update authority key
func NewUpdateMetadataAccountV2Instruction(
	updateMetadataAccountArgsV2 UpdateMetadataAccountArgsV2,
	metadata common.PublicKey,
	updateAuthority common.PublicKey,
) *UpdateMetadataAccountV2 {
	return NewUpdateMetadataAccountV2InstructionBuilder().
		SetUpdateMetadataAccountArgsV2(updateMetadataAccountArgsV2).
		SetMetadataAccount(metadata).
		SetUpdateAuthorityAccount(updateAuthority)
}

// SetUpdateMetadataAccountArgsV2 sets the "updateMetadataAccountArgsV2" parameter.
func (obj *UpdateMetadataAccountV2) SetUpdateMetadataAccountArgsV2(updateMetadataAccountArgsV2 UpdateMetadataAccountArgsV2) *UpdateMetadataAccountV2 {
	obj.UpdateMetadataAccountArgsV2 = &updateMetadataAccountArgsV2
	return obj
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *UpdateMetadataAccountV2) SetMetadataAccount(metadata common.PublicKey) *UpdateMetadataAccountV2 {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *UpdateMetadataAccountV2) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// Update authority key
func (obj *UpdateMetadataAccountV2) SetUpdateAuthorityAccount(updateAuthority common.PublicKey, multiSigners ...common.PublicKey) *UpdateMetadataAccountV2 {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[1] = common.Meta(updateAuthority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[1] = common.Meta(updateAuthority).SIGNER()
	}
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// Update authority key
func (obj *UpdateMetadataAccountV2) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

func (obj *UpdateMetadataAccountV2) SetProgramId(programId *common.PublicKey) *UpdateMetadataAccountV2 {
	obj._programId = programId
	return obj
}

func (obj *UpdateMetadataAccountV2) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_UpdateMetadataAccountV2}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *UpdateMetadataAccountV2) Validate() error {
	if obj.UpdateMetadataAccountArgsV2 == nil {
		return errors.New("[UpdateMetadataAccountV2] updateMetadataAccountArgsV2 param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[UpdateMetadataAccountV2] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[UpdateMetadataAccountV2] accounts.updateAuthority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *UpdateMetadataAccountV2) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *UpdateMetadataAccountV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.UpdateMetadataAccountArgsV2); err != nil {
		return err
	}
	return nil
}

func (obj *UpdateMetadataAccountV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.UpdateMetadataAccountArgsV2); err != nil {
		return err
	}
	return nil
}

func (obj *UpdateMetadataAccountV2) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("UpdateMetadataAccountV2")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("UpdateMetadataAccountArgsV2", *obj.UpdateMetadataAccountArgsV2))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=2]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("       metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("updateAuthority", obj.AccountMetaSlice.Get(1)))
					})
				})
		})
}

// CreateMetadataAccountV2 Instruction
type CreateMetadataAccountV2 struct {
	// [0] = [WRITE] metadata `Metadata key (pda of ['metadata', program id, mint id])`
	// [1] = [] mint `Mint of token asset`
	// [2] = [SIGNER] mintAuthority `Mint authority`
	// [3] = [WRITE, SIGNER] payer `payer`
	// [4] = [] updateAuthority `update authority info`
	// [5] = [] systemProgram `System program`
	// [6] = [] rent `Rent info`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewCreateMetadataAccountV2InstructionBuilder creates a new `CreateMetadataAccountV2` instruction builder.
func NewCreateMetadataAccountV2InstructionBuilder() *CreateMetadataAccountV2 {
	return &CreateMetadataAccountV2{
		AccountMetaSlice: make(common.AccountMetaSlice, 7),
	}
}

// NewCreateMetadataAccountV2Instruction
//
// Parameters:
//
//	metadata: Metadata key (pda of ['metadata', program id, mint id])
//	mint: Mint of token asset
//	mintAuthority: Mint authority
//	payer: payer
//	updateAuthority: update authority info
//	systemProgram: System program
//	rent: Rent info
func NewCreateMetadataAccountV2Instruction(
	metadata common.PublicKey,
	mint common.PublicKey,
	mintAuthority common.PublicKey,
	payer common.PublicKey,
	updateAuthority common.PublicKey,
	systemProgram common.PublicKey,
	rent common.PublicKey,
) *CreateMetadataAccountV2 {
	return NewCreateMetadataAccountV2InstructionBuilder().
		SetMetadataAccount(metadata).
		SetMintAccount(mint).
		SetMintAuthorityAccount(mintAuthority).
		SetPayerAccount(payer).
		SetUpdateAuthorityAccount(updateAuthority).
		SetSystemProgramAccount(systemProgram).
		SetRentAccount(rent)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata key (pda of ['metadata', program id, mint id])
func (obj *CreateMetadataAccountV2) SetMetadataAccount(metadata common.PublicKey) *CreateMetadataAccountV2 {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata key (pda of ['metadata', program id, mint id])
func (obj *CreateMetadataAccountV2) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// Mint of token asset
func (obj *CreateMetadataAccountV2) SetMintAccount(mint common.PublicKey) *CreateMetadataAccountV2 {
	obj.AccountMetaSlice[1] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of token asset
func (obj *CreateMetadataAccountV2) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMintAuthorityAccount sets the "mintAuthority" parameter.
// Mint authority
func (obj *CreateMetadataAccountV2) SetMintAuthorityAccount(mintAuthority common.PublicKey) *CreateMetadataAccountV2 {
	obj.AccountMetaSlice[2] = common.Meta(mintAuthority).SIGNER()
	return obj
}

// GetMintAuthorityAccount gets the "mintAuthority" parameter.
// Mint authority
func (obj *CreateMetadataAccountV2) GetMintAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetPayerAccount sets the "payer" parameter.
// payer
func (obj *CreateMetadataAccountV2) SetPayerAccount(payer common.PublicKey) *CreateMetadataAccountV2 {
	obj.AccountMetaSlice[3] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// payer
func (obj *CreateMetadataAccountV2) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// update authority info
func (obj *CreateMetadataAccountV2) SetUpdateAuthorityAccount(updateAuthority common.PublicKey) *CreateMetadataAccountV2 {
	obj.AccountMetaSlice[4] = common.Meta(updateAuthority)
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// update authority info
func (obj *CreateMetadataAccountV2) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *CreateMetadataAccountV2) SetSystemProgramAccount(systemProgram common.PublicKey) *CreateMetadataAccountV2 {
	obj.AccountMetaSlice[5] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *CreateMetadataAccountV2) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetRentAccount sets the "rent" parameter.
// Rent info
func (obj *CreateMetadataAccountV2) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *CreateMetadataAccountV2 {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[6] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[6] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent info
func (obj *CreateMetadataAccountV2) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

func (obj *CreateMetadataAccountV2) SetProgramId(programId *common.PublicKey) *CreateMetadataAccountV2 {
	obj._programId = programId
	return obj
}

func (obj *CreateMetadataAccountV2) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_CreateMetadataAccountV2}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *CreateMetadataAccountV2) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[CreateMetadataAccountV2] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[CreateMetadataAccountV2] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[CreateMetadataAccountV2] accounts.mintAuthority is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[CreateMetadataAccountV2] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[CreateMetadataAccountV2] accounts.updateAuthority is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[CreateMetadataAccountV2] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[CreateMetadataAccountV2] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *CreateMetadataAccountV2) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *CreateMetadataAccountV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *CreateMetadataAccountV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *CreateMetadataAccountV2) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("CreateMetadataAccountV2")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=7]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("       metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("           mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("  mintAuthority", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("          payer", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("updateAuthority", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("  systemProgram", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("           rent", obj.AccountMetaSlice.Get(6)))
					})
				})
		})
}

// CreateMasterEditionV3 Instruction
type CreateMasterEditionV3 struct {
	CreateMasterEditionArgs *CreateMasterEditionArgs
	// [0] = [WRITE] edition `Unallocated edition V2 account with address as pda of ['metadata', program id, mint, 'edition']`
	// [1] = [WRITE] mint `Metadata mint`
	// [2] = [SIGNER] updateAuthority `Update authority`
	// [3] = [SIGNER] mintAuthority `Mint authority on the metadata's mint - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY`
	// [4] = [WRITE, SIGNER] payer `payer`
	// [5] = [WRITE] metadata `Metadata account`
	// [6] = [] tokenProgram `Token program`
	// [7] = [] systemProgram `System program`
	// [8] = [] rent `Rent info`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewCreateMasterEditionV3InstructionBuilder creates a new `CreateMasterEditionV3` instruction builder.
func NewCreateMasterEditionV3InstructionBuilder() *CreateMasterEditionV3 {
	return &CreateMasterEditionV3{
		AccountMetaSlice: make(common.AccountMetaSlice, 9),
	}
}

// NewCreateMasterEditionV3Instruction
//
// Parameters:
//
//	createMasterEditionArgs:
//	edition: Unallocated edition V2 account with address as pda of ['metadata', program id, mint, 'edition']
//	mint: Metadata mint
//	updateAuthority: Update authority
//	mintAuthority: Mint authority on the metadata's mint - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
//	payer: payer
//	metadata: Metadata account
//	tokenProgram: Token program
//	systemProgram: System program
//	rent: Rent info
func NewCreateMasterEditionV3Instruction(
	createMasterEditionArgs CreateMasterEditionArgs,
	edition common.PublicKey,
	mint common.PublicKey,
	updateAuthority common.PublicKey,
	mintAuthority common.PublicKey,
	payer common.PublicKey,
	metadata common.PublicKey,
	tokenProgram common.PublicKey,
	systemProgram common.PublicKey,
	rent common.PublicKey,
) *CreateMasterEditionV3 {
	return NewCreateMasterEditionV3InstructionBuilder().
		SetCreateMasterEditionArgs(createMasterEditionArgs).
		SetEditionAccount(edition).
		SetMintAccount(mint).
		SetUpdateAuthorityAccount(updateAuthority).
		SetMintAuthorityAccount(mintAuthority).
		SetPayerAccount(payer).
		SetMetadataAccount(metadata).
		SetTokenProgramAccount(tokenProgram).
		SetSystemProgramAccount(systemProgram).
		SetRentAccount(rent)
}

// SetCreateMasterEditionArgs sets the "createMasterEditionArgs" parameter.
func (obj *CreateMasterEditionV3) SetCreateMasterEditionArgs(createMasterEditionArgs CreateMasterEditionArgs) *CreateMasterEditionV3 {
	obj.CreateMasterEditionArgs = &createMasterEditionArgs
	return obj
}

// SetEditionAccount sets the "edition" parameter.
// Unallocated edition V2 account with address as pda of ['metadata', program id, mint, 'edition']
func (obj *CreateMasterEditionV3) SetEditionAccount(edition common.PublicKey) *CreateMasterEditionV3 {
	obj.AccountMetaSlice[0] = common.Meta(edition).WRITE()
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Unallocated edition V2 account with address as pda of ['metadata', program id, mint, 'edition']
func (obj *CreateMasterEditionV3) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// Metadata mint
func (obj *CreateMasterEditionV3) SetMintAccount(mint common.PublicKey) *CreateMasterEditionV3 {
	obj.AccountMetaSlice[1] = common.Meta(mint).WRITE()
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Metadata mint
func (obj *CreateMasterEditionV3) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// Update authority
func (obj *CreateMasterEditionV3) SetUpdateAuthorityAccount(updateAuthority common.PublicKey) *CreateMasterEditionV3 {
	obj.AccountMetaSlice[2] = common.Meta(updateAuthority).SIGNER()
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// Update authority
func (obj *CreateMasterEditionV3) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMintAuthorityAccount sets the "mintAuthority" parameter.
// Mint authority on the metadata's mint - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
func (obj *CreateMasterEditionV3) SetMintAuthorityAccount(mintAuthority common.PublicKey) *CreateMasterEditionV3 {
	obj.AccountMetaSlice[3] = common.Meta(mintAuthority).SIGNER()
	return obj
}

// GetMintAuthorityAccount gets the "mintAuthority" parameter.
// Mint authority on the metadata's mint - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
func (obj *CreateMasterEditionV3) GetMintAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetPayerAccount sets the "payer" parameter.
// payer
func (obj *CreateMasterEditionV3) SetPayerAccount(payer common.PublicKey) *CreateMasterEditionV3 {
	obj.AccountMetaSlice[4] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// payer
func (obj *CreateMasterEditionV3) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *CreateMasterEditionV3) SetMetadataAccount(metadata common.PublicKey) *CreateMasterEditionV3 {
	obj.AccountMetaSlice[5] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *CreateMasterEditionV3) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetTokenProgramAccount sets the "tokenProgram" parameter.
// Token program
func (obj *CreateMasterEditionV3) SetTokenProgramAccount(tokenProgram common.PublicKey) *CreateMasterEditionV3 {
	obj.AccountMetaSlice[6] = common.Meta(tokenProgram)
	return obj
}

// GetTokenProgramAccount gets the "tokenProgram" parameter.
// Token program
func (obj *CreateMasterEditionV3) GetTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *CreateMasterEditionV3) SetSystemProgramAccount(systemProgram common.PublicKey) *CreateMasterEditionV3 {
	obj.AccountMetaSlice[7] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *CreateMasterEditionV3) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetRentAccount sets the "rent" parameter.
// Rent info
func (obj *CreateMasterEditionV3) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *CreateMasterEditionV3 {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[8] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[8] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent info
func (obj *CreateMasterEditionV3) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

func (obj *CreateMasterEditionV3) SetProgramId(programId *common.PublicKey) *CreateMasterEditionV3 {
	obj._programId = programId
	return obj
}

func (obj *CreateMasterEditionV3) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_CreateMasterEditionV3}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *CreateMasterEditionV3) Validate() error {
	if obj.CreateMasterEditionArgs == nil {
		return errors.New("[CreateMasterEditionV3] createMasterEditionArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[CreateMasterEditionV3] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[CreateMasterEditionV3] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[CreateMasterEditionV3] accounts.updateAuthority is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[CreateMasterEditionV3] accounts.mintAuthority is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[CreateMasterEditionV3] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[CreateMasterEditionV3] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[CreateMasterEditionV3] accounts.tokenProgram is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[CreateMasterEditionV3] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[CreateMasterEditionV3] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *CreateMasterEditionV3) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *CreateMasterEditionV3) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.CreateMasterEditionArgs); err != nil {
		return err
	}
	return nil
}

func (obj *CreateMasterEditionV3) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.CreateMasterEditionArgs); err != nil {
		return err
	}
	return nil
}

func (obj *CreateMasterEditionV3) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("CreateMasterEditionV3")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("CreateMasterEditionArgs", *obj.CreateMasterEditionArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=9]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("        edition", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("           mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("updateAuthority", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("  mintAuthority", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("          payer", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("       metadata", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("   tokenProgram", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("  systemProgram", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("           rent", obj.AccountMetaSlice.Get(8)))
					})
				})
		})
}

// VerifyCollection Instruction
type VerifyCollection struct {
	// [0] = [WRITE] metadata `Metadata account`
	// [1] = [WRITE, SIGNER] collectionAuthority `Collection Update authority`
	// [2] = [WRITE, SIGNER] payer `payer`
	// [3] = [] collectionMint `Mint of the Collection`
	// [4] = [] collection `Metadata Account of the Collection`
	// [5] = [] collectionMasterEditionAccount `MasterEdition2 Account of the Collection Token`
	// [6] = [] collectionAuthorityRecord `Collection Authority Record PDA`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewVerifyCollectionInstructionBuilder creates a new `VerifyCollection` instruction builder.
func NewVerifyCollectionInstructionBuilder() *VerifyCollection {
	return &VerifyCollection{
		AccountMetaSlice: make(common.AccountMetaSlice, 7),
	}
}

// NewVerifyCollectionInstruction
//
// Parameters:
//
//	metadata: Metadata account
//	collectionAuthority: Collection Update authority
//	payer: payer
//	collectionMint: Mint of the Collection
//	collection: Metadata Account of the Collection
//	collectionMasterEditionAccount: MasterEdition2 Account of the Collection Token
//	collectionAuthorityRecord: Collection Authority Record PDA
func NewVerifyCollectionInstruction(
	metadata common.PublicKey,
	collectionAuthority common.PublicKey,
	payer common.PublicKey,
	collectionMint common.PublicKey,
	collection common.PublicKey,
	collectionMasterEditionAccount common.PublicKey,
	collectionAuthorityRecord common.PublicKey,
) *VerifyCollection {
	return NewVerifyCollectionInstructionBuilder().
		SetMetadataAccount(metadata).
		SetCollectionAuthorityAccount(collectionAuthority).
		SetPayerAccount(payer).
		SetCollectionMintAccount(collectionMint).
		SetCollectionAccount(collection).
		SetCollectionMasterEditionAccountAccount(collectionMasterEditionAccount).
		SetCollectionAuthorityRecordAccount(collectionAuthorityRecord)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *VerifyCollection) SetMetadataAccount(metadata common.PublicKey) *VerifyCollection {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *VerifyCollection) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetCollectionAuthorityAccount sets the "collectionAuthority" parameter.
// Collection Update authority
func (obj *VerifyCollection) SetCollectionAuthorityAccount(collectionAuthority common.PublicKey) *VerifyCollection {
	obj.AccountMetaSlice[1] = common.Meta(collectionAuthority).WRITE().SIGNER()
	return obj
}

// GetCollectionAuthorityAccount gets the "collectionAuthority" parameter.
// Collection Update authority
func (obj *VerifyCollection) GetCollectionAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetPayerAccount sets the "payer" parameter.
// payer
func (obj *VerifyCollection) SetPayerAccount(payer common.PublicKey) *VerifyCollection {
	obj.AccountMetaSlice[2] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// payer
func (obj *VerifyCollection) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetCollectionMintAccount sets the "collectionMint" parameter.
// Mint of the Collection
func (obj *VerifyCollection) SetCollectionMintAccount(collectionMint common.PublicKey) *VerifyCollection {
	obj.AccountMetaSlice[3] = common.Meta(collectionMint)
	return obj
}

// GetCollectionMintAccount gets the "collectionMint" parameter.
// Mint of the Collection
func (obj *VerifyCollection) GetCollectionMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetCollectionAccount sets the "collection" parameter.
// Metadata Account of the Collection
func (obj *VerifyCollection) SetCollectionAccount(collection common.PublicKey) *VerifyCollection {
	obj.AccountMetaSlice[4] = common.Meta(collection)
	return obj
}

// GetCollectionAccount gets the "collection" parameter.
// Metadata Account of the Collection
func (obj *VerifyCollection) GetCollectionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetCollectionMasterEditionAccountAccount sets the "collectionMasterEditionAccount" parameter.
// MasterEdition2 Account of the Collection Token
func (obj *VerifyCollection) SetCollectionMasterEditionAccountAccount(collectionMasterEditionAccount common.PublicKey) *VerifyCollection {
	obj.AccountMetaSlice[5] = common.Meta(collectionMasterEditionAccount)
	return obj
}

// GetCollectionMasterEditionAccountAccount gets the "collectionMasterEditionAccount" parameter.
// MasterEdition2 Account of the Collection Token
func (obj *VerifyCollection) GetCollectionMasterEditionAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetCollectionAuthorityRecordAccount sets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *VerifyCollection) SetCollectionAuthorityRecordAccount(collectionAuthorityRecord common.PublicKey, multiSigners ...common.PublicKey) *VerifyCollection {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[6] = common.Meta(collectionAuthorityRecord)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[6] = common.Meta(collectionAuthorityRecord)
	}
	return obj
}

// GetCollectionAuthorityRecordAccount gets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *VerifyCollection) GetCollectionAuthorityRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

func (obj *VerifyCollection) SetProgramId(programId *common.PublicKey) *VerifyCollection {
	obj._programId = programId
	return obj
}

func (obj *VerifyCollection) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_VerifyCollection}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *VerifyCollection) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[VerifyCollection] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[VerifyCollection] accounts.collectionAuthority is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[VerifyCollection] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[VerifyCollection] accounts.collectionMint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[VerifyCollection] accounts.collection is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[VerifyCollection] accounts.collectionMasterEditionAccount is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[VerifyCollection] accounts.collectionAuthorityRecord is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *VerifyCollection) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *VerifyCollection) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *VerifyCollection) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *VerifyCollection) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("VerifyCollection")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=7]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                      metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("           collectionAuthority", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                         payer", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("                collectionMint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                    collection", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("collectionMasterEditionAccount", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("     collectionAuthorityRecord", obj.AccountMetaSlice.Get(6)))
					})
				})
		})
}

// Utilize Instruction
type Utilize struct {
	UtilizeArgs *UtilizeArgs
	// [0] = [WRITE] metadata `Metadata account`
	// [1] = [WRITE] tokenAccount `Token Account Of NFT`
	// [2] = [WRITE] mint `Mint of the Metadata`
	// [3] = [WRITE, SIGNER] useAuthority `A Use Authority / Can be the current Owner of the NFT`
	// [4] = [] owner `Owner`
	// [5] = [] tokenProgram `Token program`
	// [6] = [] ataProgram `Associated Token program`
	// [7] = [] systemProgram `System program`
	// [8] = [] rent `Rent info`
	// [9] = [WRITE] useAuthorityRecord `Use Authority Record PDA If present the program Assumes a delegated use authority`
	// [10] = [] burner `Program As Signer (Burner)`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewUtilizeInstructionBuilder creates a new `Utilize` instruction builder.
func NewUtilizeInstructionBuilder() *Utilize {
	return &Utilize{
		AccountMetaSlice: make(common.AccountMetaSlice, 11),
	}
}

// NewUtilizeInstruction
//
// Parameters:
//
//	utilizeArgs:
//	metadata: Metadata account
//	tokenAccount: Token Account Of NFT
//	mint: Mint of the Metadata
//	useAuthority: A Use Authority / Can be the current Owner of the NFT
//	owner: Owner
//	tokenProgram: Token program
//	ataProgram: Associated Token program
//	systemProgram: System program
//	rent: Rent info
//	useAuthorityRecord: Use Authority Record PDA If present the program Assumes a delegated use authority
//	burner: Program As Signer (Burner)
func NewUtilizeInstruction(
	utilizeArgs UtilizeArgs,
	metadata common.PublicKey,
	tokenAccount common.PublicKey,
	mint common.PublicKey,
	useAuthority common.PublicKey,
	owner common.PublicKey,
	tokenProgram common.PublicKey,
	ataProgram common.PublicKey,
	systemProgram common.PublicKey,
	rent common.PublicKey,
	useAuthorityRecord common.PublicKey,
	burner common.PublicKey,
) *Utilize {
	return NewUtilizeInstructionBuilder().
		SetUtilizeArgs(utilizeArgs).
		SetMetadataAccount(metadata).
		SetTokenAccountAccount(tokenAccount).
		SetMintAccount(mint).
		SetUseAuthorityAccount(useAuthority).
		SetOwnerAccount(owner).
		SetTokenProgramAccount(tokenProgram).
		SetAtaProgramAccount(ataProgram).
		SetSystemProgramAccount(systemProgram).
		SetRentAccount(rent).
		SetUseAuthorityRecordAccount(useAuthorityRecord).
		SetBurnerAccount(burner)
}

// SetUtilizeArgs sets the "utilizeArgs" parameter.
func (obj *Utilize) SetUtilizeArgs(utilizeArgs UtilizeArgs) *Utilize {
	obj.UtilizeArgs = &utilizeArgs
	return obj
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *Utilize) SetMetadataAccount(metadata common.PublicKey) *Utilize {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *Utilize) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetTokenAccountAccount sets the "tokenAccount" parameter.
// Token Account Of NFT
func (obj *Utilize) SetTokenAccountAccount(tokenAccount common.PublicKey) *Utilize {
	obj.AccountMetaSlice[1] = common.Meta(tokenAccount).WRITE()
	return obj
}

// GetTokenAccountAccount gets the "tokenAccount" parameter.
// Token Account Of NFT
func (obj *Utilize) GetTokenAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMintAccount sets the "mint" parameter.
// Mint of the Metadata
func (obj *Utilize) SetMintAccount(mint common.PublicKey) *Utilize {
	obj.AccountMetaSlice[2] = common.Meta(mint).WRITE()
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of the Metadata
func (obj *Utilize) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetUseAuthorityAccount sets the "useAuthority" parameter.
// A Use Authority / Can be the current Owner of the NFT
func (obj *Utilize) SetUseAuthorityAccount(useAuthority common.PublicKey) *Utilize {
	obj.AccountMetaSlice[3] = common.Meta(useAuthority).WRITE().SIGNER()
	return obj
}

// GetUseAuthorityAccount gets the "useAuthority" parameter.
// A Use Authority / Can be the current Owner of the NFT
func (obj *Utilize) GetUseAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetOwnerAccount sets the "owner" parameter.
// Owner
func (obj *Utilize) SetOwnerAccount(owner common.PublicKey) *Utilize {
	obj.AccountMetaSlice[4] = common.Meta(owner)
	return obj
}

// GetOwnerAccount gets the "owner" parameter.
// Owner
func (obj *Utilize) GetOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetTokenProgramAccount sets the "tokenProgram" parameter.
// Token program
func (obj *Utilize) SetTokenProgramAccount(tokenProgram common.PublicKey) *Utilize {
	obj.AccountMetaSlice[5] = common.Meta(tokenProgram)
	return obj
}

// GetTokenProgramAccount gets the "tokenProgram" parameter.
// Token program
func (obj *Utilize) GetTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetAtaProgramAccount sets the "ataProgram" parameter.
// Associated Token program
func (obj *Utilize) SetAtaProgramAccount(ataProgram common.PublicKey) *Utilize {
	obj.AccountMetaSlice[6] = common.Meta(ataProgram)
	return obj
}

// GetAtaProgramAccount gets the "ataProgram" parameter.
// Associated Token program
func (obj *Utilize) GetAtaProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *Utilize) SetSystemProgramAccount(systemProgram common.PublicKey) *Utilize {
	obj.AccountMetaSlice[7] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *Utilize) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetRentAccount sets the "rent" parameter.
// Rent info
func (obj *Utilize) SetRentAccount(rent common.PublicKey) *Utilize {
	obj.AccountMetaSlice[8] = common.Meta(rent)
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent info
func (obj *Utilize) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetUseAuthorityRecordAccount sets the "useAuthorityRecord" parameter.
// Use Authority Record PDA If present the program Assumes a delegated use authority
func (obj *Utilize) SetUseAuthorityRecordAccount(useAuthorityRecord common.PublicKey) *Utilize {
	obj.AccountMetaSlice[9] = common.Meta(useAuthorityRecord).WRITE()
	return obj
}

// GetUseAuthorityRecordAccount gets the "useAuthorityRecord" parameter.
// Use Authority Record PDA If present the program Assumes a delegated use authority
func (obj *Utilize) GetUseAuthorityRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetBurnerAccount sets the "burner" parameter.
// Program As Signer (Burner)
func (obj *Utilize) SetBurnerAccount(burner common.PublicKey, multiSigners ...common.PublicKey) *Utilize {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[10] = common.Meta(burner)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[10] = common.Meta(burner)
	}
	return obj
}

// GetBurnerAccount gets the "burner" parameter.
// Program As Signer (Burner)
func (obj *Utilize) GetBurnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

func (obj *Utilize) SetProgramId(programId *common.PublicKey) *Utilize {
	obj._programId = programId
	return obj
}

func (obj *Utilize) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Utilize}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Utilize) Validate() error {
	if obj.UtilizeArgs == nil {
		return errors.New("[Utilize] utilizeArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Utilize] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Utilize] accounts.tokenAccount is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Utilize] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Utilize] accounts.useAuthority is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Utilize] accounts.owner is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Utilize] accounts.tokenProgram is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Utilize] accounts.ataProgram is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[Utilize] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[Utilize] accounts.rent is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[Utilize] accounts.useAuthorityRecord is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[Utilize] accounts.burner is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Utilize) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Utilize) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.UtilizeArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Utilize) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.UtilizeArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Utilize) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Utilize")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("UtilizeArgs", *obj.UtilizeArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=11]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("          metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("      tokenAccount", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("              mint", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("      useAuthority", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("             owner", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("      tokenProgram", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("        ataProgram", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("     systemProgram", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("              rent", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("useAuthorityRecord", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("            burner", obj.AccountMetaSlice.Get(10)))
					})
				})
		})
}

// ApproveUseAuthority Instruction
type ApproveUseAuthority struct {
	ApproveUseAuthorityArgs *ApproveUseAuthorityArgs
	// [0] = [WRITE] useAuthorityRecord `Use Authority Record PDA`
	// [1] = [WRITE, SIGNER] owner `Owner`
	// [2] = [WRITE, SIGNER] payer `Payer`
	// [3] = [] user `A Use Authority`
	// [4] = [WRITE] ownerTokenAccount `Owned Token Account Of Mint`
	// [5] = [] metadata `Metadata account`
	// [6] = [] mint `Mint of Metadata`
	// [7] = [] burner `Program As Signer (Burner)`
	// [8] = [] tokenProgram `Token program`
	// [9] = [] systemProgram `System program`
	// [10] = [] rent `Rent info`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewApproveUseAuthorityInstructionBuilder creates a new `ApproveUseAuthority` instruction builder.
func NewApproveUseAuthorityInstructionBuilder() *ApproveUseAuthority {
	return &ApproveUseAuthority{
		AccountMetaSlice: make(common.AccountMetaSlice, 11),
	}
}

// NewApproveUseAuthorityInstruction
//
// Parameters:
//
//	approveUseAuthorityArgs:
//	useAuthorityRecord: Use Authority Record PDA
//	owner: Owner
//	payer: Payer
//	user: A Use Authority
//	ownerTokenAccount: Owned Token Account Of Mint
//	metadata: Metadata account
//	mint: Mint of Metadata
//	burner: Program As Signer (Burner)
//	tokenProgram: Token program
//	systemProgram: System program
//	rent: Rent info
func NewApproveUseAuthorityInstruction(
	approveUseAuthorityArgs ApproveUseAuthorityArgs,
	useAuthorityRecord common.PublicKey,
	owner common.PublicKey,
	payer common.PublicKey,
	user common.PublicKey,
	ownerTokenAccount common.PublicKey,
	metadata common.PublicKey,
	mint common.PublicKey,
	burner common.PublicKey,
	tokenProgram common.PublicKey,
	systemProgram common.PublicKey,
	rent common.PublicKey,
) *ApproveUseAuthority {
	return NewApproveUseAuthorityInstructionBuilder().
		SetApproveUseAuthorityArgs(approveUseAuthorityArgs).
		SetUseAuthorityRecordAccount(useAuthorityRecord).
		SetOwnerAccount(owner).
		SetPayerAccount(payer).
		SetUserAccount(user).
		SetOwnerTokenAccountAccount(ownerTokenAccount).
		SetMetadataAccount(metadata).
		SetMintAccount(mint).
		SetBurnerAccount(burner).
		SetTokenProgramAccount(tokenProgram).
		SetSystemProgramAccount(systemProgram).
		SetRentAccount(rent)
}

// SetApproveUseAuthorityArgs sets the "approveUseAuthorityArgs" parameter.
func (obj *ApproveUseAuthority) SetApproveUseAuthorityArgs(approveUseAuthorityArgs ApproveUseAuthorityArgs) *ApproveUseAuthority {
	obj.ApproveUseAuthorityArgs = &approveUseAuthorityArgs
	return obj
}

// SetUseAuthorityRecordAccount sets the "useAuthorityRecord" parameter.
// Use Authority Record PDA
func (obj *ApproveUseAuthority) SetUseAuthorityRecordAccount(useAuthorityRecord common.PublicKey) *ApproveUseAuthority {
	obj.AccountMetaSlice[0] = common.Meta(useAuthorityRecord).WRITE()
	return obj
}

// GetUseAuthorityRecordAccount gets the "useAuthorityRecord" parameter.
// Use Authority Record PDA
func (obj *ApproveUseAuthority) GetUseAuthorityRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetOwnerAccount sets the "owner" parameter.
// Owner
func (obj *ApproveUseAuthority) SetOwnerAccount(owner common.PublicKey) *ApproveUseAuthority {
	obj.AccountMetaSlice[1] = common.Meta(owner).WRITE().SIGNER()
	return obj
}

// GetOwnerAccount gets the "owner" parameter.
// Owner
func (obj *ApproveUseAuthority) GetOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetPayerAccount sets the "payer" parameter.
// Payer
func (obj *ApproveUseAuthority) SetPayerAccount(payer common.PublicKey) *ApproveUseAuthority {
	obj.AccountMetaSlice[2] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Payer
func (obj *ApproveUseAuthority) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetUserAccount sets the "user" parameter.
// A Use Authority
func (obj *ApproveUseAuthority) SetUserAccount(user common.PublicKey) *ApproveUseAuthority {
	obj.AccountMetaSlice[3] = common.Meta(user)
	return obj
}

// GetUserAccount gets the "user" parameter.
// A Use Authority
func (obj *ApproveUseAuthority) GetUserAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetOwnerTokenAccountAccount sets the "ownerTokenAccount" parameter.
// Owned Token Account Of Mint
func (obj *ApproveUseAuthority) SetOwnerTokenAccountAccount(ownerTokenAccount common.PublicKey) *ApproveUseAuthority {
	obj.AccountMetaSlice[4] = common.Meta(ownerTokenAccount).WRITE()
	return obj
}

// GetOwnerTokenAccountAccount gets the "ownerTokenAccount" parameter.
// Owned Token Account Of Mint
func (obj *ApproveUseAuthority) GetOwnerTokenAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *ApproveUseAuthority) SetMetadataAccount(metadata common.PublicKey) *ApproveUseAuthority {
	obj.AccountMetaSlice[5] = common.Meta(metadata)
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *ApproveUseAuthority) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetMintAccount sets the "mint" parameter.
// Mint of Metadata
func (obj *ApproveUseAuthority) SetMintAccount(mint common.PublicKey) *ApproveUseAuthority {
	obj.AccountMetaSlice[6] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of Metadata
func (obj *ApproveUseAuthority) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetBurnerAccount sets the "burner" parameter.
// Program As Signer (Burner)
func (obj *ApproveUseAuthority) SetBurnerAccount(burner common.PublicKey) *ApproveUseAuthority {
	obj.AccountMetaSlice[7] = common.Meta(burner)
	return obj
}

// GetBurnerAccount gets the "burner" parameter.
// Program As Signer (Burner)
func (obj *ApproveUseAuthority) GetBurnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetTokenProgramAccount sets the "tokenProgram" parameter.
// Token program
func (obj *ApproveUseAuthority) SetTokenProgramAccount(tokenProgram common.PublicKey) *ApproveUseAuthority {
	obj.AccountMetaSlice[8] = common.Meta(tokenProgram)
	return obj
}

// GetTokenProgramAccount gets the "tokenProgram" parameter.
// Token program
func (obj *ApproveUseAuthority) GetTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *ApproveUseAuthority) SetSystemProgramAccount(systemProgram common.PublicKey) *ApproveUseAuthority {
	obj.AccountMetaSlice[9] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *ApproveUseAuthority) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetRentAccount sets the "rent" parameter.
// Rent info
func (obj *ApproveUseAuthority) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *ApproveUseAuthority {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[10] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[10] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent info
func (obj *ApproveUseAuthority) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

func (obj *ApproveUseAuthority) SetProgramId(programId *common.PublicKey) *ApproveUseAuthority {
	obj._programId = programId
	return obj
}

func (obj *ApproveUseAuthority) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_ApproveUseAuthority}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *ApproveUseAuthority) Validate() error {
	if obj.ApproveUseAuthorityArgs == nil {
		return errors.New("[ApproveUseAuthority] approveUseAuthorityArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[ApproveUseAuthority] accounts.useAuthorityRecord is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[ApproveUseAuthority] accounts.owner is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[ApproveUseAuthority] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[ApproveUseAuthority] accounts.user is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[ApproveUseAuthority] accounts.ownerTokenAccount is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[ApproveUseAuthority] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[ApproveUseAuthority] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[ApproveUseAuthority] accounts.burner is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[ApproveUseAuthority] accounts.tokenProgram is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[ApproveUseAuthority] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[ApproveUseAuthority] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *ApproveUseAuthority) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *ApproveUseAuthority) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.ApproveUseAuthorityArgs); err != nil {
		return err
	}
	return nil
}

func (obj *ApproveUseAuthority) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.ApproveUseAuthorityArgs); err != nil {
		return err
	}
	return nil
}

func (obj *ApproveUseAuthority) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("ApproveUseAuthority")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("ApproveUseAuthorityArgs", *obj.ApproveUseAuthorityArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=11]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("useAuthorityRecord", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("             owner", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("             payer", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("              user", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta(" ownerTokenAccount", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("          metadata", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("              mint", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("            burner", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("      tokenProgram", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("     systemProgram", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("              rent", obj.AccountMetaSlice.Get(10)))
					})
				})
		})
}

// RevokeUseAuthority Instruction
type RevokeUseAuthority struct {
	// [0] = [WRITE] useAuthorityRecord `Use Authority Record PDA`
	// [1] = [WRITE, SIGNER] owner `Owner`
	// [2] = [] user `A Use Authority`
	// [3] = [WRITE] ownerTokenAccount `Owned Token Account Of Mint`
	// [4] = [] mint `Mint of Metadata`
	// [5] = [] metadata `Metadata account`
	// [6] = [] tokenProgram `Token program`
	// [7] = [] systemProgram `System program`
	// [8] = [] rent `Rent info`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewRevokeUseAuthorityInstructionBuilder creates a new `RevokeUseAuthority` instruction builder.
func NewRevokeUseAuthorityInstructionBuilder() *RevokeUseAuthority {
	return &RevokeUseAuthority{
		AccountMetaSlice: make(common.AccountMetaSlice, 9),
	}
}

// NewRevokeUseAuthorityInstruction
//
// Parameters:
//
//	useAuthorityRecord: Use Authority Record PDA
//	owner: Owner
//	user: A Use Authority
//	ownerTokenAccount: Owned Token Account Of Mint
//	mint: Mint of Metadata
//	metadata: Metadata account
//	tokenProgram: Token program
//	systemProgram: System program
//	rent: Rent info
func NewRevokeUseAuthorityInstruction(
	useAuthorityRecord common.PublicKey,
	owner common.PublicKey,
	user common.PublicKey,
	ownerTokenAccount common.PublicKey,
	mint common.PublicKey,
	metadata common.PublicKey,
	tokenProgram common.PublicKey,
	systemProgram common.PublicKey,
	rent common.PublicKey,
) *RevokeUseAuthority {
	return NewRevokeUseAuthorityInstructionBuilder().
		SetUseAuthorityRecordAccount(useAuthorityRecord).
		SetOwnerAccount(owner).
		SetUserAccount(user).
		SetOwnerTokenAccountAccount(ownerTokenAccount).
		SetMintAccount(mint).
		SetMetadataAccount(metadata).
		SetTokenProgramAccount(tokenProgram).
		SetSystemProgramAccount(systemProgram).
		SetRentAccount(rent)
}

// SetUseAuthorityRecordAccount sets the "useAuthorityRecord" parameter.
// Use Authority Record PDA
func (obj *RevokeUseAuthority) SetUseAuthorityRecordAccount(useAuthorityRecord common.PublicKey) *RevokeUseAuthority {
	obj.AccountMetaSlice[0] = common.Meta(useAuthorityRecord).WRITE()
	return obj
}

// GetUseAuthorityRecordAccount gets the "useAuthorityRecord" parameter.
// Use Authority Record PDA
func (obj *RevokeUseAuthority) GetUseAuthorityRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetOwnerAccount sets the "owner" parameter.
// Owner
func (obj *RevokeUseAuthority) SetOwnerAccount(owner common.PublicKey) *RevokeUseAuthority {
	obj.AccountMetaSlice[1] = common.Meta(owner).WRITE().SIGNER()
	return obj
}

// GetOwnerAccount gets the "owner" parameter.
// Owner
func (obj *RevokeUseAuthority) GetOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetUserAccount sets the "user" parameter.
// A Use Authority
func (obj *RevokeUseAuthority) SetUserAccount(user common.PublicKey) *RevokeUseAuthority {
	obj.AccountMetaSlice[2] = common.Meta(user)
	return obj
}

// GetUserAccount gets the "user" parameter.
// A Use Authority
func (obj *RevokeUseAuthority) GetUserAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetOwnerTokenAccountAccount sets the "ownerTokenAccount" parameter.
// Owned Token Account Of Mint
func (obj *RevokeUseAuthority) SetOwnerTokenAccountAccount(ownerTokenAccount common.PublicKey) *RevokeUseAuthority {
	obj.AccountMetaSlice[3] = common.Meta(ownerTokenAccount).WRITE()
	return obj
}

// GetOwnerTokenAccountAccount gets the "ownerTokenAccount" parameter.
// Owned Token Account Of Mint
func (obj *RevokeUseAuthority) GetOwnerTokenAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetMintAccount sets the "mint" parameter.
// Mint of Metadata
func (obj *RevokeUseAuthority) SetMintAccount(mint common.PublicKey) *RevokeUseAuthority {
	obj.AccountMetaSlice[4] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of Metadata
func (obj *RevokeUseAuthority) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *RevokeUseAuthority) SetMetadataAccount(metadata common.PublicKey) *RevokeUseAuthority {
	obj.AccountMetaSlice[5] = common.Meta(metadata)
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *RevokeUseAuthority) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetTokenProgramAccount sets the "tokenProgram" parameter.
// Token program
func (obj *RevokeUseAuthority) SetTokenProgramAccount(tokenProgram common.PublicKey) *RevokeUseAuthority {
	obj.AccountMetaSlice[6] = common.Meta(tokenProgram)
	return obj
}

// GetTokenProgramAccount gets the "tokenProgram" parameter.
// Token program
func (obj *RevokeUseAuthority) GetTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *RevokeUseAuthority) SetSystemProgramAccount(systemProgram common.PublicKey) *RevokeUseAuthority {
	obj.AccountMetaSlice[7] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *RevokeUseAuthority) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetRentAccount sets the "rent" parameter.
// Rent info
func (obj *RevokeUseAuthority) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *RevokeUseAuthority {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[8] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[8] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent info
func (obj *RevokeUseAuthority) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

func (obj *RevokeUseAuthority) SetProgramId(programId *common.PublicKey) *RevokeUseAuthority {
	obj._programId = programId
	return obj
}

func (obj *RevokeUseAuthority) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_RevokeUseAuthority}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *RevokeUseAuthority) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[RevokeUseAuthority] accounts.useAuthorityRecord is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[RevokeUseAuthority] accounts.owner is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[RevokeUseAuthority] accounts.user is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[RevokeUseAuthority] accounts.ownerTokenAccount is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[RevokeUseAuthority] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[RevokeUseAuthority] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[RevokeUseAuthority] accounts.tokenProgram is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[RevokeUseAuthority] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[RevokeUseAuthority] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *RevokeUseAuthority) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *RevokeUseAuthority) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *RevokeUseAuthority) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *RevokeUseAuthority) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("RevokeUseAuthority")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=9]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("useAuthorityRecord", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("             owner", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("              user", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta(" ownerTokenAccount", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("              mint", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("          metadata", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("      tokenProgram", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("     systemProgram", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("              rent", obj.AccountMetaSlice.Get(8)))
					})
				})
		})
}

// UnverifyCollection Instruction
type UnverifyCollection struct {
	// [0] = [WRITE] metadata `Metadata account`
	// [1] = [WRITE, SIGNER] collectionAuthority `Collection Authority`
	// [2] = [] collectionMint `Mint of the Collection`
	// [3] = [] collection `Metadata Account of the Collection`
	// [4] = [] collectionMasterEditionAccount `MasterEdition2 Account of the Collection Token`
	// [5] = [] collectionAuthorityRecord `Collection Authority Record PDA`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewUnverifyCollectionInstructionBuilder creates a new `UnverifyCollection` instruction builder.
func NewUnverifyCollectionInstructionBuilder() *UnverifyCollection {
	return &UnverifyCollection{
		AccountMetaSlice: make(common.AccountMetaSlice, 6),
	}
}

// NewUnverifyCollectionInstruction
//
// Parameters:
//
//	metadata: Metadata account
//	collectionAuthority: Collection Authority
//	collectionMint: Mint of the Collection
//	collection: Metadata Account of the Collection
//	collectionMasterEditionAccount: MasterEdition2 Account of the Collection Token
//	collectionAuthorityRecord: Collection Authority Record PDA
func NewUnverifyCollectionInstruction(
	metadata common.PublicKey,
	collectionAuthority common.PublicKey,
	collectionMint common.PublicKey,
	collection common.PublicKey,
	collectionMasterEditionAccount common.PublicKey,
	collectionAuthorityRecord common.PublicKey,
) *UnverifyCollection {
	return NewUnverifyCollectionInstructionBuilder().
		SetMetadataAccount(metadata).
		SetCollectionAuthorityAccount(collectionAuthority).
		SetCollectionMintAccount(collectionMint).
		SetCollectionAccount(collection).
		SetCollectionMasterEditionAccountAccount(collectionMasterEditionAccount).
		SetCollectionAuthorityRecordAccount(collectionAuthorityRecord)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *UnverifyCollection) SetMetadataAccount(metadata common.PublicKey) *UnverifyCollection {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *UnverifyCollection) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetCollectionAuthorityAccount sets the "collectionAuthority" parameter.
// Collection Authority
func (obj *UnverifyCollection) SetCollectionAuthorityAccount(collectionAuthority common.PublicKey) *UnverifyCollection {
	obj.AccountMetaSlice[1] = common.Meta(collectionAuthority).WRITE().SIGNER()
	return obj
}

// GetCollectionAuthorityAccount gets the "collectionAuthority" parameter.
// Collection Authority
func (obj *UnverifyCollection) GetCollectionAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetCollectionMintAccount sets the "collectionMint" parameter.
// Mint of the Collection
func (obj *UnverifyCollection) SetCollectionMintAccount(collectionMint common.PublicKey) *UnverifyCollection {
	obj.AccountMetaSlice[2] = common.Meta(collectionMint)
	return obj
}

// GetCollectionMintAccount gets the "collectionMint" parameter.
// Mint of the Collection
func (obj *UnverifyCollection) GetCollectionMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetCollectionAccount sets the "collection" parameter.
// Metadata Account of the Collection
func (obj *UnverifyCollection) SetCollectionAccount(collection common.PublicKey) *UnverifyCollection {
	obj.AccountMetaSlice[3] = common.Meta(collection)
	return obj
}

// GetCollectionAccount gets the "collection" parameter.
// Metadata Account of the Collection
func (obj *UnverifyCollection) GetCollectionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetCollectionMasterEditionAccountAccount sets the "collectionMasterEditionAccount" parameter.
// MasterEdition2 Account of the Collection Token
func (obj *UnverifyCollection) SetCollectionMasterEditionAccountAccount(collectionMasterEditionAccount common.PublicKey) *UnverifyCollection {
	obj.AccountMetaSlice[4] = common.Meta(collectionMasterEditionAccount)
	return obj
}

// GetCollectionMasterEditionAccountAccount gets the "collectionMasterEditionAccount" parameter.
// MasterEdition2 Account of the Collection Token
func (obj *UnverifyCollection) GetCollectionMasterEditionAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetCollectionAuthorityRecordAccount sets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *UnverifyCollection) SetCollectionAuthorityRecordAccount(collectionAuthorityRecord common.PublicKey, multiSigners ...common.PublicKey) *UnverifyCollection {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[5] = common.Meta(collectionAuthorityRecord)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[5] = common.Meta(collectionAuthorityRecord)
	}
	return obj
}

// GetCollectionAuthorityRecordAccount gets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *UnverifyCollection) GetCollectionAuthorityRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

func (obj *UnverifyCollection) SetProgramId(programId *common.PublicKey) *UnverifyCollection {
	obj._programId = programId
	return obj
}

func (obj *UnverifyCollection) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_UnverifyCollection}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *UnverifyCollection) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[UnverifyCollection] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[UnverifyCollection] accounts.collectionAuthority is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[UnverifyCollection] accounts.collectionMint is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[UnverifyCollection] accounts.collection is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[UnverifyCollection] accounts.collectionMasterEditionAccount is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[UnverifyCollection] accounts.collectionAuthorityRecord is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *UnverifyCollection) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *UnverifyCollection) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *UnverifyCollection) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *UnverifyCollection) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("UnverifyCollection")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=6]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                      metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("           collectionAuthority", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                collectionMint", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("                    collection", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("collectionMasterEditionAccount", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("     collectionAuthorityRecord", obj.AccountMetaSlice.Get(5)))
					})
				})
		})
}

// ApproveCollectionAuthority Instruction
type ApproveCollectionAuthority struct {
	// [0] = [WRITE] collectionAuthorityRecord `Collection Authority Record PDA`
	// [1] = [] newCollectionAuthority `A Collection Authority`
	// [2] = [WRITE, SIGNER] updateAuthority `Update Authority of Collection NFT`
	// [3] = [WRITE, SIGNER] payer `Payer`
	// [4] = [] metadata `Collection Metadata account`
	// [5] = [] mint `Mint of Collection Metadata`
	// [6] = [] systemProgram `System program`
	// [7] = [] rent `Rent info`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewApproveCollectionAuthorityInstructionBuilder creates a new `ApproveCollectionAuthority` instruction builder.
func NewApproveCollectionAuthorityInstructionBuilder() *ApproveCollectionAuthority {
	return &ApproveCollectionAuthority{
		AccountMetaSlice: make(common.AccountMetaSlice, 8),
	}
}

// NewApproveCollectionAuthorityInstruction
//
// Parameters:
//
//	collectionAuthorityRecord: Collection Authority Record PDA
//	newCollectionAuthority: A Collection Authority
//	updateAuthority: Update Authority of Collection NFT
//	payer: Payer
//	metadata: Collection Metadata account
//	mint: Mint of Collection Metadata
//	systemProgram: System program
//	rent: Rent info
func NewApproveCollectionAuthorityInstruction(
	collectionAuthorityRecord common.PublicKey,
	newCollectionAuthority common.PublicKey,
	updateAuthority common.PublicKey,
	payer common.PublicKey,
	metadata common.PublicKey,
	mint common.PublicKey,
	systemProgram common.PublicKey,
	rent common.PublicKey,
) *ApproveCollectionAuthority {
	return NewApproveCollectionAuthorityInstructionBuilder().
		SetCollectionAuthorityRecordAccount(collectionAuthorityRecord).
		SetNewCollectionAuthorityAccount(newCollectionAuthority).
		SetUpdateAuthorityAccount(updateAuthority).
		SetPayerAccount(payer).
		SetMetadataAccount(metadata).
		SetMintAccount(mint).
		SetSystemProgramAccount(systemProgram).
		SetRentAccount(rent)
}

// SetCollectionAuthorityRecordAccount sets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *ApproveCollectionAuthority) SetCollectionAuthorityRecordAccount(collectionAuthorityRecord common.PublicKey) *ApproveCollectionAuthority {
	obj.AccountMetaSlice[0] = common.Meta(collectionAuthorityRecord).WRITE()
	return obj
}

// GetCollectionAuthorityRecordAccount gets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *ApproveCollectionAuthority) GetCollectionAuthorityRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetNewCollectionAuthorityAccount sets the "newCollectionAuthority" parameter.
// A Collection Authority
func (obj *ApproveCollectionAuthority) SetNewCollectionAuthorityAccount(newCollectionAuthority common.PublicKey) *ApproveCollectionAuthority {
	obj.AccountMetaSlice[1] = common.Meta(newCollectionAuthority)
	return obj
}

// GetNewCollectionAuthorityAccount gets the "newCollectionAuthority" parameter.
// A Collection Authority
func (obj *ApproveCollectionAuthority) GetNewCollectionAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// Update Authority of Collection NFT
func (obj *ApproveCollectionAuthority) SetUpdateAuthorityAccount(updateAuthority common.PublicKey) *ApproveCollectionAuthority {
	obj.AccountMetaSlice[2] = common.Meta(updateAuthority).WRITE().SIGNER()
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// Update Authority of Collection NFT
func (obj *ApproveCollectionAuthority) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetPayerAccount sets the "payer" parameter.
// Payer
func (obj *ApproveCollectionAuthority) SetPayerAccount(payer common.PublicKey) *ApproveCollectionAuthority {
	obj.AccountMetaSlice[3] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Payer
func (obj *ApproveCollectionAuthority) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetMetadataAccount sets the "metadata" parameter.
// Collection Metadata account
func (obj *ApproveCollectionAuthority) SetMetadataAccount(metadata common.PublicKey) *ApproveCollectionAuthority {
	obj.AccountMetaSlice[4] = common.Meta(metadata)
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Collection Metadata account
func (obj *ApproveCollectionAuthority) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetMintAccount sets the "mint" parameter.
// Mint of Collection Metadata
func (obj *ApproveCollectionAuthority) SetMintAccount(mint common.PublicKey) *ApproveCollectionAuthority {
	obj.AccountMetaSlice[5] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of Collection Metadata
func (obj *ApproveCollectionAuthority) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *ApproveCollectionAuthority) SetSystemProgramAccount(systemProgram common.PublicKey) *ApproveCollectionAuthority {
	obj.AccountMetaSlice[6] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *ApproveCollectionAuthority) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetRentAccount sets the "rent" parameter.
// Rent info
func (obj *ApproveCollectionAuthority) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *ApproveCollectionAuthority {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[7] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[7] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent info
func (obj *ApproveCollectionAuthority) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

func (obj *ApproveCollectionAuthority) SetProgramId(programId *common.PublicKey) *ApproveCollectionAuthority {
	obj._programId = programId
	return obj
}

func (obj *ApproveCollectionAuthority) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_ApproveCollectionAuthority}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *ApproveCollectionAuthority) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[ApproveCollectionAuthority] accounts.collectionAuthorityRecord is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[ApproveCollectionAuthority] accounts.newCollectionAuthority is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[ApproveCollectionAuthority] accounts.updateAuthority is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[ApproveCollectionAuthority] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[ApproveCollectionAuthority] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[ApproveCollectionAuthority] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[ApproveCollectionAuthority] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[ApproveCollectionAuthority] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *ApproveCollectionAuthority) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *ApproveCollectionAuthority) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *ApproveCollectionAuthority) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *ApproveCollectionAuthority) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("ApproveCollectionAuthority")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=8]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("collectionAuthorityRecord", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("   newCollectionAuthority", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("          updateAuthority", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("                    payer", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                 metadata", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                     mint", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("            systemProgram", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("                     rent", obj.AccountMetaSlice.Get(7)))
					})
				})
		})
}

// RevokeCollectionAuthority Instruction
type RevokeCollectionAuthority struct {
	// [0] = [WRITE] collectionAuthorityRecord `Collection Authority Record PDA`
	// [1] = [WRITE] delegateAuthority `Delegated Collection Authority`
	// [2] = [WRITE, SIGNER] revokeAuthority `Update Authority, or Delegated Authority, of Collection NFT`
	// [3] = [] metadata `Metadata account`
	// [4] = [] mint `Mint of Metadata`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewRevokeCollectionAuthorityInstructionBuilder creates a new `RevokeCollectionAuthority` instruction builder.
func NewRevokeCollectionAuthorityInstructionBuilder() *RevokeCollectionAuthority {
	return &RevokeCollectionAuthority{
		AccountMetaSlice: make(common.AccountMetaSlice, 5),
	}
}

// NewRevokeCollectionAuthorityInstruction
//
// Parameters:
//
//	collectionAuthorityRecord: Collection Authority Record PDA
//	delegateAuthority: Delegated Collection Authority
//	revokeAuthority: Update Authority, or Delegated Authority, of Collection NFT
//	metadata: Metadata account
//	mint: Mint of Metadata
func NewRevokeCollectionAuthorityInstruction(
	collectionAuthorityRecord common.PublicKey,
	delegateAuthority common.PublicKey,
	revokeAuthority common.PublicKey,
	metadata common.PublicKey,
	mint common.PublicKey,
) *RevokeCollectionAuthority {
	return NewRevokeCollectionAuthorityInstructionBuilder().
		SetCollectionAuthorityRecordAccount(collectionAuthorityRecord).
		SetDelegateAuthorityAccount(delegateAuthority).
		SetRevokeAuthorityAccount(revokeAuthority).
		SetMetadataAccount(metadata).
		SetMintAccount(mint)
}

// SetCollectionAuthorityRecordAccount sets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *RevokeCollectionAuthority) SetCollectionAuthorityRecordAccount(collectionAuthorityRecord common.PublicKey) *RevokeCollectionAuthority {
	obj.AccountMetaSlice[0] = common.Meta(collectionAuthorityRecord).WRITE()
	return obj
}

// GetCollectionAuthorityRecordAccount gets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *RevokeCollectionAuthority) GetCollectionAuthorityRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetDelegateAuthorityAccount sets the "delegateAuthority" parameter.
// Delegated Collection Authority
func (obj *RevokeCollectionAuthority) SetDelegateAuthorityAccount(delegateAuthority common.PublicKey) *RevokeCollectionAuthority {
	obj.AccountMetaSlice[1] = common.Meta(delegateAuthority).WRITE()
	return obj
}

// GetDelegateAuthorityAccount gets the "delegateAuthority" parameter.
// Delegated Collection Authority
func (obj *RevokeCollectionAuthority) GetDelegateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetRevokeAuthorityAccount sets the "revokeAuthority" parameter.
// Update Authority, or Delegated Authority, of Collection NFT
func (obj *RevokeCollectionAuthority) SetRevokeAuthorityAccount(revokeAuthority common.PublicKey) *RevokeCollectionAuthority {
	obj.AccountMetaSlice[2] = common.Meta(revokeAuthority).WRITE().SIGNER()
	return obj
}

// GetRevokeAuthorityAccount gets the "revokeAuthority" parameter.
// Update Authority, or Delegated Authority, of Collection NFT
func (obj *RevokeCollectionAuthority) GetRevokeAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *RevokeCollectionAuthority) SetMetadataAccount(metadata common.PublicKey) *RevokeCollectionAuthority {
	obj.AccountMetaSlice[3] = common.Meta(metadata)
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *RevokeCollectionAuthority) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetMintAccount sets the "mint" parameter.
// Mint of Metadata
func (obj *RevokeCollectionAuthority) SetMintAccount(mint common.PublicKey, multiSigners ...common.PublicKey) *RevokeCollectionAuthority {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[4] = common.Meta(mint)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[4] = common.Meta(mint)
	}
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of Metadata
func (obj *RevokeCollectionAuthority) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

func (obj *RevokeCollectionAuthority) SetProgramId(programId *common.PublicKey) *RevokeCollectionAuthority {
	obj._programId = programId
	return obj
}

func (obj *RevokeCollectionAuthority) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_RevokeCollectionAuthority}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *RevokeCollectionAuthority) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[RevokeCollectionAuthority] accounts.collectionAuthorityRecord is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[RevokeCollectionAuthority] accounts.delegateAuthority is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[RevokeCollectionAuthority] accounts.revokeAuthority is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[RevokeCollectionAuthority] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[RevokeCollectionAuthority] accounts.mint is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *RevokeCollectionAuthority) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *RevokeCollectionAuthority) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *RevokeCollectionAuthority) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *RevokeCollectionAuthority) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("RevokeCollectionAuthority")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=5]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("collectionAuthorityRecord", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("        delegateAuthority", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("          revokeAuthority", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("                 metadata", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                     mint", obj.AccountMetaSlice.Get(4)))
					})
				})
		})
}

// SetAndVerifyCollection Instruction
type SetAndVerifyCollection struct {
	// [0] = [WRITE] metadata `Metadata account`
	// [1] = [WRITE, SIGNER] collectionAuthority `Collection Update authority`
	// [2] = [WRITE, SIGNER] payer `Payer`
	// [3] = [] updateAuthority `Update Authority of Collection NFT and NFT`
	// [4] = [] collectionMint `Mint of the Collection`
	// [5] = [] collection `Metadata Account of the Collection`
	// [6] = [] collectionMasterEditionAccount `MasterEdition2 Account of the Collection Token`
	// [7] = [] collectionAuthorityRecord `Collection Authority Record PDA`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewSetAndVerifyCollectionInstructionBuilder creates a new `SetAndVerifyCollection` instruction builder.
func NewSetAndVerifyCollectionInstructionBuilder() *SetAndVerifyCollection {
	return &SetAndVerifyCollection{
		AccountMetaSlice: make(common.AccountMetaSlice, 8),
	}
}

// NewSetAndVerifyCollectionInstruction
//
// Parameters:
//
//	metadata: Metadata account
//	collectionAuthority: Collection Update authority
//	payer: Payer
//	updateAuthority: Update Authority of Collection NFT and NFT
//	collectionMint: Mint of the Collection
//	collection: Metadata Account of the Collection
//	collectionMasterEditionAccount: MasterEdition2 Account of the Collection Token
//	collectionAuthorityRecord: Collection Authority Record PDA
func NewSetAndVerifyCollectionInstruction(
	metadata common.PublicKey,
	collectionAuthority common.PublicKey,
	payer common.PublicKey,
	updateAuthority common.PublicKey,
	collectionMint common.PublicKey,
	collection common.PublicKey,
	collectionMasterEditionAccount common.PublicKey,
	collectionAuthorityRecord common.PublicKey,
) *SetAndVerifyCollection {
	return NewSetAndVerifyCollectionInstructionBuilder().
		SetMetadataAccount(metadata).
		SetCollectionAuthorityAccount(collectionAuthority).
		SetPayerAccount(payer).
		SetUpdateAuthorityAccount(updateAuthority).
		SetCollectionMintAccount(collectionMint).
		SetCollectionAccount(collection).
		SetCollectionMasterEditionAccountAccount(collectionMasterEditionAccount).
		SetCollectionAuthorityRecordAccount(collectionAuthorityRecord)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *SetAndVerifyCollection) SetMetadataAccount(metadata common.PublicKey) *SetAndVerifyCollection {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *SetAndVerifyCollection) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetCollectionAuthorityAccount sets the "collectionAuthority" parameter.
// Collection Update authority
func (obj *SetAndVerifyCollection) SetCollectionAuthorityAccount(collectionAuthority common.PublicKey) *SetAndVerifyCollection {
	obj.AccountMetaSlice[1] = common.Meta(collectionAuthority).WRITE().SIGNER()
	return obj
}

// GetCollectionAuthorityAccount gets the "collectionAuthority" parameter.
// Collection Update authority
func (obj *SetAndVerifyCollection) GetCollectionAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetPayerAccount sets the "payer" parameter.
// Payer
func (obj *SetAndVerifyCollection) SetPayerAccount(payer common.PublicKey) *SetAndVerifyCollection {
	obj.AccountMetaSlice[2] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Payer
func (obj *SetAndVerifyCollection) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// Update Authority of Collection NFT and NFT
func (obj *SetAndVerifyCollection) SetUpdateAuthorityAccount(updateAuthority common.PublicKey) *SetAndVerifyCollection {
	obj.AccountMetaSlice[3] = common.Meta(updateAuthority)
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// Update Authority of Collection NFT and NFT
func (obj *SetAndVerifyCollection) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetCollectionMintAccount sets the "collectionMint" parameter.
// Mint of the Collection
func (obj *SetAndVerifyCollection) SetCollectionMintAccount(collectionMint common.PublicKey) *SetAndVerifyCollection {
	obj.AccountMetaSlice[4] = common.Meta(collectionMint)
	return obj
}

// GetCollectionMintAccount gets the "collectionMint" parameter.
// Mint of the Collection
func (obj *SetAndVerifyCollection) GetCollectionMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetCollectionAccount sets the "collection" parameter.
// Metadata Account of the Collection
func (obj *SetAndVerifyCollection) SetCollectionAccount(collection common.PublicKey) *SetAndVerifyCollection {
	obj.AccountMetaSlice[5] = common.Meta(collection)
	return obj
}

// GetCollectionAccount gets the "collection" parameter.
// Metadata Account of the Collection
func (obj *SetAndVerifyCollection) GetCollectionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetCollectionMasterEditionAccountAccount sets the "collectionMasterEditionAccount" parameter.
// MasterEdition2 Account of the Collection Token
func (obj *SetAndVerifyCollection) SetCollectionMasterEditionAccountAccount(collectionMasterEditionAccount common.PublicKey) *SetAndVerifyCollection {
	obj.AccountMetaSlice[6] = common.Meta(collectionMasterEditionAccount)
	return obj
}

// GetCollectionMasterEditionAccountAccount gets the "collectionMasterEditionAccount" parameter.
// MasterEdition2 Account of the Collection Token
func (obj *SetAndVerifyCollection) GetCollectionMasterEditionAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetCollectionAuthorityRecordAccount sets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *SetAndVerifyCollection) SetCollectionAuthorityRecordAccount(collectionAuthorityRecord common.PublicKey, multiSigners ...common.PublicKey) *SetAndVerifyCollection {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[7] = common.Meta(collectionAuthorityRecord)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[7] = common.Meta(collectionAuthorityRecord)
	}
	return obj
}

// GetCollectionAuthorityRecordAccount gets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *SetAndVerifyCollection) GetCollectionAuthorityRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

func (obj *SetAndVerifyCollection) SetProgramId(programId *common.PublicKey) *SetAndVerifyCollection {
	obj._programId = programId
	return obj
}

func (obj *SetAndVerifyCollection) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_SetAndVerifyCollection}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *SetAndVerifyCollection) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[SetAndVerifyCollection] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[SetAndVerifyCollection] accounts.collectionAuthority is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[SetAndVerifyCollection] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[SetAndVerifyCollection] accounts.updateAuthority is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[SetAndVerifyCollection] accounts.collectionMint is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[SetAndVerifyCollection] accounts.collection is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[SetAndVerifyCollection] accounts.collectionMasterEditionAccount is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[SetAndVerifyCollection] accounts.collectionAuthorityRecord is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *SetAndVerifyCollection) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *SetAndVerifyCollection) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *SetAndVerifyCollection) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *SetAndVerifyCollection) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("SetAndVerifyCollection")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=8]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                      metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("           collectionAuthority", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                         payer", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("               updateAuthority", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                collectionMint", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                    collection", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("collectionMasterEditionAccount", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("     collectionAuthorityRecord", obj.AccountMetaSlice.Get(7)))
					})
				})
		})
}

// FreezeDelegatedAccount Instruction
type FreezeDelegatedAccount struct {
	// [0] = [WRITE, SIGNER] delegate `Delegate`
	// [1] = [WRITE] tokenAccount `Token account to freeze`
	// [2] = [] edition `Edition`
	// [3] = [] mint `Token mint`
	// [4] = [] tokenProgram `Token Program`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewFreezeDelegatedAccountInstructionBuilder creates a new `FreezeDelegatedAccount` instruction builder.
func NewFreezeDelegatedAccountInstructionBuilder() *FreezeDelegatedAccount {
	return &FreezeDelegatedAccount{
		AccountMetaSlice: make(common.AccountMetaSlice, 5),
	}
}

// NewFreezeDelegatedAccountInstruction
//
// Parameters:
//
//	delegate: Delegate
//	tokenAccount: Token account to freeze
//	edition: Edition
//	mint: Token mint
//	tokenProgram: Token Program
func NewFreezeDelegatedAccountInstruction(
	delegate common.PublicKey,
	tokenAccount common.PublicKey,
	edition common.PublicKey,
	mint common.PublicKey,
	tokenProgram common.PublicKey,
) *FreezeDelegatedAccount {
	return NewFreezeDelegatedAccountInstructionBuilder().
		SetDelegateAccount(delegate).
		SetTokenAccountAccount(tokenAccount).
		SetEditionAccount(edition).
		SetMintAccount(mint).
		SetTokenProgramAccount(tokenProgram)
}

// SetDelegateAccount sets the "delegate" parameter.
// Delegate
func (obj *FreezeDelegatedAccount) SetDelegateAccount(delegate common.PublicKey) *FreezeDelegatedAccount {
	obj.AccountMetaSlice[0] = common.Meta(delegate).WRITE().SIGNER()
	return obj
}

// GetDelegateAccount gets the "delegate" parameter.
// Delegate
func (obj *FreezeDelegatedAccount) GetDelegateAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetTokenAccountAccount sets the "tokenAccount" parameter.
// Token account to freeze
func (obj *FreezeDelegatedAccount) SetTokenAccountAccount(tokenAccount common.PublicKey) *FreezeDelegatedAccount {
	obj.AccountMetaSlice[1] = common.Meta(tokenAccount).WRITE()
	return obj
}

// GetTokenAccountAccount gets the "tokenAccount" parameter.
// Token account to freeze
func (obj *FreezeDelegatedAccount) GetTokenAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetEditionAccount sets the "edition" parameter.
// Edition
func (obj *FreezeDelegatedAccount) SetEditionAccount(edition common.PublicKey) *FreezeDelegatedAccount {
	obj.AccountMetaSlice[2] = common.Meta(edition)
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Edition
func (obj *FreezeDelegatedAccount) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMintAccount sets the "mint" parameter.
// Token mint
func (obj *FreezeDelegatedAccount) SetMintAccount(mint common.PublicKey) *FreezeDelegatedAccount {
	obj.AccountMetaSlice[3] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Token mint
func (obj *FreezeDelegatedAccount) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetTokenProgramAccount sets the "tokenProgram" parameter.
// Token Program
func (obj *FreezeDelegatedAccount) SetTokenProgramAccount(tokenProgram common.PublicKey, multiSigners ...common.PublicKey) *FreezeDelegatedAccount {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[4] = common.Meta(tokenProgram)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[4] = common.Meta(tokenProgram)
	}
	return obj
}

// GetTokenProgramAccount gets the "tokenProgram" parameter.
// Token Program
func (obj *FreezeDelegatedAccount) GetTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

func (obj *FreezeDelegatedAccount) SetProgramId(programId *common.PublicKey) *FreezeDelegatedAccount {
	obj._programId = programId
	return obj
}

func (obj *FreezeDelegatedAccount) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_FreezeDelegatedAccount}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *FreezeDelegatedAccount) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[FreezeDelegatedAccount] accounts.delegate is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[FreezeDelegatedAccount] accounts.tokenAccount is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[FreezeDelegatedAccount] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[FreezeDelegatedAccount] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[FreezeDelegatedAccount] accounts.tokenProgram is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *FreezeDelegatedAccount) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *FreezeDelegatedAccount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *FreezeDelegatedAccount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *FreezeDelegatedAccount) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("FreezeDelegatedAccount")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=5]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("    delegate", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("tokenAccount", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("     edition", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("        mint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("tokenProgram", obj.AccountMetaSlice.Get(4)))
					})
				})
		})
}

// ThawDelegatedAccount Instruction
type ThawDelegatedAccount struct {
	// [0] = [WRITE, SIGNER] delegate `Delegate`
	// [1] = [WRITE] tokenAccount `Token account to thaw`
	// [2] = [] edition `Edition`
	// [3] = [] mint `Token mint`
	// [4] = [] tokenProgram `Token Program`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewThawDelegatedAccountInstructionBuilder creates a new `ThawDelegatedAccount` instruction builder.
func NewThawDelegatedAccountInstructionBuilder() *ThawDelegatedAccount {
	return &ThawDelegatedAccount{
		AccountMetaSlice: make(common.AccountMetaSlice, 5),
	}
}

// NewThawDelegatedAccountInstruction
//
// Parameters:
//
//	delegate: Delegate
//	tokenAccount: Token account to thaw
//	edition: Edition
//	mint: Token mint
//	tokenProgram: Token Program
func NewThawDelegatedAccountInstruction(
	delegate common.PublicKey,
	tokenAccount common.PublicKey,
	edition common.PublicKey,
	mint common.PublicKey,
	tokenProgram common.PublicKey,
) *ThawDelegatedAccount {
	return NewThawDelegatedAccountInstructionBuilder().
		SetDelegateAccount(delegate).
		SetTokenAccountAccount(tokenAccount).
		SetEditionAccount(edition).
		SetMintAccount(mint).
		SetTokenProgramAccount(tokenProgram)
}

// SetDelegateAccount sets the "delegate" parameter.
// Delegate
func (obj *ThawDelegatedAccount) SetDelegateAccount(delegate common.PublicKey) *ThawDelegatedAccount {
	obj.AccountMetaSlice[0] = common.Meta(delegate).WRITE().SIGNER()
	return obj
}

// GetDelegateAccount gets the "delegate" parameter.
// Delegate
func (obj *ThawDelegatedAccount) GetDelegateAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetTokenAccountAccount sets the "tokenAccount" parameter.
// Token account to thaw
func (obj *ThawDelegatedAccount) SetTokenAccountAccount(tokenAccount common.PublicKey) *ThawDelegatedAccount {
	obj.AccountMetaSlice[1] = common.Meta(tokenAccount).WRITE()
	return obj
}

// GetTokenAccountAccount gets the "tokenAccount" parameter.
// Token account to thaw
func (obj *ThawDelegatedAccount) GetTokenAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetEditionAccount sets the "edition" parameter.
// Edition
func (obj *ThawDelegatedAccount) SetEditionAccount(edition common.PublicKey) *ThawDelegatedAccount {
	obj.AccountMetaSlice[2] = common.Meta(edition)
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Edition
func (obj *ThawDelegatedAccount) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMintAccount sets the "mint" parameter.
// Token mint
func (obj *ThawDelegatedAccount) SetMintAccount(mint common.PublicKey) *ThawDelegatedAccount {
	obj.AccountMetaSlice[3] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Token mint
func (obj *ThawDelegatedAccount) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetTokenProgramAccount sets the "tokenProgram" parameter.
// Token Program
func (obj *ThawDelegatedAccount) SetTokenProgramAccount(tokenProgram common.PublicKey, multiSigners ...common.PublicKey) *ThawDelegatedAccount {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[4] = common.Meta(tokenProgram)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[4] = common.Meta(tokenProgram)
	}
	return obj
}

// GetTokenProgramAccount gets the "tokenProgram" parameter.
// Token Program
func (obj *ThawDelegatedAccount) GetTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

func (obj *ThawDelegatedAccount) SetProgramId(programId *common.PublicKey) *ThawDelegatedAccount {
	obj._programId = programId
	return obj
}

func (obj *ThawDelegatedAccount) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_ThawDelegatedAccount}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *ThawDelegatedAccount) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[ThawDelegatedAccount] accounts.delegate is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[ThawDelegatedAccount] accounts.tokenAccount is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[ThawDelegatedAccount] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[ThawDelegatedAccount] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[ThawDelegatedAccount] accounts.tokenProgram is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *ThawDelegatedAccount) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *ThawDelegatedAccount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *ThawDelegatedAccount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *ThawDelegatedAccount) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("ThawDelegatedAccount")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=5]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("    delegate", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("tokenAccount", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("     edition", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("        mint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("tokenProgram", obj.AccountMetaSlice.Get(4)))
					})
				})
		})
}

// RemoveCreatorVerification Instruction
type RemoveCreatorVerification struct {
	// [0] = [WRITE] metadata `Metadata (pda of ['metadata', program id, mint id])`
	// [1] = [SIGNER] creator `Creator`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewRemoveCreatorVerificationInstructionBuilder creates a new `RemoveCreatorVerification` instruction builder.
func NewRemoveCreatorVerificationInstructionBuilder() *RemoveCreatorVerification {
	return &RemoveCreatorVerification{
		AccountMetaSlice: make(common.AccountMetaSlice, 2),
	}
}

// NewRemoveCreatorVerificationInstruction
//
// Parameters:
//
//	metadata: Metadata (pda of ['metadata', program id, mint id])
//	creator: Creator
func NewRemoveCreatorVerificationInstruction(
	metadata common.PublicKey,
	creator common.PublicKey,
) *RemoveCreatorVerification {
	return NewRemoveCreatorVerificationInstructionBuilder().
		SetMetadataAccount(metadata).
		SetCreatorAccount(creator)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata (pda of ['metadata', program id, mint id])
func (obj *RemoveCreatorVerification) SetMetadataAccount(metadata common.PublicKey) *RemoveCreatorVerification {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata (pda of ['metadata', program id, mint id])
func (obj *RemoveCreatorVerification) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetCreatorAccount sets the "creator" parameter.
// Creator
func (obj *RemoveCreatorVerification) SetCreatorAccount(creator common.PublicKey, multiSigners ...common.PublicKey) *RemoveCreatorVerification {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[1] = common.Meta(creator)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[1] = common.Meta(creator).SIGNER()
	}
	return obj
}

// GetCreatorAccount gets the "creator" parameter.
// Creator
func (obj *RemoveCreatorVerification) GetCreatorAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

func (obj *RemoveCreatorVerification) SetProgramId(programId *common.PublicKey) *RemoveCreatorVerification {
	obj._programId = programId
	return obj
}

func (obj *RemoveCreatorVerification) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_RemoveCreatorVerification}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *RemoveCreatorVerification) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[RemoveCreatorVerification] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[RemoveCreatorVerification] accounts.creator is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *RemoveCreatorVerification) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *RemoveCreatorVerification) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *RemoveCreatorVerification) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *RemoveCreatorVerification) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("RemoveCreatorVerification")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=2]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta(" creator", obj.AccountMetaSlice.Get(1)))
					})
				})
		})
}

// BurnNft Instruction
type BurnNft struct {
	// [0] = [WRITE] metadata `Metadata (pda of ['metadata', program id, mint id])`
	// [1] = [WRITE, SIGNER] owner `NFT owner`
	// [2] = [WRITE] mint `Mint of the NFT`
	// [3] = [WRITE] tokenAccount `Token account to close`
	// [4] = [WRITE] masterEditionAccount `MasterEdition2 of the NFT`
	// [5] = [] splTokenProgram `SPL Token Program`
	// [6] = [WRITE] collectionMetadata `Metadata of the Collection`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewBurnNftInstructionBuilder creates a new `BurnNft` instruction builder.
func NewBurnNftInstructionBuilder() *BurnNft {
	return &BurnNft{
		AccountMetaSlice: make(common.AccountMetaSlice, 7),
	}
}

// NewBurnNftInstruction
//
// Parameters:
//
//	metadata: Metadata (pda of ['metadata', program id, mint id])
//	owner: NFT owner
//	mint: Mint of the NFT
//	tokenAccount: Token account to close
//	masterEditionAccount: MasterEdition2 of the NFT
//	splTokenProgram: SPL Token Program
//	collectionMetadata: Metadata of the Collection
func NewBurnNftInstruction(
	metadata common.PublicKey,
	owner common.PublicKey,
	mint common.PublicKey,
	tokenAccount common.PublicKey,
	masterEditionAccount common.PublicKey,
	splTokenProgram common.PublicKey,
	collectionMetadata common.PublicKey,
) *BurnNft {
	return NewBurnNftInstructionBuilder().
		SetMetadataAccount(metadata).
		SetOwnerAccount(owner).
		SetMintAccount(mint).
		SetTokenAccountAccount(tokenAccount).
		SetMasterEditionAccountAccount(masterEditionAccount).
		SetSplTokenProgramAccount(splTokenProgram).
		SetCollectionMetadataAccount(collectionMetadata)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata (pda of ['metadata', program id, mint id])
func (obj *BurnNft) SetMetadataAccount(metadata common.PublicKey) *BurnNft {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata (pda of ['metadata', program id, mint id])
func (obj *BurnNft) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetOwnerAccount sets the "owner" parameter.
// NFT owner
func (obj *BurnNft) SetOwnerAccount(owner common.PublicKey) *BurnNft {
	obj.AccountMetaSlice[1] = common.Meta(owner).WRITE().SIGNER()
	return obj
}

// GetOwnerAccount gets the "owner" parameter.
// NFT owner
func (obj *BurnNft) GetOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMintAccount sets the "mint" parameter.
// Mint of the NFT
func (obj *BurnNft) SetMintAccount(mint common.PublicKey) *BurnNft {
	obj.AccountMetaSlice[2] = common.Meta(mint).WRITE()
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of the NFT
func (obj *BurnNft) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetTokenAccountAccount sets the "tokenAccount" parameter.
// Token account to close
func (obj *BurnNft) SetTokenAccountAccount(tokenAccount common.PublicKey) *BurnNft {
	obj.AccountMetaSlice[3] = common.Meta(tokenAccount).WRITE()
	return obj
}

// GetTokenAccountAccount gets the "tokenAccount" parameter.
// Token account to close
func (obj *BurnNft) GetTokenAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetMasterEditionAccountAccount sets the "masterEditionAccount" parameter.
// MasterEdition2 of the NFT
func (obj *BurnNft) SetMasterEditionAccountAccount(masterEditionAccount common.PublicKey) *BurnNft {
	obj.AccountMetaSlice[4] = common.Meta(masterEditionAccount).WRITE()
	return obj
}

// GetMasterEditionAccountAccount gets the "masterEditionAccount" parameter.
// MasterEdition2 of the NFT
func (obj *BurnNft) GetMasterEditionAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *BurnNft) SetSplTokenProgramAccount(splTokenProgram common.PublicKey) *BurnNft {
	obj.AccountMetaSlice[5] = common.Meta(splTokenProgram)
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *BurnNft) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetCollectionMetadataAccount sets the "collectionMetadata" parameter.
// Metadata of the Collection
func (obj *BurnNft) SetCollectionMetadataAccount(collectionMetadata common.PublicKey, multiSigners ...common.PublicKey) *BurnNft {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[6] = common.Meta(collectionMetadata)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[6] = common.Meta(collectionMetadata).WRITE()
	}
	return obj
}

// GetCollectionMetadataAccount gets the "collectionMetadata" parameter.
// Metadata of the Collection
func (obj *BurnNft) GetCollectionMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

func (obj *BurnNft) SetProgramId(programId *common.PublicKey) *BurnNft {
	obj._programId = programId
	return obj
}

func (obj *BurnNft) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_BurnNft}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *BurnNft) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[BurnNft] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[BurnNft] accounts.owner is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[BurnNft] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[BurnNft] accounts.tokenAccount is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[BurnNft] accounts.masterEditionAccount is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[BurnNft] accounts.splTokenProgram is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[BurnNft] accounts.collectionMetadata is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *BurnNft) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *BurnNft) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *BurnNft) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *BurnNft) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("BurnNft")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=7]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("            metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("               owner", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                mint", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("        tokenAccount", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("masterEditionAccount", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("     splTokenProgram", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("  collectionMetadata", obj.AccountMetaSlice.Get(6)))
					})
				})
		})
}

// VerifySizedCollectionItem Instruction
type VerifySizedCollectionItem struct {
	// [0] = [WRITE] metadata `Metadata account`
	// [1] = [SIGNER] collectionAuthority `Collection Update authority`
	// [2] = [WRITE, SIGNER] payer `payer`
	// [3] = [] collectionMint `Mint of the Collection`
	// [4] = [WRITE] collection `Metadata Account of the Collection`
	// [5] = [] collectionMasterEditionAccount `MasterEdition2 Account of the Collection Token`
	// [6] = [] collectionAuthorityRecord `Collection Authority Record PDA`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewVerifySizedCollectionItemInstructionBuilder creates a new `VerifySizedCollectionItem` instruction builder.
func NewVerifySizedCollectionItemInstructionBuilder() *VerifySizedCollectionItem {
	return &VerifySizedCollectionItem{
		AccountMetaSlice: make(common.AccountMetaSlice, 7),
	}
}

// NewVerifySizedCollectionItemInstruction
//
// Parameters:
//
//	metadata: Metadata account
//	collectionAuthority: Collection Update authority
//	payer: payer
//	collectionMint: Mint of the Collection
//	collection: Metadata Account of the Collection
//	collectionMasterEditionAccount: MasterEdition2 Account of the Collection Token
//	collectionAuthorityRecord: Collection Authority Record PDA
func NewVerifySizedCollectionItemInstruction(
	metadata common.PublicKey,
	collectionAuthority common.PublicKey,
	payer common.PublicKey,
	collectionMint common.PublicKey,
	collection common.PublicKey,
	collectionMasterEditionAccount common.PublicKey,
	collectionAuthorityRecord common.PublicKey,
) *VerifySizedCollectionItem {
	return NewVerifySizedCollectionItemInstructionBuilder().
		SetMetadataAccount(metadata).
		SetCollectionAuthorityAccount(collectionAuthority).
		SetPayerAccount(payer).
		SetCollectionMintAccount(collectionMint).
		SetCollectionAccount(collection).
		SetCollectionMasterEditionAccountAccount(collectionMasterEditionAccount).
		SetCollectionAuthorityRecordAccount(collectionAuthorityRecord)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *VerifySizedCollectionItem) SetMetadataAccount(metadata common.PublicKey) *VerifySizedCollectionItem {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *VerifySizedCollectionItem) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetCollectionAuthorityAccount sets the "collectionAuthority" parameter.
// Collection Update authority
func (obj *VerifySizedCollectionItem) SetCollectionAuthorityAccount(collectionAuthority common.PublicKey) *VerifySizedCollectionItem {
	obj.AccountMetaSlice[1] = common.Meta(collectionAuthority).SIGNER()
	return obj
}

// GetCollectionAuthorityAccount gets the "collectionAuthority" parameter.
// Collection Update authority
func (obj *VerifySizedCollectionItem) GetCollectionAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetPayerAccount sets the "payer" parameter.
// payer
func (obj *VerifySizedCollectionItem) SetPayerAccount(payer common.PublicKey) *VerifySizedCollectionItem {
	obj.AccountMetaSlice[2] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// payer
func (obj *VerifySizedCollectionItem) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetCollectionMintAccount sets the "collectionMint" parameter.
// Mint of the Collection
func (obj *VerifySizedCollectionItem) SetCollectionMintAccount(collectionMint common.PublicKey) *VerifySizedCollectionItem {
	obj.AccountMetaSlice[3] = common.Meta(collectionMint)
	return obj
}

// GetCollectionMintAccount gets the "collectionMint" parameter.
// Mint of the Collection
func (obj *VerifySizedCollectionItem) GetCollectionMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetCollectionAccount sets the "collection" parameter.
// Metadata Account of the Collection
func (obj *VerifySizedCollectionItem) SetCollectionAccount(collection common.PublicKey) *VerifySizedCollectionItem {
	obj.AccountMetaSlice[4] = common.Meta(collection).WRITE()
	return obj
}

// GetCollectionAccount gets the "collection" parameter.
// Metadata Account of the Collection
func (obj *VerifySizedCollectionItem) GetCollectionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetCollectionMasterEditionAccountAccount sets the "collectionMasterEditionAccount" parameter.
// MasterEdition2 Account of the Collection Token
func (obj *VerifySizedCollectionItem) SetCollectionMasterEditionAccountAccount(collectionMasterEditionAccount common.PublicKey) *VerifySizedCollectionItem {
	obj.AccountMetaSlice[5] = common.Meta(collectionMasterEditionAccount)
	return obj
}

// GetCollectionMasterEditionAccountAccount gets the "collectionMasterEditionAccount" parameter.
// MasterEdition2 Account of the Collection Token
func (obj *VerifySizedCollectionItem) GetCollectionMasterEditionAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetCollectionAuthorityRecordAccount sets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *VerifySizedCollectionItem) SetCollectionAuthorityRecordAccount(collectionAuthorityRecord common.PublicKey, multiSigners ...common.PublicKey) *VerifySizedCollectionItem {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[6] = common.Meta(collectionAuthorityRecord)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[6] = common.Meta(collectionAuthorityRecord)
	}
	return obj
}

// GetCollectionAuthorityRecordAccount gets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *VerifySizedCollectionItem) GetCollectionAuthorityRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

func (obj *VerifySizedCollectionItem) SetProgramId(programId *common.PublicKey) *VerifySizedCollectionItem {
	obj._programId = programId
	return obj
}

func (obj *VerifySizedCollectionItem) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_VerifySizedCollectionItem}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *VerifySizedCollectionItem) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[VerifySizedCollectionItem] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[VerifySizedCollectionItem] accounts.collectionAuthority is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[VerifySizedCollectionItem] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[VerifySizedCollectionItem] accounts.collectionMint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[VerifySizedCollectionItem] accounts.collection is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[VerifySizedCollectionItem] accounts.collectionMasterEditionAccount is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[VerifySizedCollectionItem] accounts.collectionAuthorityRecord is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *VerifySizedCollectionItem) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *VerifySizedCollectionItem) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *VerifySizedCollectionItem) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *VerifySizedCollectionItem) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("VerifySizedCollectionItem")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=7]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                      metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("           collectionAuthority", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                         payer", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("                collectionMint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                    collection", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("collectionMasterEditionAccount", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("     collectionAuthorityRecord", obj.AccountMetaSlice.Get(6)))
					})
				})
		})
}

// UnverifySizedCollectionItem Instruction
type UnverifySizedCollectionItem struct {
	// [0] = [WRITE] metadata `Metadata account`
	// [1] = [SIGNER] collectionAuthority `Collection Authority`
	// [2] = [WRITE, SIGNER] payer `payer`
	// [3] = [] collectionMint `Mint of the Collection`
	// [4] = [WRITE] collection `Metadata Account of the Collection`
	// [5] = [] collectionMasterEditionAccount `MasterEdition2 Account of the Collection Token`
	// [6] = [] collectionAuthorityRecord `Collection Authority Record PDA`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewUnverifySizedCollectionItemInstructionBuilder creates a new `UnverifySizedCollectionItem` instruction builder.
func NewUnverifySizedCollectionItemInstructionBuilder() *UnverifySizedCollectionItem {
	return &UnverifySizedCollectionItem{
		AccountMetaSlice: make(common.AccountMetaSlice, 7),
	}
}

// NewUnverifySizedCollectionItemInstruction
//
// Parameters:
//
//	metadata: Metadata account
//	collectionAuthority: Collection Authority
//	payer: payer
//	collectionMint: Mint of the Collection
//	collection: Metadata Account of the Collection
//	collectionMasterEditionAccount: MasterEdition2 Account of the Collection Token
//	collectionAuthorityRecord: Collection Authority Record PDA
func NewUnverifySizedCollectionItemInstruction(
	metadata common.PublicKey,
	collectionAuthority common.PublicKey,
	payer common.PublicKey,
	collectionMint common.PublicKey,
	collection common.PublicKey,
	collectionMasterEditionAccount common.PublicKey,
	collectionAuthorityRecord common.PublicKey,
) *UnverifySizedCollectionItem {
	return NewUnverifySizedCollectionItemInstructionBuilder().
		SetMetadataAccount(metadata).
		SetCollectionAuthorityAccount(collectionAuthority).
		SetPayerAccount(payer).
		SetCollectionMintAccount(collectionMint).
		SetCollectionAccount(collection).
		SetCollectionMasterEditionAccountAccount(collectionMasterEditionAccount).
		SetCollectionAuthorityRecordAccount(collectionAuthorityRecord)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *UnverifySizedCollectionItem) SetMetadataAccount(metadata common.PublicKey) *UnverifySizedCollectionItem {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *UnverifySizedCollectionItem) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetCollectionAuthorityAccount sets the "collectionAuthority" parameter.
// Collection Authority
func (obj *UnverifySizedCollectionItem) SetCollectionAuthorityAccount(collectionAuthority common.PublicKey) *UnverifySizedCollectionItem {
	obj.AccountMetaSlice[1] = common.Meta(collectionAuthority).SIGNER()
	return obj
}

// GetCollectionAuthorityAccount gets the "collectionAuthority" parameter.
// Collection Authority
func (obj *UnverifySizedCollectionItem) GetCollectionAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetPayerAccount sets the "payer" parameter.
// payer
func (obj *UnverifySizedCollectionItem) SetPayerAccount(payer common.PublicKey) *UnverifySizedCollectionItem {
	obj.AccountMetaSlice[2] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// payer
func (obj *UnverifySizedCollectionItem) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetCollectionMintAccount sets the "collectionMint" parameter.
// Mint of the Collection
func (obj *UnverifySizedCollectionItem) SetCollectionMintAccount(collectionMint common.PublicKey) *UnverifySizedCollectionItem {
	obj.AccountMetaSlice[3] = common.Meta(collectionMint)
	return obj
}

// GetCollectionMintAccount gets the "collectionMint" parameter.
// Mint of the Collection
func (obj *UnverifySizedCollectionItem) GetCollectionMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetCollectionAccount sets the "collection" parameter.
// Metadata Account of the Collection
func (obj *UnverifySizedCollectionItem) SetCollectionAccount(collection common.PublicKey) *UnverifySizedCollectionItem {
	obj.AccountMetaSlice[4] = common.Meta(collection).WRITE()
	return obj
}

// GetCollectionAccount gets the "collection" parameter.
// Metadata Account of the Collection
func (obj *UnverifySizedCollectionItem) GetCollectionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetCollectionMasterEditionAccountAccount sets the "collectionMasterEditionAccount" parameter.
// MasterEdition2 Account of the Collection Token
func (obj *UnverifySizedCollectionItem) SetCollectionMasterEditionAccountAccount(collectionMasterEditionAccount common.PublicKey) *UnverifySizedCollectionItem {
	obj.AccountMetaSlice[5] = common.Meta(collectionMasterEditionAccount)
	return obj
}

// GetCollectionMasterEditionAccountAccount gets the "collectionMasterEditionAccount" parameter.
// MasterEdition2 Account of the Collection Token
func (obj *UnverifySizedCollectionItem) GetCollectionMasterEditionAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetCollectionAuthorityRecordAccount sets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *UnverifySizedCollectionItem) SetCollectionAuthorityRecordAccount(collectionAuthorityRecord common.PublicKey, multiSigners ...common.PublicKey) *UnverifySizedCollectionItem {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[6] = common.Meta(collectionAuthorityRecord)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[6] = common.Meta(collectionAuthorityRecord)
	}
	return obj
}

// GetCollectionAuthorityRecordAccount gets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *UnverifySizedCollectionItem) GetCollectionAuthorityRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

func (obj *UnverifySizedCollectionItem) SetProgramId(programId *common.PublicKey) *UnverifySizedCollectionItem {
	obj._programId = programId
	return obj
}

func (obj *UnverifySizedCollectionItem) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_UnverifySizedCollectionItem}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *UnverifySizedCollectionItem) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[UnverifySizedCollectionItem] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[UnverifySizedCollectionItem] accounts.collectionAuthority is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[UnverifySizedCollectionItem] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[UnverifySizedCollectionItem] accounts.collectionMint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[UnverifySizedCollectionItem] accounts.collection is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[UnverifySizedCollectionItem] accounts.collectionMasterEditionAccount is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[UnverifySizedCollectionItem] accounts.collectionAuthorityRecord is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *UnverifySizedCollectionItem) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *UnverifySizedCollectionItem) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *UnverifySizedCollectionItem) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *UnverifySizedCollectionItem) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("UnverifySizedCollectionItem")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=7]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                      metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("           collectionAuthority", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                         payer", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("                collectionMint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                    collection", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("collectionMasterEditionAccount", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("     collectionAuthorityRecord", obj.AccountMetaSlice.Get(6)))
					})
				})
		})
}

// SetAndVerifySizedCollectionItem Instruction
type SetAndVerifySizedCollectionItem struct {
	// [0] = [WRITE] metadata `Metadata account`
	// [1] = [SIGNER] collectionAuthority `Collection Update authority`
	// [2] = [WRITE, SIGNER] payer `payer`
	// [3] = [] updateAuthority `Update Authority of Collection NFT and NFT`
	// [4] = [] collectionMint `Mint of the Collection`
	// [5] = [WRITE] collection `Metadata Account of the Collection`
	// [6] = [] collectionMasterEditionAccount `MasterEdition2 Account of the Collection Token`
	// [7] = [] collectionAuthorityRecord `Collection Authority Record PDA`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewSetAndVerifySizedCollectionItemInstructionBuilder creates a new `SetAndVerifySizedCollectionItem` instruction builder.
func NewSetAndVerifySizedCollectionItemInstructionBuilder() *SetAndVerifySizedCollectionItem {
	return &SetAndVerifySizedCollectionItem{
		AccountMetaSlice: make(common.AccountMetaSlice, 8),
	}
}

// NewSetAndVerifySizedCollectionItemInstruction
//
// Parameters:
//
//	metadata: Metadata account
//	collectionAuthority: Collection Update authority
//	payer: payer
//	updateAuthority: Update Authority of Collection NFT and NFT
//	collectionMint: Mint of the Collection
//	collection: Metadata Account of the Collection
//	collectionMasterEditionAccount: MasterEdition2 Account of the Collection Token
//	collectionAuthorityRecord: Collection Authority Record PDA
func NewSetAndVerifySizedCollectionItemInstruction(
	metadata common.PublicKey,
	collectionAuthority common.PublicKey,
	payer common.PublicKey,
	updateAuthority common.PublicKey,
	collectionMint common.PublicKey,
	collection common.PublicKey,
	collectionMasterEditionAccount common.PublicKey,
	collectionAuthorityRecord common.PublicKey,
) *SetAndVerifySizedCollectionItem {
	return NewSetAndVerifySizedCollectionItemInstructionBuilder().
		SetMetadataAccount(metadata).
		SetCollectionAuthorityAccount(collectionAuthority).
		SetPayerAccount(payer).
		SetUpdateAuthorityAccount(updateAuthority).
		SetCollectionMintAccount(collectionMint).
		SetCollectionAccount(collection).
		SetCollectionMasterEditionAccountAccount(collectionMasterEditionAccount).
		SetCollectionAuthorityRecordAccount(collectionAuthorityRecord)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *SetAndVerifySizedCollectionItem) SetMetadataAccount(metadata common.PublicKey) *SetAndVerifySizedCollectionItem {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *SetAndVerifySizedCollectionItem) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetCollectionAuthorityAccount sets the "collectionAuthority" parameter.
// Collection Update authority
func (obj *SetAndVerifySizedCollectionItem) SetCollectionAuthorityAccount(collectionAuthority common.PublicKey) *SetAndVerifySizedCollectionItem {
	obj.AccountMetaSlice[1] = common.Meta(collectionAuthority).SIGNER()
	return obj
}

// GetCollectionAuthorityAccount gets the "collectionAuthority" parameter.
// Collection Update authority
func (obj *SetAndVerifySizedCollectionItem) GetCollectionAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetPayerAccount sets the "payer" parameter.
// payer
func (obj *SetAndVerifySizedCollectionItem) SetPayerAccount(payer common.PublicKey) *SetAndVerifySizedCollectionItem {
	obj.AccountMetaSlice[2] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// payer
func (obj *SetAndVerifySizedCollectionItem) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// Update Authority of Collection NFT and NFT
func (obj *SetAndVerifySizedCollectionItem) SetUpdateAuthorityAccount(updateAuthority common.PublicKey) *SetAndVerifySizedCollectionItem {
	obj.AccountMetaSlice[3] = common.Meta(updateAuthority)
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// Update Authority of Collection NFT and NFT
func (obj *SetAndVerifySizedCollectionItem) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetCollectionMintAccount sets the "collectionMint" parameter.
// Mint of the Collection
func (obj *SetAndVerifySizedCollectionItem) SetCollectionMintAccount(collectionMint common.PublicKey) *SetAndVerifySizedCollectionItem {
	obj.AccountMetaSlice[4] = common.Meta(collectionMint)
	return obj
}

// GetCollectionMintAccount gets the "collectionMint" parameter.
// Mint of the Collection
func (obj *SetAndVerifySizedCollectionItem) GetCollectionMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetCollectionAccount sets the "collection" parameter.
// Metadata Account of the Collection
func (obj *SetAndVerifySizedCollectionItem) SetCollectionAccount(collection common.PublicKey) *SetAndVerifySizedCollectionItem {
	obj.AccountMetaSlice[5] = common.Meta(collection).WRITE()
	return obj
}

// GetCollectionAccount gets the "collection" parameter.
// Metadata Account of the Collection
func (obj *SetAndVerifySizedCollectionItem) GetCollectionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetCollectionMasterEditionAccountAccount sets the "collectionMasterEditionAccount" parameter.
// MasterEdition2 Account of the Collection Token
func (obj *SetAndVerifySizedCollectionItem) SetCollectionMasterEditionAccountAccount(collectionMasterEditionAccount common.PublicKey) *SetAndVerifySizedCollectionItem {
	obj.AccountMetaSlice[6] = common.Meta(collectionMasterEditionAccount)
	return obj
}

// GetCollectionMasterEditionAccountAccount gets the "collectionMasterEditionAccount" parameter.
// MasterEdition2 Account of the Collection Token
func (obj *SetAndVerifySizedCollectionItem) GetCollectionMasterEditionAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetCollectionAuthorityRecordAccount sets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *SetAndVerifySizedCollectionItem) SetCollectionAuthorityRecordAccount(collectionAuthorityRecord common.PublicKey, multiSigners ...common.PublicKey) *SetAndVerifySizedCollectionItem {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[7] = common.Meta(collectionAuthorityRecord)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[7] = common.Meta(collectionAuthorityRecord)
	}
	return obj
}

// GetCollectionAuthorityRecordAccount gets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *SetAndVerifySizedCollectionItem) GetCollectionAuthorityRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

func (obj *SetAndVerifySizedCollectionItem) SetProgramId(programId *common.PublicKey) *SetAndVerifySizedCollectionItem {
	obj._programId = programId
	return obj
}

func (obj *SetAndVerifySizedCollectionItem) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_SetAndVerifySizedCollectionItem}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *SetAndVerifySizedCollectionItem) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[SetAndVerifySizedCollectionItem] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[SetAndVerifySizedCollectionItem] accounts.collectionAuthority is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[SetAndVerifySizedCollectionItem] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[SetAndVerifySizedCollectionItem] accounts.updateAuthority is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[SetAndVerifySizedCollectionItem] accounts.collectionMint is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[SetAndVerifySizedCollectionItem] accounts.collection is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[SetAndVerifySizedCollectionItem] accounts.collectionMasterEditionAccount is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[SetAndVerifySizedCollectionItem] accounts.collectionAuthorityRecord is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *SetAndVerifySizedCollectionItem) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *SetAndVerifySizedCollectionItem) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *SetAndVerifySizedCollectionItem) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *SetAndVerifySizedCollectionItem) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("SetAndVerifySizedCollectionItem")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=8]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                      metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("           collectionAuthority", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                         payer", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("               updateAuthority", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                collectionMint", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                    collection", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("collectionMasterEditionAccount", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("     collectionAuthorityRecord", obj.AccountMetaSlice.Get(7)))
					})
				})
		})
}

// CreateMetadataAccountV3 Instruction
type CreateMetadataAccountV3 struct {
	CreateMetadataAccountArgsV3 *CreateMetadataAccountArgsV3
	// [0] = [WRITE] metadata `Metadata key (pda of ['metadata', program id, mint id])`
	// [1] = [] mint `Mint of token asset`
	// [2] = [SIGNER] mintAuthority `Mint authority`
	// [3] = [WRITE, SIGNER] payer `payer`
	// [4] = [] updateAuthority `update authority info`
	// [5] = [] systemProgram `System program`
	// [6] = [] rent `Rent info`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewCreateMetadataAccountV3InstructionBuilder creates a new `CreateMetadataAccountV3` instruction builder.
func NewCreateMetadataAccountV3InstructionBuilder() *CreateMetadataAccountV3 {
	return &CreateMetadataAccountV3{
		AccountMetaSlice: make(common.AccountMetaSlice, 7),
	}
}

// NewCreateMetadataAccountV3Instruction
//
// Parameters:
//
//	createMetadataAccountArgsV3:
//	metadata: Metadata key (pda of ['metadata', program id, mint id])
//	mint: Mint of token asset
//	mintAuthority: Mint authority
//	payer: payer
//	updateAuthority: update authority info
//	systemProgram: System program
//	rent: Rent info
func NewCreateMetadataAccountV3Instruction(
	createMetadataAccountArgsV3 CreateMetadataAccountArgsV3,
	metadata common.PublicKey,
	mint common.PublicKey,
	mintAuthority common.PublicKey,
	payer common.PublicKey,
	updateAuthority common.PublicKey,
	systemProgram common.PublicKey,
	rent common.PublicKey,
) *CreateMetadataAccountV3 {
	return NewCreateMetadataAccountV3InstructionBuilder().
		SetCreateMetadataAccountArgsV3(createMetadataAccountArgsV3).
		SetMetadataAccount(metadata).
		SetMintAccount(mint).
		SetMintAuthorityAccount(mintAuthority).
		SetPayerAccount(payer).
		SetUpdateAuthorityAccount(updateAuthority).
		SetSystemProgramAccount(systemProgram).
		SetRentAccount(rent)
}

// SetCreateMetadataAccountArgsV3 sets the "createMetadataAccountArgsV3" parameter.
func (obj *CreateMetadataAccountV3) SetCreateMetadataAccountArgsV3(createMetadataAccountArgsV3 CreateMetadataAccountArgsV3) *CreateMetadataAccountV3 {
	obj.CreateMetadataAccountArgsV3 = &createMetadataAccountArgsV3
	return obj
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata key (pda of ['metadata', program id, mint id])
func (obj *CreateMetadataAccountV3) SetMetadataAccount(metadata common.PublicKey) *CreateMetadataAccountV3 {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata key (pda of ['metadata', program id, mint id])
func (obj *CreateMetadataAccountV3) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMintAccount sets the "mint" parameter.
// Mint of token asset
func (obj *CreateMetadataAccountV3) SetMintAccount(mint common.PublicKey) *CreateMetadataAccountV3 {
	obj.AccountMetaSlice[1] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of token asset
func (obj *CreateMetadataAccountV3) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMintAuthorityAccount sets the "mintAuthority" parameter.
// Mint authority
func (obj *CreateMetadataAccountV3) SetMintAuthorityAccount(mintAuthority common.PublicKey) *CreateMetadataAccountV3 {
	obj.AccountMetaSlice[2] = common.Meta(mintAuthority).SIGNER()
	return obj
}

// GetMintAuthorityAccount gets the "mintAuthority" parameter.
// Mint authority
func (obj *CreateMetadataAccountV3) GetMintAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetPayerAccount sets the "payer" parameter.
// payer
func (obj *CreateMetadataAccountV3) SetPayerAccount(payer common.PublicKey) *CreateMetadataAccountV3 {
	obj.AccountMetaSlice[3] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// payer
func (obj *CreateMetadataAccountV3) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// update authority info
func (obj *CreateMetadataAccountV3) SetUpdateAuthorityAccount(updateAuthority common.PublicKey) *CreateMetadataAccountV3 {
	obj.AccountMetaSlice[4] = common.Meta(updateAuthority)
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// update authority info
func (obj *CreateMetadataAccountV3) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *CreateMetadataAccountV3) SetSystemProgramAccount(systemProgram common.PublicKey) *CreateMetadataAccountV3 {
	obj.AccountMetaSlice[5] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *CreateMetadataAccountV3) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetRentAccount sets the "rent" parameter.
// Rent info
func (obj *CreateMetadataAccountV3) SetRentAccount(rent common.PublicKey, multiSigners ...common.PublicKey) *CreateMetadataAccountV3 {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[6] = common.Meta(rent)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[6] = common.Meta(rent)
	}
	return obj
}

// GetRentAccount gets the "rent" parameter.
// Rent info
func (obj *CreateMetadataAccountV3) GetRentAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

func (obj *CreateMetadataAccountV3) SetProgramId(programId *common.PublicKey) *CreateMetadataAccountV3 {
	obj._programId = programId
	return obj
}

func (obj *CreateMetadataAccountV3) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_CreateMetadataAccountV3}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *CreateMetadataAccountV3) Validate() error {
	if obj.CreateMetadataAccountArgsV3 == nil {
		return errors.New("[CreateMetadataAccountV3] createMetadataAccountArgsV3 param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[CreateMetadataAccountV3] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[CreateMetadataAccountV3] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[CreateMetadataAccountV3] accounts.mintAuthority is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[CreateMetadataAccountV3] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[CreateMetadataAccountV3] accounts.updateAuthority is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[CreateMetadataAccountV3] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[CreateMetadataAccountV3] accounts.rent is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *CreateMetadataAccountV3) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *CreateMetadataAccountV3) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.CreateMetadataAccountArgsV3); err != nil {
		return err
	}
	return nil
}

func (obj *CreateMetadataAccountV3) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.CreateMetadataAccountArgsV3); err != nil {
		return err
	}
	return nil
}

func (obj *CreateMetadataAccountV3) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("CreateMetadataAccountV3")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("CreateMetadataAccountArgsV3", *obj.CreateMetadataAccountArgsV3))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=7]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("       metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("           mint", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("  mintAuthority", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("          payer", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("updateAuthority", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("  systemProgram", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("           rent", obj.AccountMetaSlice.Get(6)))
					})
				})
		})
}

// SetCollectionSize Instruction
type SetCollectionSize struct {
	SetCollectionSizeArgs *SetCollectionSizeArgs
	// [0] = [WRITE] collectionMetadata `Collection Metadata account`
	// [1] = [WRITE, SIGNER] collectionAuthority `Collection Update authority`
	// [2] = [] collectionMint `Mint of the Collection`
	// [3] = [] collectionAuthorityRecord `Collection Authority Record PDA`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewSetCollectionSizeInstructionBuilder creates a new `SetCollectionSize` instruction builder.
func NewSetCollectionSizeInstructionBuilder() *SetCollectionSize {
	return &SetCollectionSize{
		AccountMetaSlice: make(common.AccountMetaSlice, 4),
	}
}

// NewSetCollectionSizeInstruction
//
// Parameters:
//
//	setCollectionSizeArgs:
//	collectionMetadata: Collection Metadata account
//	collectionAuthority: Collection Update authority
//	collectionMint: Mint of the Collection
//	collectionAuthorityRecord: Collection Authority Record PDA
func NewSetCollectionSizeInstruction(
	setCollectionSizeArgs SetCollectionSizeArgs,
	collectionMetadata common.PublicKey,
	collectionAuthority common.PublicKey,
	collectionMint common.PublicKey,
	collectionAuthorityRecord common.PublicKey,
) *SetCollectionSize {
	return NewSetCollectionSizeInstructionBuilder().
		SetSetCollectionSizeArgs(setCollectionSizeArgs).
		SetCollectionMetadataAccount(collectionMetadata).
		SetCollectionAuthorityAccount(collectionAuthority).
		SetCollectionMintAccount(collectionMint).
		SetCollectionAuthorityRecordAccount(collectionAuthorityRecord)
}

// SetSetCollectionSizeArgs sets the "setCollectionSizeArgs" parameter.
func (obj *SetCollectionSize) SetSetCollectionSizeArgs(setCollectionSizeArgs SetCollectionSizeArgs) *SetCollectionSize {
	obj.SetCollectionSizeArgs = &setCollectionSizeArgs
	return obj
}

// SetCollectionMetadataAccount sets the "collectionMetadata" parameter.
// Collection Metadata account
func (obj *SetCollectionSize) SetCollectionMetadataAccount(collectionMetadata common.PublicKey) *SetCollectionSize {
	obj.AccountMetaSlice[0] = common.Meta(collectionMetadata).WRITE()
	return obj
}

// GetCollectionMetadataAccount gets the "collectionMetadata" parameter.
// Collection Metadata account
func (obj *SetCollectionSize) GetCollectionMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetCollectionAuthorityAccount sets the "collectionAuthority" parameter.
// Collection Update authority
func (obj *SetCollectionSize) SetCollectionAuthorityAccount(collectionAuthority common.PublicKey) *SetCollectionSize {
	obj.AccountMetaSlice[1] = common.Meta(collectionAuthority).WRITE().SIGNER()
	return obj
}

// GetCollectionAuthorityAccount gets the "collectionAuthority" parameter.
// Collection Update authority
func (obj *SetCollectionSize) GetCollectionAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetCollectionMintAccount sets the "collectionMint" parameter.
// Mint of the Collection
func (obj *SetCollectionSize) SetCollectionMintAccount(collectionMint common.PublicKey) *SetCollectionSize {
	obj.AccountMetaSlice[2] = common.Meta(collectionMint)
	return obj
}

// GetCollectionMintAccount gets the "collectionMint" parameter.
// Mint of the Collection
func (obj *SetCollectionSize) GetCollectionMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetCollectionAuthorityRecordAccount sets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *SetCollectionSize) SetCollectionAuthorityRecordAccount(collectionAuthorityRecord common.PublicKey, multiSigners ...common.PublicKey) *SetCollectionSize {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[3] = common.Meta(collectionAuthorityRecord)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[3] = common.Meta(collectionAuthorityRecord)
	}
	return obj
}

// GetCollectionAuthorityRecordAccount gets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *SetCollectionSize) GetCollectionAuthorityRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

func (obj *SetCollectionSize) SetProgramId(programId *common.PublicKey) *SetCollectionSize {
	obj._programId = programId
	return obj
}

func (obj *SetCollectionSize) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_SetCollectionSize}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *SetCollectionSize) Validate() error {
	if obj.SetCollectionSizeArgs == nil {
		return errors.New("[SetCollectionSize] setCollectionSizeArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[SetCollectionSize] accounts.collectionMetadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[SetCollectionSize] accounts.collectionAuthority is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[SetCollectionSize] accounts.collectionMint is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[SetCollectionSize] accounts.collectionAuthorityRecord is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *SetCollectionSize) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *SetCollectionSize) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.SetCollectionSizeArgs); err != nil {
		return err
	}
	return nil
}

func (obj *SetCollectionSize) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.SetCollectionSizeArgs); err != nil {
		return err
	}
	return nil
}

func (obj *SetCollectionSize) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("SetCollectionSize")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("SetCollectionSizeArgs", *obj.SetCollectionSizeArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=4]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("       collectionMetadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("      collectionAuthority", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("           collectionMint", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("collectionAuthorityRecord", obj.AccountMetaSlice.Get(3)))
					})
				})
		})
}

// SetTokenStandard Instruction
type SetTokenStandard struct {
	// [0] = [WRITE] metadata `Metadata account`
	// [1] = [SIGNER] updateAuthority `Metadata update authority`
	// [2] = [] mint `Mint account`
	// [3] = [] edition `Edition account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewSetTokenStandardInstructionBuilder creates a new `SetTokenStandard` instruction builder.
func NewSetTokenStandardInstructionBuilder() *SetTokenStandard {
	return &SetTokenStandard{
		AccountMetaSlice: make(common.AccountMetaSlice, 4),
	}
}

// NewSetTokenStandardInstruction
//
// Parameters:
//
//	metadata: Metadata account
//	updateAuthority: Metadata update authority
//	mint: Mint account
//	edition: Edition account
func NewSetTokenStandardInstruction(
	metadata common.PublicKey,
	updateAuthority common.PublicKey,
	mint common.PublicKey,
	edition common.PublicKey,
) *SetTokenStandard {
	return NewSetTokenStandardInstructionBuilder().
		SetMetadataAccount(metadata).
		SetUpdateAuthorityAccount(updateAuthority).
		SetMintAccount(mint).
		SetEditionAccount(edition)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *SetTokenStandard) SetMetadataAccount(metadata common.PublicKey) *SetTokenStandard {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *SetTokenStandard) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// Metadata update authority
func (obj *SetTokenStandard) SetUpdateAuthorityAccount(updateAuthority common.PublicKey) *SetTokenStandard {
	obj.AccountMetaSlice[1] = common.Meta(updateAuthority).SIGNER()
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// Metadata update authority
func (obj *SetTokenStandard) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMintAccount sets the "mint" parameter.
// Mint account
func (obj *SetTokenStandard) SetMintAccount(mint common.PublicKey) *SetTokenStandard {
	obj.AccountMetaSlice[2] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint account
func (obj *SetTokenStandard) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetEditionAccount sets the "edition" parameter.
// Edition account
func (obj *SetTokenStandard) SetEditionAccount(edition common.PublicKey, multiSigners ...common.PublicKey) *SetTokenStandard {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[3] = common.Meta(edition)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[3] = common.Meta(edition)
	}
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Edition account
func (obj *SetTokenStandard) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

func (obj *SetTokenStandard) SetProgramId(programId *common.PublicKey) *SetTokenStandard {
	obj._programId = programId
	return obj
}

func (obj *SetTokenStandard) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_SetTokenStandard}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *SetTokenStandard) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[SetTokenStandard] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[SetTokenStandard] accounts.updateAuthority is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[SetTokenStandard] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[SetTokenStandard] accounts.edition is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *SetTokenStandard) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *SetTokenStandard) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *SetTokenStandard) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *SetTokenStandard) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("SetTokenStandard")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=4]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("       metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("updateAuthority", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("           mint", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("        edition", obj.AccountMetaSlice.Get(3)))
					})
				})
		})
}

// BubblegumSetCollectionSize Instruction
type BubblegumSetCollectionSize struct {
	SetCollectionSizeArgs *SetCollectionSizeArgs
	// [0] = [WRITE] collectionMetadata `Collection Metadata account`
	// [1] = [SIGNER] collectionAuthority `Collection Update authority`
	// [2] = [] collectionMint `Mint of the Collection`
	// [3] = [SIGNER] bubblegumSigner `Signing PDA of Bubblegum program`
	// [4] = [] collectionAuthorityRecord `Collection Authority Record PDA`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewBubblegumSetCollectionSizeInstructionBuilder creates a new `BubblegumSetCollectionSize` instruction builder.
func NewBubblegumSetCollectionSizeInstructionBuilder() *BubblegumSetCollectionSize {
	return &BubblegumSetCollectionSize{
		AccountMetaSlice: make(common.AccountMetaSlice, 5),
	}
}

// NewBubblegumSetCollectionSizeInstruction
//
// Parameters:
//
//	setCollectionSizeArgs:
//	collectionMetadata: Collection Metadata account
//	collectionAuthority: Collection Update authority
//	collectionMint: Mint of the Collection
//	bubblegumSigner: Signing PDA of Bubblegum program
//	collectionAuthorityRecord: Collection Authority Record PDA
func NewBubblegumSetCollectionSizeInstruction(
	setCollectionSizeArgs SetCollectionSizeArgs,
	collectionMetadata common.PublicKey,
	collectionAuthority common.PublicKey,
	collectionMint common.PublicKey,
	bubblegumSigner common.PublicKey,
	collectionAuthorityRecord common.PublicKey,
) *BubblegumSetCollectionSize {
	return NewBubblegumSetCollectionSizeInstructionBuilder().
		SetSetCollectionSizeArgs(setCollectionSizeArgs).
		SetCollectionMetadataAccount(collectionMetadata).
		SetCollectionAuthorityAccount(collectionAuthority).
		SetCollectionMintAccount(collectionMint).
		SetBubblegumSignerAccount(bubblegumSigner).
		SetCollectionAuthorityRecordAccount(collectionAuthorityRecord)
}

// SetSetCollectionSizeArgs sets the "setCollectionSizeArgs" parameter.
func (obj *BubblegumSetCollectionSize) SetSetCollectionSizeArgs(setCollectionSizeArgs SetCollectionSizeArgs) *BubblegumSetCollectionSize {
	obj.SetCollectionSizeArgs = &setCollectionSizeArgs
	return obj
}

// SetCollectionMetadataAccount sets the "collectionMetadata" parameter.
// Collection Metadata account
func (obj *BubblegumSetCollectionSize) SetCollectionMetadataAccount(collectionMetadata common.PublicKey) *BubblegumSetCollectionSize {
	obj.AccountMetaSlice[0] = common.Meta(collectionMetadata).WRITE()
	return obj
}

// GetCollectionMetadataAccount gets the "collectionMetadata" parameter.
// Collection Metadata account
func (obj *BubblegumSetCollectionSize) GetCollectionMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetCollectionAuthorityAccount sets the "collectionAuthority" parameter.
// Collection Update authority
func (obj *BubblegumSetCollectionSize) SetCollectionAuthorityAccount(collectionAuthority common.PublicKey) *BubblegumSetCollectionSize {
	obj.AccountMetaSlice[1] = common.Meta(collectionAuthority).SIGNER()
	return obj
}

// GetCollectionAuthorityAccount gets the "collectionAuthority" parameter.
// Collection Update authority
func (obj *BubblegumSetCollectionSize) GetCollectionAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetCollectionMintAccount sets the "collectionMint" parameter.
// Mint of the Collection
func (obj *BubblegumSetCollectionSize) SetCollectionMintAccount(collectionMint common.PublicKey) *BubblegumSetCollectionSize {
	obj.AccountMetaSlice[2] = common.Meta(collectionMint)
	return obj
}

// GetCollectionMintAccount gets the "collectionMint" parameter.
// Mint of the Collection
func (obj *BubblegumSetCollectionSize) GetCollectionMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetBubblegumSignerAccount sets the "bubblegumSigner" parameter.
// Signing PDA of Bubblegum program
func (obj *BubblegumSetCollectionSize) SetBubblegumSignerAccount(bubblegumSigner common.PublicKey) *BubblegumSetCollectionSize {
	obj.AccountMetaSlice[3] = common.Meta(bubblegumSigner).SIGNER()
	return obj
}

// GetBubblegumSignerAccount gets the "bubblegumSigner" parameter.
// Signing PDA of Bubblegum program
func (obj *BubblegumSetCollectionSize) GetBubblegumSignerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetCollectionAuthorityRecordAccount sets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *BubblegumSetCollectionSize) SetCollectionAuthorityRecordAccount(collectionAuthorityRecord common.PublicKey, multiSigners ...common.PublicKey) *BubblegumSetCollectionSize {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[4] = common.Meta(collectionAuthorityRecord)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[4] = common.Meta(collectionAuthorityRecord)
	}
	return obj
}

// GetCollectionAuthorityRecordAccount gets the "collectionAuthorityRecord" parameter.
// Collection Authority Record PDA
func (obj *BubblegumSetCollectionSize) GetCollectionAuthorityRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

func (obj *BubblegumSetCollectionSize) SetProgramId(programId *common.PublicKey) *BubblegumSetCollectionSize {
	obj._programId = programId
	return obj
}

func (obj *BubblegumSetCollectionSize) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_BubblegumSetCollectionSize}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *BubblegumSetCollectionSize) Validate() error {
	if obj.SetCollectionSizeArgs == nil {
		return errors.New("[BubblegumSetCollectionSize] setCollectionSizeArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[BubblegumSetCollectionSize] accounts.collectionMetadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[BubblegumSetCollectionSize] accounts.collectionAuthority is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[BubblegumSetCollectionSize] accounts.collectionMint is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[BubblegumSetCollectionSize] accounts.bubblegumSigner is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[BubblegumSetCollectionSize] accounts.collectionAuthorityRecord is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *BubblegumSetCollectionSize) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *BubblegumSetCollectionSize) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.SetCollectionSizeArgs); err != nil {
		return err
	}
	return nil
}

func (obj *BubblegumSetCollectionSize) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.SetCollectionSizeArgs); err != nil {
		return err
	}
	return nil
}

func (obj *BubblegumSetCollectionSize) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("BubblegumSetCollectionSize")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("SetCollectionSizeArgs", *obj.SetCollectionSizeArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=5]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("       collectionMetadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("      collectionAuthority", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("           collectionMint", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("          bubblegumSigner", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("collectionAuthorityRecord", obj.AccountMetaSlice.Get(4)))
					})
				})
		})
}

// BurnEditionNft Instruction
type BurnEditionNft struct {
	// [0] = [WRITE] metadata `Metadata (pda of ['metadata', program id, mint id])`
	// [1] = [WRITE, SIGNER] owner `NFT owner`
	// [2] = [WRITE] printEditionMint `Mint of the print edition NFT`
	// [3] = [] masterEditionMint `Mint of the original/master NFT`
	// [4] = [WRITE] printEditionTokenAccount `Token account the print edition NFT is in`
	// [5] = [] masterEditionTokenAccount `Token account the Master Edition NFT is in`
	// [6] = [WRITE] masterEditionAccount `MasterEdition2 of the original NFT`
	// [7] = [WRITE] printEditionAccount `Print Edition account of the NFT`
	// [8] = [WRITE] editionMarkerAccount `Edition Marker PDA of the NFT`
	// [9] = [] splTokenProgram `SPL Token Program`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewBurnEditionNftInstructionBuilder creates a new `BurnEditionNft` instruction builder.
func NewBurnEditionNftInstructionBuilder() *BurnEditionNft {
	return &BurnEditionNft{
		AccountMetaSlice: make(common.AccountMetaSlice, 10),
	}
}

// NewBurnEditionNftInstruction
//
// Parameters:
//
//	metadata: Metadata (pda of ['metadata', program id, mint id])
//	owner: NFT owner
//	printEditionMint: Mint of the print edition NFT
//	masterEditionMint: Mint of the original/master NFT
//	printEditionTokenAccount: Token account the print edition NFT is in
//	masterEditionTokenAccount: Token account the Master Edition NFT is in
//	masterEditionAccount: MasterEdition2 of the original NFT
//	printEditionAccount: Print Edition account of the NFT
//	editionMarkerAccount: Edition Marker PDA of the NFT
//	splTokenProgram: SPL Token Program
func NewBurnEditionNftInstruction(
	metadata common.PublicKey,
	owner common.PublicKey,
	printEditionMint common.PublicKey,
	masterEditionMint common.PublicKey,
	printEditionTokenAccount common.PublicKey,
	masterEditionTokenAccount common.PublicKey,
	masterEditionAccount common.PublicKey,
	printEditionAccount common.PublicKey,
	editionMarkerAccount common.PublicKey,
	splTokenProgram common.PublicKey,
) *BurnEditionNft {
	return NewBurnEditionNftInstructionBuilder().
		SetMetadataAccount(metadata).
		SetOwnerAccount(owner).
		SetPrintEditionMintAccount(printEditionMint).
		SetMasterEditionMintAccount(masterEditionMint).
		SetPrintEditionTokenAccountAccount(printEditionTokenAccount).
		SetMasterEditionTokenAccountAccount(masterEditionTokenAccount).
		SetMasterEditionAccountAccount(masterEditionAccount).
		SetPrintEditionAccountAccount(printEditionAccount).
		SetEditionMarkerAccountAccount(editionMarkerAccount).
		SetSplTokenProgramAccount(splTokenProgram)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata (pda of ['metadata', program id, mint id])
func (obj *BurnEditionNft) SetMetadataAccount(metadata common.PublicKey) *BurnEditionNft {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata (pda of ['metadata', program id, mint id])
func (obj *BurnEditionNft) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetOwnerAccount sets the "owner" parameter.
// NFT owner
func (obj *BurnEditionNft) SetOwnerAccount(owner common.PublicKey) *BurnEditionNft {
	obj.AccountMetaSlice[1] = common.Meta(owner).WRITE().SIGNER()
	return obj
}

// GetOwnerAccount gets the "owner" parameter.
// NFT owner
func (obj *BurnEditionNft) GetOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetPrintEditionMintAccount sets the "printEditionMint" parameter.
// Mint of the print edition NFT
func (obj *BurnEditionNft) SetPrintEditionMintAccount(printEditionMint common.PublicKey) *BurnEditionNft {
	obj.AccountMetaSlice[2] = common.Meta(printEditionMint).WRITE()
	return obj
}

// GetPrintEditionMintAccount gets the "printEditionMint" parameter.
// Mint of the print edition NFT
func (obj *BurnEditionNft) GetPrintEditionMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMasterEditionMintAccount sets the "masterEditionMint" parameter.
// Mint of the original/master NFT
func (obj *BurnEditionNft) SetMasterEditionMintAccount(masterEditionMint common.PublicKey) *BurnEditionNft {
	obj.AccountMetaSlice[3] = common.Meta(masterEditionMint)
	return obj
}

// GetMasterEditionMintAccount gets the "masterEditionMint" parameter.
// Mint of the original/master NFT
func (obj *BurnEditionNft) GetMasterEditionMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetPrintEditionTokenAccountAccount sets the "printEditionTokenAccount" parameter.
// Token account the print edition NFT is in
func (obj *BurnEditionNft) SetPrintEditionTokenAccountAccount(printEditionTokenAccount common.PublicKey) *BurnEditionNft {
	obj.AccountMetaSlice[4] = common.Meta(printEditionTokenAccount).WRITE()
	return obj
}

// GetPrintEditionTokenAccountAccount gets the "printEditionTokenAccount" parameter.
// Token account the print edition NFT is in
func (obj *BurnEditionNft) GetPrintEditionTokenAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetMasterEditionTokenAccountAccount sets the "masterEditionTokenAccount" parameter.
// Token account the Master Edition NFT is in
func (obj *BurnEditionNft) SetMasterEditionTokenAccountAccount(masterEditionTokenAccount common.PublicKey) *BurnEditionNft {
	obj.AccountMetaSlice[5] = common.Meta(masterEditionTokenAccount)
	return obj
}

// GetMasterEditionTokenAccountAccount gets the "masterEditionTokenAccount" parameter.
// Token account the Master Edition NFT is in
func (obj *BurnEditionNft) GetMasterEditionTokenAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetMasterEditionAccountAccount sets the "masterEditionAccount" parameter.
// MasterEdition2 of the original NFT
func (obj *BurnEditionNft) SetMasterEditionAccountAccount(masterEditionAccount common.PublicKey) *BurnEditionNft {
	obj.AccountMetaSlice[6] = common.Meta(masterEditionAccount).WRITE()
	return obj
}

// GetMasterEditionAccountAccount gets the "masterEditionAccount" parameter.
// MasterEdition2 of the original NFT
func (obj *BurnEditionNft) GetMasterEditionAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetPrintEditionAccountAccount sets the "printEditionAccount" parameter.
// Print Edition account of the NFT
func (obj *BurnEditionNft) SetPrintEditionAccountAccount(printEditionAccount common.PublicKey) *BurnEditionNft {
	obj.AccountMetaSlice[7] = common.Meta(printEditionAccount).WRITE()
	return obj
}

// GetPrintEditionAccountAccount gets the "printEditionAccount" parameter.
// Print Edition account of the NFT
func (obj *BurnEditionNft) GetPrintEditionAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetEditionMarkerAccountAccount sets the "editionMarkerAccount" parameter.
// Edition Marker PDA of the NFT
func (obj *BurnEditionNft) SetEditionMarkerAccountAccount(editionMarkerAccount common.PublicKey) *BurnEditionNft {
	obj.AccountMetaSlice[8] = common.Meta(editionMarkerAccount).WRITE()
	return obj
}

// GetEditionMarkerAccountAccount gets the "editionMarkerAccount" parameter.
// Edition Marker PDA of the NFT
func (obj *BurnEditionNft) GetEditionMarkerAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *BurnEditionNft) SetSplTokenProgramAccount(splTokenProgram common.PublicKey, multiSigners ...common.PublicKey) *BurnEditionNft {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[9] = common.Meta(splTokenProgram)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[9] = common.Meta(splTokenProgram)
	}
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *BurnEditionNft) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

func (obj *BurnEditionNft) SetProgramId(programId *common.PublicKey) *BurnEditionNft {
	obj._programId = programId
	return obj
}

func (obj *BurnEditionNft) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_BurnEditionNft}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *BurnEditionNft) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[BurnEditionNft] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[BurnEditionNft] accounts.owner is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[BurnEditionNft] accounts.printEditionMint is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[BurnEditionNft] accounts.masterEditionMint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[BurnEditionNft] accounts.printEditionTokenAccount is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[BurnEditionNft] accounts.masterEditionTokenAccount is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[BurnEditionNft] accounts.masterEditionAccount is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[BurnEditionNft] accounts.printEditionAccount is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[BurnEditionNft] accounts.editionMarkerAccount is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[BurnEditionNft] accounts.splTokenProgram is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *BurnEditionNft) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *BurnEditionNft) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *BurnEditionNft) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *BurnEditionNft) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("BurnEditionNft")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=10]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                 metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("                    owner", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("         printEditionMint", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("        masterEditionMint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta(" printEditionTokenAccount", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("masterEditionTokenAccount", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("     masterEditionAccount", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("      printEditionAccount", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("     editionMarkerAccount", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("          splTokenProgram", obj.AccountMetaSlice.Get(9)))
					})
				})
		})
}

// CreateEscrowAccount Instruction
type CreateEscrowAccount struct {
	// [0] = [WRITE] escrow `Escrow account`
	// [1] = [WRITE] metadata `Metadata account`
	// [2] = [] mint `Mint account`
	// [3] = [] tokenAccount `Token account of the token`
	// [4] = [] edition `Edition account`
	// [5] = [WRITE, SIGNER] payer `Wallet paying for the transaction and new account`
	// [6] = [] systemProgram `System program`
	// [7] = [] sysvarInstructions `Instructions sysvar account`
	// [8] = [SIGNER] authority `Authority/creator of the escrow account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewCreateEscrowAccountInstructionBuilder creates a new `CreateEscrowAccount` instruction builder.
func NewCreateEscrowAccountInstructionBuilder() *CreateEscrowAccount {
	return &CreateEscrowAccount{
		AccountMetaSlice: make(common.AccountMetaSlice, 9),
	}
}

// NewCreateEscrowAccountInstruction
//
// Parameters:
//
//	escrow: Escrow account
//	metadata: Metadata account
//	mint: Mint account
//	tokenAccount: Token account of the token
//	edition: Edition account
//	payer: Wallet paying for the transaction and new account
//	systemProgram: System program
//	sysvarInstructions: Instructions sysvar account
//	authority: Authority/creator of the escrow account
func NewCreateEscrowAccountInstruction(
	escrow common.PublicKey,
	metadata common.PublicKey,
	mint common.PublicKey,
	tokenAccount common.PublicKey,
	edition common.PublicKey,
	payer common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
	authority common.PublicKey,
) *CreateEscrowAccount {
	return NewCreateEscrowAccountInstructionBuilder().
		SetEscrowAccount(escrow).
		SetMetadataAccount(metadata).
		SetMintAccount(mint).
		SetTokenAccountAccount(tokenAccount).
		SetEditionAccount(edition).
		SetPayerAccount(payer).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions).
		SetAuthorityAccount(authority)
}

// SetEscrowAccount sets the "escrow" parameter.
// Escrow account
func (obj *CreateEscrowAccount) SetEscrowAccount(escrow common.PublicKey) *CreateEscrowAccount {
	obj.AccountMetaSlice[0] = common.Meta(escrow).WRITE()
	return obj
}

// GetEscrowAccount gets the "escrow" parameter.
// Escrow account
func (obj *CreateEscrowAccount) GetEscrowAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *CreateEscrowAccount) SetMetadataAccount(metadata common.PublicKey) *CreateEscrowAccount {
	obj.AccountMetaSlice[1] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *CreateEscrowAccount) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMintAccount sets the "mint" parameter.
// Mint account
func (obj *CreateEscrowAccount) SetMintAccount(mint common.PublicKey) *CreateEscrowAccount {
	obj.AccountMetaSlice[2] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint account
func (obj *CreateEscrowAccount) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetTokenAccountAccount sets the "tokenAccount" parameter.
// Token account of the token
func (obj *CreateEscrowAccount) SetTokenAccountAccount(tokenAccount common.PublicKey) *CreateEscrowAccount {
	obj.AccountMetaSlice[3] = common.Meta(tokenAccount)
	return obj
}

// GetTokenAccountAccount gets the "tokenAccount" parameter.
// Token account of the token
func (obj *CreateEscrowAccount) GetTokenAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetEditionAccount sets the "edition" parameter.
// Edition account
func (obj *CreateEscrowAccount) SetEditionAccount(edition common.PublicKey) *CreateEscrowAccount {
	obj.AccountMetaSlice[4] = common.Meta(edition)
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Edition account
func (obj *CreateEscrowAccount) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetPayerAccount sets the "payer" parameter.
// Wallet paying for the transaction and new account
func (obj *CreateEscrowAccount) SetPayerAccount(payer common.PublicKey) *CreateEscrowAccount {
	obj.AccountMetaSlice[5] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Wallet paying for the transaction and new account
func (obj *CreateEscrowAccount) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *CreateEscrowAccount) SetSystemProgramAccount(systemProgram common.PublicKey) *CreateEscrowAccount {
	obj.AccountMetaSlice[6] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *CreateEscrowAccount) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *CreateEscrowAccount) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey) *CreateEscrowAccount {
	obj.AccountMetaSlice[7] = common.Meta(sysvarInstructions)
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *CreateEscrowAccount) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetAuthorityAccount sets the "authority" parameter.
// Authority/creator of the escrow account
func (obj *CreateEscrowAccount) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *CreateEscrowAccount {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[8] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[8] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Authority/creator of the escrow account
func (obj *CreateEscrowAccount) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

func (obj *CreateEscrowAccount) SetProgramId(programId *common.PublicKey) *CreateEscrowAccount {
	obj._programId = programId
	return obj
}

func (obj *CreateEscrowAccount) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_CreateEscrowAccount}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *CreateEscrowAccount) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[CreateEscrowAccount] accounts.escrow is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[CreateEscrowAccount] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[CreateEscrowAccount] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[CreateEscrowAccount] accounts.tokenAccount is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[CreateEscrowAccount] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[CreateEscrowAccount] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[CreateEscrowAccount] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[CreateEscrowAccount] accounts.sysvarInstructions is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[CreateEscrowAccount] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *CreateEscrowAccount) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *CreateEscrowAccount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *CreateEscrowAccount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *CreateEscrowAccount) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("CreateEscrowAccount")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=9]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("            escrow", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("          metadata", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("              mint", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("      tokenAccount", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("           edition", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("             payer", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("     systemProgram", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("sysvarInstructions", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("         authority", obj.AccountMetaSlice.Get(8)))
					})
				})
		})
}

// CloseEscrowAccount Instruction
type CloseEscrowAccount struct {
	// [0] = [WRITE] escrow `Escrow account`
	// [1] = [WRITE] metadata `Metadata account`
	// [2] = [] mint `Mint account`
	// [3] = [] tokenAccount `Token account`
	// [4] = [] edition `Edition account`
	// [5] = [WRITE, SIGNER] payer `Wallet paying for the transaction and new account`
	// [6] = [] systemProgram `System program`
	// [7] = [] sysvarInstructions `Instructions sysvar account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewCloseEscrowAccountInstructionBuilder creates a new `CloseEscrowAccount` instruction builder.
func NewCloseEscrowAccountInstructionBuilder() *CloseEscrowAccount {
	return &CloseEscrowAccount{
		AccountMetaSlice: make(common.AccountMetaSlice, 8),
	}
}

// NewCloseEscrowAccountInstruction
//
// Parameters:
//
//	escrow: Escrow account
//	metadata: Metadata account
//	mint: Mint account
//	tokenAccount: Token account
//	edition: Edition account
//	payer: Wallet paying for the transaction and new account
//	systemProgram: System program
//	sysvarInstructions: Instructions sysvar account
func NewCloseEscrowAccountInstruction(
	escrow common.PublicKey,
	metadata common.PublicKey,
	mint common.PublicKey,
	tokenAccount common.PublicKey,
	edition common.PublicKey,
	payer common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
) *CloseEscrowAccount {
	return NewCloseEscrowAccountInstructionBuilder().
		SetEscrowAccount(escrow).
		SetMetadataAccount(metadata).
		SetMintAccount(mint).
		SetTokenAccountAccount(tokenAccount).
		SetEditionAccount(edition).
		SetPayerAccount(payer).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions)
}

// SetEscrowAccount sets the "escrow" parameter.
// Escrow account
func (obj *CloseEscrowAccount) SetEscrowAccount(escrow common.PublicKey) *CloseEscrowAccount {
	obj.AccountMetaSlice[0] = common.Meta(escrow).WRITE()
	return obj
}

// GetEscrowAccount gets the "escrow" parameter.
// Escrow account
func (obj *CloseEscrowAccount) GetEscrowAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *CloseEscrowAccount) SetMetadataAccount(metadata common.PublicKey) *CloseEscrowAccount {
	obj.AccountMetaSlice[1] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *CloseEscrowAccount) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMintAccount sets the "mint" parameter.
// Mint account
func (obj *CloseEscrowAccount) SetMintAccount(mint common.PublicKey) *CloseEscrowAccount {
	obj.AccountMetaSlice[2] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint account
func (obj *CloseEscrowAccount) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetTokenAccountAccount sets the "tokenAccount" parameter.
// Token account
func (obj *CloseEscrowAccount) SetTokenAccountAccount(tokenAccount common.PublicKey) *CloseEscrowAccount {
	obj.AccountMetaSlice[3] = common.Meta(tokenAccount)
	return obj
}

// GetTokenAccountAccount gets the "tokenAccount" parameter.
// Token account
func (obj *CloseEscrowAccount) GetTokenAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetEditionAccount sets the "edition" parameter.
// Edition account
func (obj *CloseEscrowAccount) SetEditionAccount(edition common.PublicKey) *CloseEscrowAccount {
	obj.AccountMetaSlice[4] = common.Meta(edition)
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Edition account
func (obj *CloseEscrowAccount) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetPayerAccount sets the "payer" parameter.
// Wallet paying for the transaction and new account
func (obj *CloseEscrowAccount) SetPayerAccount(payer common.PublicKey) *CloseEscrowAccount {
	obj.AccountMetaSlice[5] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Wallet paying for the transaction and new account
func (obj *CloseEscrowAccount) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *CloseEscrowAccount) SetSystemProgramAccount(systemProgram common.PublicKey) *CloseEscrowAccount {
	obj.AccountMetaSlice[6] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *CloseEscrowAccount) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *CloseEscrowAccount) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey, multiSigners ...common.PublicKey) *CloseEscrowAccount {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[7] = common.Meta(sysvarInstructions)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[7] = common.Meta(sysvarInstructions)
	}
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *CloseEscrowAccount) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

func (obj *CloseEscrowAccount) SetProgramId(programId *common.PublicKey) *CloseEscrowAccount {
	obj._programId = programId
	return obj
}

func (obj *CloseEscrowAccount) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_CloseEscrowAccount}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *CloseEscrowAccount) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[CloseEscrowAccount] accounts.escrow is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[CloseEscrowAccount] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[CloseEscrowAccount] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[CloseEscrowAccount] accounts.tokenAccount is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[CloseEscrowAccount] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[CloseEscrowAccount] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[CloseEscrowAccount] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[CloseEscrowAccount] accounts.sysvarInstructions is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *CloseEscrowAccount) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *CloseEscrowAccount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *CloseEscrowAccount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *CloseEscrowAccount) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("CloseEscrowAccount")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=8]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("            escrow", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("          metadata", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("              mint", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("      tokenAccount", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("           edition", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("             payer", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("     systemProgram", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("sysvarInstructions", obj.AccountMetaSlice.Get(7)))
					})
				})
		})
}

// TransferOutOfEscrow Instruction
type TransferOutOfEscrow struct {
	TransferOutOfEscrowArgs *TransferOutOfEscrowArgs
	// [0] = [] escrow `Escrow account`
	// [1] = [WRITE] metadata `Metadata account`
	// [2] = [WRITE, SIGNER] payer `Wallet paying for the transaction and new account`
	// [3] = [] attributeMint `Mint account for the new attribute`
	// [4] = [WRITE] attributeSrc `Token account source for the new attribute`
	// [5] = [WRITE] attributeDst `Token account, owned by TM, destination for the new attribute`
	// [6] = [] escrowMint `Mint account that the escrow is attached`
	// [7] = [] escrowAccount `Token account that holds the token the escrow is attached to`
	// [8] = [] systemProgram `System program`
	// [9] = [] ataProgram `Associated Token program`
	// [10] = [] tokenProgram `Token program`
	// [11] = [] sysvarInstructions `Instructions sysvar account`
	// [12] = [SIGNER] authority `Authority/creator of the escrow account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewTransferOutOfEscrowInstructionBuilder creates a new `TransferOutOfEscrow` instruction builder.
func NewTransferOutOfEscrowInstructionBuilder() *TransferOutOfEscrow {
	return &TransferOutOfEscrow{
		AccountMetaSlice: make(common.AccountMetaSlice, 13),
	}
}

// NewTransferOutOfEscrowInstruction
//
// Parameters:
//
//	transferOutOfEscrowArgs:
//	escrow: Escrow account
//	metadata: Metadata account
//	payer: Wallet paying for the transaction and new account
//	attributeMint: Mint account for the new attribute
//	attributeSrc: Token account source for the new attribute
//	attributeDst: Token account, owned by TM, destination for the new attribute
//	escrowMint: Mint account that the escrow is attached
//	escrowAccount: Token account that holds the token the escrow is attached to
//	systemProgram: System program
//	ataProgram: Associated Token program
//	tokenProgram: Token program
//	sysvarInstructions: Instructions sysvar account
//	authority: Authority/creator of the escrow account
func NewTransferOutOfEscrowInstruction(
	transferOutOfEscrowArgs TransferOutOfEscrowArgs,
	escrow common.PublicKey,
	metadata common.PublicKey,
	payer common.PublicKey,
	attributeMint common.PublicKey,
	attributeSrc common.PublicKey,
	attributeDst common.PublicKey,
	escrowMint common.PublicKey,
	escrowAccount common.PublicKey,
	systemProgram common.PublicKey,
	ataProgram common.PublicKey,
	tokenProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
	authority common.PublicKey,
) *TransferOutOfEscrow {
	return NewTransferOutOfEscrowInstructionBuilder().
		SetTransferOutOfEscrowArgs(transferOutOfEscrowArgs).
		SetEscrowAccount(escrow).
		SetMetadataAccount(metadata).
		SetPayerAccount(payer).
		SetAttributeMintAccount(attributeMint).
		SetAttributeSrcAccount(attributeSrc).
		SetAttributeDstAccount(attributeDst).
		SetEscrowMintAccount(escrowMint).
		SetEscrowAccountAccount(escrowAccount).
		SetSystemProgramAccount(systemProgram).
		SetAtaProgramAccount(ataProgram).
		SetTokenProgramAccount(tokenProgram).
		SetSysvarInstructionsAccount(sysvarInstructions).
		SetAuthorityAccount(authority)
}

// SetTransferOutOfEscrowArgs sets the "transferOutOfEscrowArgs" parameter.
func (obj *TransferOutOfEscrow) SetTransferOutOfEscrowArgs(transferOutOfEscrowArgs TransferOutOfEscrowArgs) *TransferOutOfEscrow {
	obj.TransferOutOfEscrowArgs = &transferOutOfEscrowArgs
	return obj
}

// SetEscrowAccount sets the "escrow" parameter.
// Escrow account
func (obj *TransferOutOfEscrow) SetEscrowAccount(escrow common.PublicKey) *TransferOutOfEscrow {
	obj.AccountMetaSlice[0] = common.Meta(escrow)
	return obj
}

// GetEscrowAccount gets the "escrow" parameter.
// Escrow account
func (obj *TransferOutOfEscrow) GetEscrowAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *TransferOutOfEscrow) SetMetadataAccount(metadata common.PublicKey) *TransferOutOfEscrow {
	obj.AccountMetaSlice[1] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *TransferOutOfEscrow) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetPayerAccount sets the "payer" parameter.
// Wallet paying for the transaction and new account
func (obj *TransferOutOfEscrow) SetPayerAccount(payer common.PublicKey) *TransferOutOfEscrow {
	obj.AccountMetaSlice[2] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Wallet paying for the transaction and new account
func (obj *TransferOutOfEscrow) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetAttributeMintAccount sets the "attributeMint" parameter.
// Mint account for the new attribute
func (obj *TransferOutOfEscrow) SetAttributeMintAccount(attributeMint common.PublicKey) *TransferOutOfEscrow {
	obj.AccountMetaSlice[3] = common.Meta(attributeMint)
	return obj
}

// GetAttributeMintAccount gets the "attributeMint" parameter.
// Mint account for the new attribute
func (obj *TransferOutOfEscrow) GetAttributeMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetAttributeSrcAccount sets the "attributeSrc" parameter.
// Token account source for the new attribute
func (obj *TransferOutOfEscrow) SetAttributeSrcAccount(attributeSrc common.PublicKey) *TransferOutOfEscrow {
	obj.AccountMetaSlice[4] = common.Meta(attributeSrc).WRITE()
	return obj
}

// GetAttributeSrcAccount gets the "attributeSrc" parameter.
// Token account source for the new attribute
func (obj *TransferOutOfEscrow) GetAttributeSrcAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetAttributeDstAccount sets the "attributeDst" parameter.
// Token account, owned by TM, destination for the new attribute
func (obj *TransferOutOfEscrow) SetAttributeDstAccount(attributeDst common.PublicKey) *TransferOutOfEscrow {
	obj.AccountMetaSlice[5] = common.Meta(attributeDst).WRITE()
	return obj
}

// GetAttributeDstAccount gets the "attributeDst" parameter.
// Token account, owned by TM, destination for the new attribute
func (obj *TransferOutOfEscrow) GetAttributeDstAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetEscrowMintAccount sets the "escrowMint" parameter.
// Mint account that the escrow is attached
func (obj *TransferOutOfEscrow) SetEscrowMintAccount(escrowMint common.PublicKey) *TransferOutOfEscrow {
	obj.AccountMetaSlice[6] = common.Meta(escrowMint)
	return obj
}

// GetEscrowMintAccount gets the "escrowMint" parameter.
// Mint account that the escrow is attached
func (obj *TransferOutOfEscrow) GetEscrowMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetEscrowAccountAccount sets the "escrowAccount" parameter.
// Token account that holds the token the escrow is attached to
func (obj *TransferOutOfEscrow) SetEscrowAccountAccount(escrowAccount common.PublicKey) *TransferOutOfEscrow {
	obj.AccountMetaSlice[7] = common.Meta(escrowAccount)
	return obj
}

// GetEscrowAccountAccount gets the "escrowAccount" parameter.
// Token account that holds the token the escrow is attached to
func (obj *TransferOutOfEscrow) GetEscrowAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *TransferOutOfEscrow) SetSystemProgramAccount(systemProgram common.PublicKey) *TransferOutOfEscrow {
	obj.AccountMetaSlice[8] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *TransferOutOfEscrow) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetAtaProgramAccount sets the "ataProgram" parameter.
// Associated Token program
func (obj *TransferOutOfEscrow) SetAtaProgramAccount(ataProgram common.PublicKey) *TransferOutOfEscrow {
	obj.AccountMetaSlice[9] = common.Meta(ataProgram)
	return obj
}

// GetAtaProgramAccount gets the "ataProgram" parameter.
// Associated Token program
func (obj *TransferOutOfEscrow) GetAtaProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetTokenProgramAccount sets the "tokenProgram" parameter.
// Token program
func (obj *TransferOutOfEscrow) SetTokenProgramAccount(tokenProgram common.PublicKey) *TransferOutOfEscrow {
	obj.AccountMetaSlice[10] = common.Meta(tokenProgram)
	return obj
}

// GetTokenProgramAccount gets the "tokenProgram" parameter.
// Token program
func (obj *TransferOutOfEscrow) GetTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *TransferOutOfEscrow) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey) *TransferOutOfEscrow {
	obj.AccountMetaSlice[11] = common.Meta(sysvarInstructions)
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *TransferOutOfEscrow) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

// SetAuthorityAccount sets the "authority" parameter.
// Authority/creator of the escrow account
func (obj *TransferOutOfEscrow) SetAuthorityAccount(authority common.PublicKey, multiSigners ...common.PublicKey) *TransferOutOfEscrow {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[12] = common.Meta(authority)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[12] = common.Meta(authority).SIGNER()
	}
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Authority/creator of the escrow account
func (obj *TransferOutOfEscrow) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(12)
}

func (obj *TransferOutOfEscrow) SetProgramId(programId *common.PublicKey) *TransferOutOfEscrow {
	obj._programId = programId
	return obj
}

func (obj *TransferOutOfEscrow) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_TransferOutOfEscrow}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *TransferOutOfEscrow) Validate() error {
	if obj.TransferOutOfEscrowArgs == nil {
		return errors.New("[TransferOutOfEscrow] transferOutOfEscrowArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[TransferOutOfEscrow] accounts.escrow is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[TransferOutOfEscrow] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[TransferOutOfEscrow] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[TransferOutOfEscrow] accounts.attributeMint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[TransferOutOfEscrow] accounts.attributeSrc is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[TransferOutOfEscrow] accounts.attributeDst is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[TransferOutOfEscrow] accounts.escrowMint is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[TransferOutOfEscrow] accounts.escrowAccount is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[TransferOutOfEscrow] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[TransferOutOfEscrow] accounts.ataProgram is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[TransferOutOfEscrow] accounts.tokenProgram is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[TransferOutOfEscrow] accounts.sysvarInstructions is not set")
	}
	if obj.AccountMetaSlice[12] == nil {
		return errors.New("[TransferOutOfEscrow] accounts.authority is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *TransferOutOfEscrow) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *TransferOutOfEscrow) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.TransferOutOfEscrowArgs); err != nil {
		return err
	}
	return nil
}

func (obj *TransferOutOfEscrow) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.TransferOutOfEscrowArgs); err != nil {
		return err
	}
	return nil
}

func (obj *TransferOutOfEscrow) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("TransferOutOfEscrow")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("TransferOutOfEscrowArgs", *obj.TransferOutOfEscrowArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=13]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("            escrow", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("          metadata", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("             payer", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("     attributeMint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("      attributeSrc", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("      attributeDst", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("        escrowMint", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("     escrowAccount", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("     systemProgram", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("        ataProgram", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("      tokenProgram", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("sysvarInstructions", obj.AccountMetaSlice.Get(11)))
						accountsBranch.Child(common.FormatMeta("         authority", obj.AccountMetaSlice.Get(12)))
					})
				})
		})
}

// Burn Instruction
type Burn struct {
	BurnArgs *BurnArgs
	// [0] = [WRITE, SIGNER] authority `Asset owner or Utility delegate`
	// [1] = [WRITE] collectionMetadata `Metadata of the Collection`
	// [2] = [WRITE] metadata `Metadata (pda of ['metadata', program id, mint id])`
	// [3] = [WRITE] edition `Edition of the asset`
	// [4] = [WRITE] mint `Mint of token asset`
	// [5] = [WRITE] token `Token account to close`
	// [6] = [WRITE] masterEdition `Master edition account`
	// [7] = [] masterEditionMint `Master edition mint of the asset`
	// [8] = [] masterEditionToken `Master edition token account`
	// [9] = [WRITE] editionMarker `Edition marker account`
	// [10] = [WRITE] tokenRecord `Token record account`
	// [11] = [] systemProgram `System program`
	// [12] = [] sysvarInstructions `Instructions sysvar account`
	// [13] = [] splTokenProgram `SPL Token Program`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewBurnInstructionBuilder creates a new `Burn` instruction builder.
func NewBurnInstructionBuilder() *Burn {
	return &Burn{
		AccountMetaSlice: make(common.AccountMetaSlice, 14),
	}
}

// NewBurnInstruction
//
// Parameters:
//
//	burnArgs:
//	authority: Asset owner or Utility delegate
//	collectionMetadata: Metadata of the Collection
//	metadata: Metadata (pda of ['metadata', program id, mint id])
//	edition: Edition of the asset
//	mint: Mint of token asset
//	token: Token account to close
//	masterEdition: Master edition account
//	masterEditionMint: Master edition mint of the asset
//	masterEditionToken: Master edition token account
//	editionMarker: Edition marker account
//	tokenRecord: Token record account
//	systemProgram: System program
//	sysvarInstructions: Instructions sysvar account
//	splTokenProgram: SPL Token Program
func NewBurnInstruction(
	burnArgs BurnArgs,
	authority common.PublicKey,
	collectionMetadata common.PublicKey,
	metadata common.PublicKey,
	edition common.PublicKey,
	mint common.PublicKey,
	token common.PublicKey,
	masterEdition common.PublicKey,
	masterEditionMint common.PublicKey,
	masterEditionToken common.PublicKey,
	editionMarker common.PublicKey,
	tokenRecord common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
	splTokenProgram common.PublicKey,
) *Burn {
	return NewBurnInstructionBuilder().
		SetBurnArgs(burnArgs).
		SetAuthorityAccount(authority).
		SetCollectionMetadataAccount(collectionMetadata).
		SetMetadataAccount(metadata).
		SetEditionAccount(edition).
		SetMintAccount(mint).
		SetTokenAccount(token).
		SetMasterEditionAccount(masterEdition).
		SetMasterEditionMintAccount(masterEditionMint).
		SetMasterEditionTokenAccount(masterEditionToken).
		SetEditionMarkerAccount(editionMarker).
		SetTokenRecordAccount(tokenRecord).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions).
		SetSplTokenProgramAccount(splTokenProgram)
}

// SetBurnArgs sets the "burnArgs" parameter.
func (obj *Burn) SetBurnArgs(burnArgs BurnArgs) *Burn {
	obj.BurnArgs = &burnArgs
	return obj
}

// SetAuthorityAccount sets the "authority" parameter.
// Asset owner or Utility delegate
func (obj *Burn) SetAuthorityAccount(authority common.PublicKey) *Burn {
	obj.AccountMetaSlice[0] = common.Meta(authority).WRITE().SIGNER()
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Asset owner or Utility delegate
func (obj *Burn) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetCollectionMetadataAccount sets the "collectionMetadata" parameter.
// Metadata of the Collection
func (obj *Burn) SetCollectionMetadataAccount(collectionMetadata common.PublicKey) *Burn {
	obj.AccountMetaSlice[1] = common.Meta(collectionMetadata).WRITE()
	return obj
}

// GetCollectionMetadataAccount gets the "collectionMetadata" parameter.
// Metadata of the Collection
func (obj *Burn) GetCollectionMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata (pda of ['metadata', program id, mint id])
func (obj *Burn) SetMetadataAccount(metadata common.PublicKey) *Burn {
	obj.AccountMetaSlice[2] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata (pda of ['metadata', program id, mint id])
func (obj *Burn) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetEditionAccount sets the "edition" parameter.
// Edition of the asset
func (obj *Burn) SetEditionAccount(edition common.PublicKey) *Burn {
	obj.AccountMetaSlice[3] = common.Meta(edition).WRITE()
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Edition of the asset
func (obj *Burn) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetMintAccount sets the "mint" parameter.
// Mint of token asset
func (obj *Burn) SetMintAccount(mint common.PublicKey) *Burn {
	obj.AccountMetaSlice[4] = common.Meta(mint).WRITE()
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of token asset
func (obj *Burn) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetTokenAccount sets the "token" parameter.
// Token account to close
func (obj *Burn) SetTokenAccount(token common.PublicKey) *Burn {
	obj.AccountMetaSlice[5] = common.Meta(token).WRITE()
	return obj
}

// GetTokenAccount gets the "token" parameter.
// Token account to close
func (obj *Burn) GetTokenAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetMasterEditionAccount sets the "masterEdition" parameter.
// Master edition account
func (obj *Burn) SetMasterEditionAccount(masterEdition common.PublicKey) *Burn {
	obj.AccountMetaSlice[6] = common.Meta(masterEdition).WRITE()
	return obj
}

// GetMasterEditionAccount gets the "masterEdition" parameter.
// Master edition account
func (obj *Burn) GetMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetMasterEditionMintAccount sets the "masterEditionMint" parameter.
// Master edition mint of the asset
func (obj *Burn) SetMasterEditionMintAccount(masterEditionMint common.PublicKey) *Burn {
	obj.AccountMetaSlice[7] = common.Meta(masterEditionMint)
	return obj
}

// GetMasterEditionMintAccount gets the "masterEditionMint" parameter.
// Master edition mint of the asset
func (obj *Burn) GetMasterEditionMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetMasterEditionTokenAccount sets the "masterEditionToken" parameter.
// Master edition token account
func (obj *Burn) SetMasterEditionTokenAccount(masterEditionToken common.PublicKey) *Burn {
	obj.AccountMetaSlice[8] = common.Meta(masterEditionToken)
	return obj
}

// GetMasterEditionTokenAccount gets the "masterEditionToken" parameter.
// Master edition token account
func (obj *Burn) GetMasterEditionTokenAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetEditionMarkerAccount sets the "editionMarker" parameter.
// Edition marker account
func (obj *Burn) SetEditionMarkerAccount(editionMarker common.PublicKey) *Burn {
	obj.AccountMetaSlice[9] = common.Meta(editionMarker).WRITE()
	return obj
}

// GetEditionMarkerAccount gets the "editionMarker" parameter.
// Edition marker account
func (obj *Burn) GetEditionMarkerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetTokenRecordAccount sets the "tokenRecord" parameter.
// Token record account
func (obj *Burn) SetTokenRecordAccount(tokenRecord common.PublicKey) *Burn {
	obj.AccountMetaSlice[10] = common.Meta(tokenRecord).WRITE()
	return obj
}

// GetTokenRecordAccount gets the "tokenRecord" parameter.
// Token record account
func (obj *Burn) GetTokenRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *Burn) SetSystemProgramAccount(systemProgram common.PublicKey) *Burn {
	obj.AccountMetaSlice[11] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *Burn) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Burn) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey) *Burn {
	obj.AccountMetaSlice[12] = common.Meta(sysvarInstructions)
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Burn) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(12)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Burn) SetSplTokenProgramAccount(splTokenProgram common.PublicKey, multiSigners ...common.PublicKey) *Burn {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[13] = common.Meta(splTokenProgram)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[13] = common.Meta(splTokenProgram)
	}
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Burn) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(13)
}

func (obj *Burn) SetProgramId(programId *common.PublicKey) *Burn {
	obj._programId = programId
	return obj
}

func (obj *Burn) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Burn}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Burn) Validate() error {
	if obj.BurnArgs == nil {
		return errors.New("[Burn] burnArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Burn] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Burn] accounts.collectionMetadata is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Burn] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Burn] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Burn] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Burn] accounts.token is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Burn] accounts.masterEdition is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[Burn] accounts.masterEditionMint is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[Burn] accounts.masterEditionToken is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[Burn] accounts.editionMarker is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[Burn] accounts.tokenRecord is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[Burn] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[12] == nil {
		return errors.New("[Burn] accounts.sysvarInstructions is not set")
	}
	if obj.AccountMetaSlice[13] == nil {
		return errors.New("[Burn] accounts.splTokenProgram is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Burn) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Burn) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.BurnArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Burn) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.BurnArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Burn) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Burn")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("BurnArgs", *obj.BurnArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=14]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("         authority", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("collectionMetadata", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("          metadata", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("           edition", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("              mint", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("             token", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("     masterEdition", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta(" masterEditionMint", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("masterEditionToken", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("     editionMarker", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("       tokenRecord", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("     systemProgram", obj.AccountMetaSlice.Get(11)))
						accountsBranch.Child(common.FormatMeta("sysvarInstructions", obj.AccountMetaSlice.Get(12)))
						accountsBranch.Child(common.FormatMeta("   splTokenProgram", obj.AccountMetaSlice.Get(13)))
					})
				})
		})
}

// Create Instruction
type Create struct {
	CreateArgs *CreateArgs
	// [0] = [WRITE] metadata `Unallocated metadata account with address as pda of ['metadata', program id, mint id]`
	// [1] = [WRITE] masterEdition `Unallocated edition account with address as pda of ['metadata', program id, mint, 'edition']`
	// [2] = [WRITE] mint `Mint of token asset`
	// [3] = [SIGNER] authority `Mint authority`
	// [4] = [WRITE, SIGNER] payer `Payer`
	// [5] = [] updateAuthority `Update authority for the metadata account`
	// [6] = [] systemProgram `System program`
	// [7] = [] sysvarInstructions `Instructions sysvar account`
	// [8] = [] splTokenProgram `SPL Token program`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewCreateInstructionBuilder creates a new `Create` instruction builder.
func NewCreateInstructionBuilder() *Create {
	return &Create{
		AccountMetaSlice: make(common.AccountMetaSlice, 9),
	}
}

// NewCreateInstruction
//
// Parameters:
//
//	createArgs:
//	metadata: Unallocated metadata account with address as pda of ['metadata', program id, mint id]
//	masterEdition: Unallocated edition account with address as pda of ['metadata', program id, mint, 'edition']
//	mint: Mint of token asset
//	authority: Mint authority
//	payer: Payer
//	updateAuthority: Update authority for the metadata account
//	systemProgram: System program
//	sysvarInstructions: Instructions sysvar account
//	splTokenProgram: SPL Token program
func NewCreateInstruction(
	createArgs CreateArgs,
	metadata common.PublicKey,
	masterEdition common.PublicKey,
	mint common.PublicKey,
	authority common.PublicKey,
	payer common.PublicKey,
	updateAuthority common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
	splTokenProgram common.PublicKey,
) *Create {
	return NewCreateInstructionBuilder().
		SetCreateArgs(createArgs).
		SetMetadataAccount(metadata).
		SetMasterEditionAccount(masterEdition).
		SetMintAccount(mint).
		SetAuthorityAccount(authority).
		SetPayerAccount(payer).
		SetUpdateAuthorityAccount(updateAuthority).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions).
		SetSplTokenProgramAccount(splTokenProgram)
}

// SetCreateArgs sets the "createArgs" parameter.
func (obj *Create) SetCreateArgs(createArgs CreateArgs) *Create {
	obj.CreateArgs = &createArgs
	return obj
}

// SetMetadataAccount sets the "metadata" parameter.
// Unallocated metadata account with address as pda of ['metadata', program id, mint id]
func (obj *Create) SetMetadataAccount(metadata common.PublicKey) *Create {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Unallocated metadata account with address as pda of ['metadata', program id, mint id]
func (obj *Create) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetMasterEditionAccount sets the "masterEdition" parameter.
// Unallocated edition account with address as pda of ['metadata', program id, mint, 'edition']
func (obj *Create) SetMasterEditionAccount(masterEdition common.PublicKey) *Create {
	obj.AccountMetaSlice[1] = common.Meta(masterEdition).WRITE()
	return obj
}

// GetMasterEditionAccount gets the "masterEdition" parameter.
// Unallocated edition account with address as pda of ['metadata', program id, mint, 'edition']
func (obj *Create) GetMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMintAccount sets the "mint" parameter.
// Mint of token asset
func (obj *Create) SetMintAccount(mint common.PublicKey) *Create {
	obj.AccountMetaSlice[2] = common.Meta(mint).WRITE()
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of token asset
func (obj *Create) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetAuthorityAccount sets the "authority" parameter.
// Mint authority
func (obj *Create) SetAuthorityAccount(authority common.PublicKey) *Create {
	obj.AccountMetaSlice[3] = common.Meta(authority).SIGNER()
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Mint authority
func (obj *Create) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetPayerAccount sets the "payer" parameter.
// Payer
func (obj *Create) SetPayerAccount(payer common.PublicKey) *Create {
	obj.AccountMetaSlice[4] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Payer
func (obj *Create) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// Update authority for the metadata account
func (obj *Create) SetUpdateAuthorityAccount(updateAuthority common.PublicKey) *Create {
	obj.AccountMetaSlice[5] = common.Meta(updateAuthority)
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// Update authority for the metadata account
func (obj *Create) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *Create) SetSystemProgramAccount(systemProgram common.PublicKey) *Create {
	obj.AccountMetaSlice[6] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *Create) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Create) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey) *Create {
	obj.AccountMetaSlice[7] = common.Meta(sysvarInstructions)
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Create) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token program
func (obj *Create) SetSplTokenProgramAccount(splTokenProgram common.PublicKey, multiSigners ...common.PublicKey) *Create {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[8] = common.Meta(splTokenProgram)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[8] = common.Meta(splTokenProgram)
	}
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token program
func (obj *Create) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

func (obj *Create) SetProgramId(programId *common.PublicKey) *Create {
	obj._programId = programId
	return obj
}

func (obj *Create) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Create}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Create) Validate() error {
	if obj.CreateArgs == nil {
		return errors.New("[Create] createArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Create] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Create] accounts.masterEdition is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Create] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Create] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Create] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Create] accounts.updateAuthority is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Create] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[Create] accounts.sysvarInstructions is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[Create] accounts.splTokenProgram is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Create) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Create) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.CreateArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Create) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.CreateArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Create) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Create")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("CreateArgs", *obj.CreateArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=9]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("          metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("     masterEdition", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("              mint", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("         authority", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("             payer", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("   updateAuthority", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("     systemProgram", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("sysvarInstructions", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("   splTokenProgram", obj.AccountMetaSlice.Get(8)))
					})
				})
		})
}

// Mint Instruction
type Mint struct {
	MintArgs *MintArgs
	// [0] = [WRITE] token `Token or Associated Token account`
	// [1] = [] tokenOwner `Owner of the token account`
	// [2] = [] metadata `Metadata account (pda of ['metadata', program id, mint id])`
	// [3] = [WRITE] masterEdition `Master Edition account`
	// [4] = [WRITE] tokenRecord `Token record account`
	// [5] = [WRITE] mint `Mint of token asset`
	// [6] = [SIGNER] authority `(Mint or Update) authority`
	// [7] = [] delegateRecord `Metadata delegate record`
	// [8] = [WRITE, SIGNER] payer `Payer`
	// [9] = [] systemProgram `System program`
	// [10] = [] sysvarInstructions `Instructions sysvar account`
	// [11] = [] splTokenProgram `SPL Token program`
	// [12] = [] splAtaProgram `SPL Associated Token Account program`
	// [13] = [] authorizationRulesProgram `Token Authorization Rules program`
	// [14] = [] authorizationRules `Token Authorization Rules account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewMintInstructionBuilder creates a new `Mint` instruction builder.
func NewMintInstructionBuilder() *Mint {
	return &Mint{
		AccountMetaSlice: make(common.AccountMetaSlice, 15),
	}
}

// NewMintInstruction
//
// Parameters:
//
//	mintArgs:
//	token: Token or Associated Token account
//	tokenOwner: Owner of the token account
//	metadata: Metadata account (pda of ['metadata', program id, mint id])
//	masterEdition: Master Edition account
//	tokenRecord: Token record account
//	mint: Mint of token asset
//	authority: (Mint or Update) authority
//	delegateRecord: Metadata delegate record
//	payer: Payer
//	systemProgram: System program
//	sysvarInstructions: Instructions sysvar account
//	splTokenProgram: SPL Token program
//	splAtaProgram: SPL Associated Token Account program
//	authorizationRulesProgram: Token Authorization Rules program
//	authorizationRules: Token Authorization Rules account
func NewMintInstruction(
	mintArgs MintArgs,
	token common.PublicKey,
	tokenOwner common.PublicKey,
	metadata common.PublicKey,
	masterEdition common.PublicKey,
	tokenRecord common.PublicKey,
	mint common.PublicKey,
	authority common.PublicKey,
	delegateRecord common.PublicKey,
	payer common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
	splTokenProgram common.PublicKey,
	splAtaProgram common.PublicKey,
	authorizationRulesProgram common.PublicKey,
	authorizationRules common.PublicKey,
) *Mint {
	return NewMintInstructionBuilder().
		SetMintArgs(mintArgs).
		SetTokenAccount(token).
		SetTokenOwnerAccount(tokenOwner).
		SetMetadataAccount(metadata).
		SetMasterEditionAccount(masterEdition).
		SetTokenRecordAccount(tokenRecord).
		SetMintAccount(mint).
		SetAuthorityAccount(authority).
		SetDelegateRecordAccount(delegateRecord).
		SetPayerAccount(payer).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions).
		SetSplTokenProgramAccount(splTokenProgram).
		SetSplAtaProgramAccount(splAtaProgram).
		SetAuthorizationRulesProgramAccount(authorizationRulesProgram).
		SetAuthorizationRulesAccount(authorizationRules)
}

// SetMintArgs sets the "mintArgs" parameter.
func (obj *Mint) SetMintArgs(mintArgs MintArgs) *Mint {
	obj.MintArgs = &mintArgs
	return obj
}

// SetTokenAccount sets the "token" parameter.
// Token or Associated Token account
func (obj *Mint) SetTokenAccount(token common.PublicKey) *Mint {
	obj.AccountMetaSlice[0] = common.Meta(token).WRITE()
	return obj
}

// GetTokenAccount gets the "token" parameter.
// Token or Associated Token account
func (obj *Mint) GetTokenAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetTokenOwnerAccount sets the "tokenOwner" parameter.
// Owner of the token account
func (obj *Mint) SetTokenOwnerAccount(tokenOwner common.PublicKey) *Mint {
	obj.AccountMetaSlice[1] = common.Meta(tokenOwner)
	return obj
}

// GetTokenOwnerAccount gets the "tokenOwner" parameter.
// Owner of the token account
func (obj *Mint) GetTokenOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account (pda of ['metadata', program id, mint id])
func (obj *Mint) SetMetadataAccount(metadata common.PublicKey) *Mint {
	obj.AccountMetaSlice[2] = common.Meta(metadata)
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account (pda of ['metadata', program id, mint id])
func (obj *Mint) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMasterEditionAccount sets the "masterEdition" parameter.
// Master Edition account
func (obj *Mint) SetMasterEditionAccount(masterEdition common.PublicKey) *Mint {
	obj.AccountMetaSlice[3] = common.Meta(masterEdition).WRITE()
	return obj
}

// GetMasterEditionAccount gets the "masterEdition" parameter.
// Master Edition account
func (obj *Mint) GetMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetTokenRecordAccount sets the "tokenRecord" parameter.
// Token record account
func (obj *Mint) SetTokenRecordAccount(tokenRecord common.PublicKey) *Mint {
	obj.AccountMetaSlice[4] = common.Meta(tokenRecord).WRITE()
	return obj
}

// GetTokenRecordAccount gets the "tokenRecord" parameter.
// Token record account
func (obj *Mint) GetTokenRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetMintAccount sets the "mint" parameter.
// Mint of token asset
func (obj *Mint) SetMintAccount(mint common.PublicKey) *Mint {
	obj.AccountMetaSlice[5] = common.Meta(mint).WRITE()
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of token asset
func (obj *Mint) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetAuthorityAccount sets the "authority" parameter.
// (Mint or Update) authority
func (obj *Mint) SetAuthorityAccount(authority common.PublicKey) *Mint {
	obj.AccountMetaSlice[6] = common.Meta(authority).SIGNER()
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// (Mint or Update) authority
func (obj *Mint) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetDelegateRecordAccount sets the "delegateRecord" parameter.
// Metadata delegate record
func (obj *Mint) SetDelegateRecordAccount(delegateRecord common.PublicKey) *Mint {
	obj.AccountMetaSlice[7] = common.Meta(delegateRecord)
	return obj
}

// GetDelegateRecordAccount gets the "delegateRecord" parameter.
// Metadata delegate record
func (obj *Mint) GetDelegateRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetPayerAccount sets the "payer" parameter.
// Payer
func (obj *Mint) SetPayerAccount(payer common.PublicKey) *Mint {
	obj.AccountMetaSlice[8] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Payer
func (obj *Mint) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *Mint) SetSystemProgramAccount(systemProgram common.PublicKey) *Mint {
	obj.AccountMetaSlice[9] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *Mint) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Mint) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey) *Mint {
	obj.AccountMetaSlice[10] = common.Meta(sysvarInstructions)
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Mint) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token program
func (obj *Mint) SetSplTokenProgramAccount(splTokenProgram common.PublicKey) *Mint {
	obj.AccountMetaSlice[11] = common.Meta(splTokenProgram)
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token program
func (obj *Mint) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

// SetSplAtaProgramAccount sets the "splAtaProgram" parameter.
// SPL Associated Token Account program
func (obj *Mint) SetSplAtaProgramAccount(splAtaProgram common.PublicKey) *Mint {
	obj.AccountMetaSlice[12] = common.Meta(splAtaProgram)
	return obj
}

// GetSplAtaProgramAccount gets the "splAtaProgram" parameter.
// SPL Associated Token Account program
func (obj *Mint) GetSplAtaProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(12)
}

// SetAuthorizationRulesProgramAccount sets the "authorizationRulesProgram" parameter.
// Token Authorization Rules program
func (obj *Mint) SetAuthorizationRulesProgramAccount(authorizationRulesProgram common.PublicKey) *Mint {
	obj.AccountMetaSlice[13] = common.Meta(authorizationRulesProgram)
	return obj
}

// GetAuthorizationRulesProgramAccount gets the "authorizationRulesProgram" parameter.
// Token Authorization Rules program
func (obj *Mint) GetAuthorizationRulesProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(13)
}

// SetAuthorizationRulesAccount sets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Mint) SetAuthorizationRulesAccount(authorizationRules common.PublicKey, multiSigners ...common.PublicKey) *Mint {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[14] = common.Meta(authorizationRules)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[14] = common.Meta(authorizationRules)
	}
	return obj
}

// GetAuthorizationRulesAccount gets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Mint) GetAuthorizationRulesAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(14)
}

func (obj *Mint) SetProgramId(programId *common.PublicKey) *Mint {
	obj._programId = programId
	return obj
}

func (obj *Mint) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Mint}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Mint) Validate() error {
	if obj.MintArgs == nil {
		return errors.New("[Mint] mintArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Mint] accounts.token is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Mint] accounts.tokenOwner is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Mint] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Mint] accounts.masterEdition is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Mint] accounts.tokenRecord is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Mint] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Mint] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[Mint] accounts.delegateRecord is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[Mint] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[Mint] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[Mint] accounts.sysvarInstructions is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[Mint] accounts.splTokenProgram is not set")
	}
	if obj.AccountMetaSlice[12] == nil {
		return errors.New("[Mint] accounts.splAtaProgram is not set")
	}
	if obj.AccountMetaSlice[13] == nil {
		return errors.New("[Mint] accounts.authorizationRulesProgram is not set")
	}
	if obj.AccountMetaSlice[14] == nil {
		return errors.New("[Mint] accounts.authorizationRules is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Mint) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Mint) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.MintArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Mint) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.MintArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Mint) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Mint")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("MintArgs", *obj.MintArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=15]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                    token", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("               tokenOwner", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                 metadata", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("            masterEdition", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("              tokenRecord", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                     mint", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("                authority", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("           delegateRecord", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("                    payer", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("            systemProgram", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("       sysvarInstructions", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("          splTokenProgram", obj.AccountMetaSlice.Get(11)))
						accountsBranch.Child(common.FormatMeta("            splAtaProgram", obj.AccountMetaSlice.Get(12)))
						accountsBranch.Child(common.FormatMeta("authorizationRulesProgram", obj.AccountMetaSlice.Get(13)))
						accountsBranch.Child(common.FormatMeta("       authorizationRules", obj.AccountMetaSlice.Get(14)))
					})
				})
		})
}

// Delegate Instruction
type Delegate struct {
	DelegateArgs *DelegateArgs
	// [0] = [WRITE] delegateRecord `Delegate record account`
	// [1] = [] delegate `Owner of the delegated account`
	// [2] = [WRITE] metadata `Metadata account`
	// [3] = [] masterEdition `Master Edition account`
	// [4] = [WRITE] tokenRecord `Token record account`
	// [5] = [] mint `Mint of metadata`
	// [6] = [WRITE] token `Token account of mint`
	// [7] = [SIGNER] authority `Update authority or token owner`
	// [8] = [WRITE, SIGNER] payer `Payer`
	// [9] = [] systemProgram `System Program`
	// [10] = [] sysvarInstructions `Instructions sysvar account`
	// [11] = [] splTokenProgram `SPL Token Program`
	// [12] = [] authorizationRulesProgram `Token Authorization Rules Program`
	// [13] = [] authorizationRules `Token Authorization Rules account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewDelegateInstructionBuilder creates a new `Delegate` instruction builder.
func NewDelegateInstructionBuilder() *Delegate {
	return &Delegate{
		AccountMetaSlice: make(common.AccountMetaSlice, 14),
	}
}

// NewDelegateInstruction
//
// Parameters:
//
//	delegateArgs:
//	delegateRecord: Delegate record account
//	delegate: Owner of the delegated account
//	metadata: Metadata account
//	masterEdition: Master Edition account
//	tokenRecord: Token record account
//	mint: Mint of metadata
//	token: Token account of mint
//	authority: Update authority or token owner
//	payer: Payer
//	systemProgram: System Program
//	sysvarInstructions: Instructions sysvar account
//	splTokenProgram: SPL Token Program
//	authorizationRulesProgram: Token Authorization Rules Program
//	authorizationRules: Token Authorization Rules account
func NewDelegateInstruction(
	delegateArgs DelegateArgs,
	delegateRecord common.PublicKey,
	delegate common.PublicKey,
	metadata common.PublicKey,
	masterEdition common.PublicKey,
	tokenRecord common.PublicKey,
	mint common.PublicKey,
	token common.PublicKey,
	authority common.PublicKey,
	payer common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
	splTokenProgram common.PublicKey,
	authorizationRulesProgram common.PublicKey,
	authorizationRules common.PublicKey,
) *Delegate {
	return NewDelegateInstructionBuilder().
		SetDelegateArgs(delegateArgs).
		SetDelegateRecordAccount(delegateRecord).
		SetDelegateAccount(delegate).
		SetMetadataAccount(metadata).
		SetMasterEditionAccount(masterEdition).
		SetTokenRecordAccount(tokenRecord).
		SetMintAccount(mint).
		SetTokenAccount(token).
		SetAuthorityAccount(authority).
		SetPayerAccount(payer).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions).
		SetSplTokenProgramAccount(splTokenProgram).
		SetAuthorizationRulesProgramAccount(authorizationRulesProgram).
		SetAuthorizationRulesAccount(authorizationRules)
}

// SetDelegateArgs sets the "delegateArgs" parameter.
func (obj *Delegate) SetDelegateArgs(delegateArgs DelegateArgs) *Delegate {
	obj.DelegateArgs = &delegateArgs
	return obj
}

// SetDelegateRecordAccount sets the "delegateRecord" parameter.
// Delegate record account
func (obj *Delegate) SetDelegateRecordAccount(delegateRecord common.PublicKey) *Delegate {
	obj.AccountMetaSlice[0] = common.Meta(delegateRecord).WRITE()
	return obj
}

// GetDelegateRecordAccount gets the "delegateRecord" parameter.
// Delegate record account
func (obj *Delegate) GetDelegateRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetDelegateAccount sets the "delegate" parameter.
// Owner of the delegated account
func (obj *Delegate) SetDelegateAccount(delegate common.PublicKey) *Delegate {
	obj.AccountMetaSlice[1] = common.Meta(delegate)
	return obj
}

// GetDelegateAccount gets the "delegate" parameter.
// Owner of the delegated account
func (obj *Delegate) GetDelegateAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *Delegate) SetMetadataAccount(metadata common.PublicKey) *Delegate {
	obj.AccountMetaSlice[2] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *Delegate) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMasterEditionAccount sets the "masterEdition" parameter.
// Master Edition account
func (obj *Delegate) SetMasterEditionAccount(masterEdition common.PublicKey) *Delegate {
	obj.AccountMetaSlice[3] = common.Meta(masterEdition)
	return obj
}

// GetMasterEditionAccount gets the "masterEdition" parameter.
// Master Edition account
func (obj *Delegate) GetMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetTokenRecordAccount sets the "tokenRecord" parameter.
// Token record account
func (obj *Delegate) SetTokenRecordAccount(tokenRecord common.PublicKey) *Delegate {
	obj.AccountMetaSlice[4] = common.Meta(tokenRecord).WRITE()
	return obj
}

// GetTokenRecordAccount gets the "tokenRecord" parameter.
// Token record account
func (obj *Delegate) GetTokenRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetMintAccount sets the "mint" parameter.
// Mint of metadata
func (obj *Delegate) SetMintAccount(mint common.PublicKey) *Delegate {
	obj.AccountMetaSlice[5] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of metadata
func (obj *Delegate) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetTokenAccount sets the "token" parameter.
// Token account of mint
func (obj *Delegate) SetTokenAccount(token common.PublicKey) *Delegate {
	obj.AccountMetaSlice[6] = common.Meta(token).WRITE()
	return obj
}

// GetTokenAccount gets the "token" parameter.
// Token account of mint
func (obj *Delegate) GetTokenAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetAuthorityAccount sets the "authority" parameter.
// Update authority or token owner
func (obj *Delegate) SetAuthorityAccount(authority common.PublicKey) *Delegate {
	obj.AccountMetaSlice[7] = common.Meta(authority).SIGNER()
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Update authority or token owner
func (obj *Delegate) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetPayerAccount sets the "payer" parameter.
// Payer
func (obj *Delegate) SetPayerAccount(payer common.PublicKey) *Delegate {
	obj.AccountMetaSlice[8] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Payer
func (obj *Delegate) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System Program
func (obj *Delegate) SetSystemProgramAccount(systemProgram common.PublicKey) *Delegate {
	obj.AccountMetaSlice[9] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System Program
func (obj *Delegate) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Delegate) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey) *Delegate {
	obj.AccountMetaSlice[10] = common.Meta(sysvarInstructions)
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Delegate) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Delegate) SetSplTokenProgramAccount(splTokenProgram common.PublicKey) *Delegate {
	obj.AccountMetaSlice[11] = common.Meta(splTokenProgram)
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Delegate) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

// SetAuthorizationRulesProgramAccount sets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Delegate) SetAuthorizationRulesProgramAccount(authorizationRulesProgram common.PublicKey) *Delegate {
	obj.AccountMetaSlice[12] = common.Meta(authorizationRulesProgram)
	return obj
}

// GetAuthorizationRulesProgramAccount gets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Delegate) GetAuthorizationRulesProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(12)
}

// SetAuthorizationRulesAccount sets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Delegate) SetAuthorizationRulesAccount(authorizationRules common.PublicKey, multiSigners ...common.PublicKey) *Delegate {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[13] = common.Meta(authorizationRules)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[13] = common.Meta(authorizationRules)
	}
	return obj
}

// GetAuthorizationRulesAccount gets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Delegate) GetAuthorizationRulesAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(13)
}

func (obj *Delegate) SetProgramId(programId *common.PublicKey) *Delegate {
	obj._programId = programId
	return obj
}

func (obj *Delegate) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Delegate}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Delegate) Validate() error {
	if obj.DelegateArgs == nil {
		return errors.New("[Delegate] delegateArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Delegate] accounts.delegateRecord is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Delegate] accounts.delegate is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Delegate] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Delegate] accounts.masterEdition is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Delegate] accounts.tokenRecord is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Delegate] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Delegate] accounts.token is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[Delegate] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[Delegate] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[Delegate] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[Delegate] accounts.sysvarInstructions is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[Delegate] accounts.splTokenProgram is not set")
	}
	if obj.AccountMetaSlice[12] == nil {
		return errors.New("[Delegate] accounts.authorizationRulesProgram is not set")
	}
	if obj.AccountMetaSlice[13] == nil {
		return errors.New("[Delegate] accounts.authorizationRules is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Delegate) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Delegate) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.DelegateArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Delegate) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.DelegateArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Delegate) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Delegate")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("DelegateArgs", *obj.DelegateArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=14]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("           delegateRecord", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("                 delegate", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                 metadata", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("            masterEdition", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("              tokenRecord", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                     mint", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("                    token", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("                authority", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("                    payer", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("            systemProgram", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("       sysvarInstructions", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("          splTokenProgram", obj.AccountMetaSlice.Get(11)))
						accountsBranch.Child(common.FormatMeta("authorizationRulesProgram", obj.AccountMetaSlice.Get(12)))
						accountsBranch.Child(common.FormatMeta("       authorizationRules", obj.AccountMetaSlice.Get(13)))
					})
				})
		})
}

// Revoke Instruction
type Revoke struct {
	RevokeArgs *RevokeArgs
	// [0] = [WRITE] delegateRecord `Delegate record account`
	// [1] = [] delegate `Owner of the delegated account`
	// [2] = [WRITE] metadata `Metadata account`
	// [3] = [] masterEdition `Master Edition account`
	// [4] = [WRITE] tokenRecord `Token record account`
	// [5] = [] mint `Mint of metadata`
	// [6] = [WRITE] token `Token account of mint`
	// [7] = [SIGNER] authority `Update authority or token owner`
	// [8] = [WRITE, SIGNER] payer `Payer`
	// [9] = [] systemProgram `System Program`
	// [10] = [] sysvarInstructions `Instructions sysvar account`
	// [11] = [] splTokenProgram `SPL Token Program`
	// [12] = [] authorizationRulesProgram `Token Authorization Rules Program`
	// [13] = [] authorizationRules `Token Authorization Rules account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewRevokeInstructionBuilder creates a new `Revoke` instruction builder.
func NewRevokeInstructionBuilder() *Revoke {
	return &Revoke{
		AccountMetaSlice: make(common.AccountMetaSlice, 14),
	}
}

// NewRevokeInstruction
//
// Parameters:
//
//	revokeArgs:
//	delegateRecord: Delegate record account
//	delegate: Owner of the delegated account
//	metadata: Metadata account
//	masterEdition: Master Edition account
//	tokenRecord: Token record account
//	mint: Mint of metadata
//	token: Token account of mint
//	authority: Update authority or token owner
//	payer: Payer
//	systemProgram: System Program
//	sysvarInstructions: Instructions sysvar account
//	splTokenProgram: SPL Token Program
//	authorizationRulesProgram: Token Authorization Rules Program
//	authorizationRules: Token Authorization Rules account
func NewRevokeInstruction(
	revokeArgs RevokeArgs,
	delegateRecord common.PublicKey,
	delegate common.PublicKey,
	metadata common.PublicKey,
	masterEdition common.PublicKey,
	tokenRecord common.PublicKey,
	mint common.PublicKey,
	token common.PublicKey,
	authority common.PublicKey,
	payer common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
	splTokenProgram common.PublicKey,
	authorizationRulesProgram common.PublicKey,
	authorizationRules common.PublicKey,
) *Revoke {
	return NewRevokeInstructionBuilder().
		SetRevokeArgs(revokeArgs).
		SetDelegateRecordAccount(delegateRecord).
		SetDelegateAccount(delegate).
		SetMetadataAccount(metadata).
		SetMasterEditionAccount(masterEdition).
		SetTokenRecordAccount(tokenRecord).
		SetMintAccount(mint).
		SetTokenAccount(token).
		SetAuthorityAccount(authority).
		SetPayerAccount(payer).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions).
		SetSplTokenProgramAccount(splTokenProgram).
		SetAuthorizationRulesProgramAccount(authorizationRulesProgram).
		SetAuthorizationRulesAccount(authorizationRules)
}

// SetRevokeArgs sets the "revokeArgs" parameter.
func (obj *Revoke) SetRevokeArgs(revokeArgs RevokeArgs) *Revoke {
	obj.RevokeArgs = &revokeArgs
	return obj
}

// SetDelegateRecordAccount sets the "delegateRecord" parameter.
// Delegate record account
func (obj *Revoke) SetDelegateRecordAccount(delegateRecord common.PublicKey) *Revoke {
	obj.AccountMetaSlice[0] = common.Meta(delegateRecord).WRITE()
	return obj
}

// GetDelegateRecordAccount gets the "delegateRecord" parameter.
// Delegate record account
func (obj *Revoke) GetDelegateRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetDelegateAccount sets the "delegate" parameter.
// Owner of the delegated account
func (obj *Revoke) SetDelegateAccount(delegate common.PublicKey) *Revoke {
	obj.AccountMetaSlice[1] = common.Meta(delegate)
	return obj
}

// GetDelegateAccount gets the "delegate" parameter.
// Owner of the delegated account
func (obj *Revoke) GetDelegateAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *Revoke) SetMetadataAccount(metadata common.PublicKey) *Revoke {
	obj.AccountMetaSlice[2] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *Revoke) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMasterEditionAccount sets the "masterEdition" parameter.
// Master Edition account
func (obj *Revoke) SetMasterEditionAccount(masterEdition common.PublicKey) *Revoke {
	obj.AccountMetaSlice[3] = common.Meta(masterEdition)
	return obj
}

// GetMasterEditionAccount gets the "masterEdition" parameter.
// Master Edition account
func (obj *Revoke) GetMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetTokenRecordAccount sets the "tokenRecord" parameter.
// Token record account
func (obj *Revoke) SetTokenRecordAccount(tokenRecord common.PublicKey) *Revoke {
	obj.AccountMetaSlice[4] = common.Meta(tokenRecord).WRITE()
	return obj
}

// GetTokenRecordAccount gets the "tokenRecord" parameter.
// Token record account
func (obj *Revoke) GetTokenRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetMintAccount sets the "mint" parameter.
// Mint of metadata
func (obj *Revoke) SetMintAccount(mint common.PublicKey) *Revoke {
	obj.AccountMetaSlice[5] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of metadata
func (obj *Revoke) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetTokenAccount sets the "token" parameter.
// Token account of mint
func (obj *Revoke) SetTokenAccount(token common.PublicKey) *Revoke {
	obj.AccountMetaSlice[6] = common.Meta(token).WRITE()
	return obj
}

// GetTokenAccount gets the "token" parameter.
// Token account of mint
func (obj *Revoke) GetTokenAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetAuthorityAccount sets the "authority" parameter.
// Update authority or token owner
func (obj *Revoke) SetAuthorityAccount(authority common.PublicKey) *Revoke {
	obj.AccountMetaSlice[7] = common.Meta(authority).SIGNER()
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Update authority or token owner
func (obj *Revoke) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetPayerAccount sets the "payer" parameter.
// Payer
func (obj *Revoke) SetPayerAccount(payer common.PublicKey) *Revoke {
	obj.AccountMetaSlice[8] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Payer
func (obj *Revoke) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System Program
func (obj *Revoke) SetSystemProgramAccount(systemProgram common.PublicKey) *Revoke {
	obj.AccountMetaSlice[9] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System Program
func (obj *Revoke) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Revoke) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey) *Revoke {
	obj.AccountMetaSlice[10] = common.Meta(sysvarInstructions)
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Revoke) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Revoke) SetSplTokenProgramAccount(splTokenProgram common.PublicKey) *Revoke {
	obj.AccountMetaSlice[11] = common.Meta(splTokenProgram)
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Revoke) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

// SetAuthorizationRulesProgramAccount sets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Revoke) SetAuthorizationRulesProgramAccount(authorizationRulesProgram common.PublicKey) *Revoke {
	obj.AccountMetaSlice[12] = common.Meta(authorizationRulesProgram)
	return obj
}

// GetAuthorizationRulesProgramAccount gets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Revoke) GetAuthorizationRulesProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(12)
}

// SetAuthorizationRulesAccount sets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Revoke) SetAuthorizationRulesAccount(authorizationRules common.PublicKey, multiSigners ...common.PublicKey) *Revoke {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[13] = common.Meta(authorizationRules)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[13] = common.Meta(authorizationRules)
	}
	return obj
}

// GetAuthorizationRulesAccount gets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Revoke) GetAuthorizationRulesAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(13)
}

func (obj *Revoke) SetProgramId(programId *common.PublicKey) *Revoke {
	obj._programId = programId
	return obj
}

func (obj *Revoke) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Revoke}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Revoke) Validate() error {
	if obj.RevokeArgs == nil {
		return errors.New("[Revoke] revokeArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Revoke] accounts.delegateRecord is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Revoke] accounts.delegate is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Revoke] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Revoke] accounts.masterEdition is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Revoke] accounts.tokenRecord is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Revoke] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Revoke] accounts.token is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[Revoke] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[Revoke] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[Revoke] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[Revoke] accounts.sysvarInstructions is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[Revoke] accounts.splTokenProgram is not set")
	}
	if obj.AccountMetaSlice[12] == nil {
		return errors.New("[Revoke] accounts.authorizationRulesProgram is not set")
	}
	if obj.AccountMetaSlice[13] == nil {
		return errors.New("[Revoke] accounts.authorizationRules is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Revoke) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Revoke) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.RevokeArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Revoke) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.RevokeArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Revoke) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Revoke")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("RevokeArgs", *obj.RevokeArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=14]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("           delegateRecord", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("                 delegate", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                 metadata", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("            masterEdition", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("              tokenRecord", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                     mint", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("                    token", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("                authority", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("                    payer", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("            systemProgram", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("       sysvarInstructions", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("          splTokenProgram", obj.AccountMetaSlice.Get(11)))
						accountsBranch.Child(common.FormatMeta("authorizationRulesProgram", obj.AccountMetaSlice.Get(12)))
						accountsBranch.Child(common.FormatMeta("       authorizationRules", obj.AccountMetaSlice.Get(13)))
					})
				})
		})
}

// Lock Instruction
type Lock struct {
	LockArgs *LockArgs
	// [0] = [SIGNER] authority `Delegate or freeze authority`
	// [1] = [] tokenOwner `Token owner account`
	// [2] = [WRITE] token `Token account`
	// [3] = [] mint `Mint account`
	// [4] = [WRITE] metadata `Metadata account`
	// [5] = [] edition `Edition account`
	// [6] = [WRITE] tokenRecord `Token record account`
	// [7] = [WRITE, SIGNER] payer `Payer`
	// [8] = [] systemProgram `System program`
	// [9] = [] sysvarInstructions `System program`
	// [10] = [] splTokenProgram `SPL Token Program`
	// [11] = [] authorizationRulesProgram `Token Authorization Rules Program`
	// [12] = [] authorizationRules `Token Authorization Rules account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewLockInstructionBuilder creates a new `Lock` instruction builder.
func NewLockInstructionBuilder() *Lock {
	return &Lock{
		AccountMetaSlice: make(common.AccountMetaSlice, 13),
	}
}

// NewLockInstruction
//
// Parameters:
//
//	lockArgs:
//	authority: Delegate or freeze authority
//	tokenOwner: Token owner account
//	token: Token account
//	mint: Mint account
//	metadata: Metadata account
//	edition: Edition account
//	tokenRecord: Token record account
//	payer: Payer
//	systemProgram: System program
//	sysvarInstructions: System program
//	splTokenProgram: SPL Token Program
//	authorizationRulesProgram: Token Authorization Rules Program
//	authorizationRules: Token Authorization Rules account
func NewLockInstruction(
	lockArgs LockArgs,
	authority common.PublicKey,
	tokenOwner common.PublicKey,
	token common.PublicKey,
	mint common.PublicKey,
	metadata common.PublicKey,
	edition common.PublicKey,
	tokenRecord common.PublicKey,
	payer common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
	splTokenProgram common.PublicKey,
	authorizationRulesProgram common.PublicKey,
	authorizationRules common.PublicKey,
) *Lock {
	return NewLockInstructionBuilder().
		SetLockArgs(lockArgs).
		SetAuthorityAccount(authority).
		SetTokenOwnerAccount(tokenOwner).
		SetTokenAccount(token).
		SetMintAccount(mint).
		SetMetadataAccount(metadata).
		SetEditionAccount(edition).
		SetTokenRecordAccount(tokenRecord).
		SetPayerAccount(payer).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions).
		SetSplTokenProgramAccount(splTokenProgram).
		SetAuthorizationRulesProgramAccount(authorizationRulesProgram).
		SetAuthorizationRulesAccount(authorizationRules)
}

// SetLockArgs sets the "lockArgs" parameter.
func (obj *Lock) SetLockArgs(lockArgs LockArgs) *Lock {
	obj.LockArgs = &lockArgs
	return obj
}

// SetAuthorityAccount sets the "authority" parameter.
// Delegate or freeze authority
func (obj *Lock) SetAuthorityAccount(authority common.PublicKey) *Lock {
	obj.AccountMetaSlice[0] = common.Meta(authority).SIGNER()
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Delegate or freeze authority
func (obj *Lock) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetTokenOwnerAccount sets the "tokenOwner" parameter.
// Token owner account
func (obj *Lock) SetTokenOwnerAccount(tokenOwner common.PublicKey) *Lock {
	obj.AccountMetaSlice[1] = common.Meta(tokenOwner)
	return obj
}

// GetTokenOwnerAccount gets the "tokenOwner" parameter.
// Token owner account
func (obj *Lock) GetTokenOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetTokenAccount sets the "token" parameter.
// Token account
func (obj *Lock) SetTokenAccount(token common.PublicKey) *Lock {
	obj.AccountMetaSlice[2] = common.Meta(token).WRITE()
	return obj
}

// GetTokenAccount gets the "token" parameter.
// Token account
func (obj *Lock) GetTokenAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMintAccount sets the "mint" parameter.
// Mint account
func (obj *Lock) SetMintAccount(mint common.PublicKey) *Lock {
	obj.AccountMetaSlice[3] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint account
func (obj *Lock) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *Lock) SetMetadataAccount(metadata common.PublicKey) *Lock {
	obj.AccountMetaSlice[4] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *Lock) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetEditionAccount sets the "edition" parameter.
// Edition account
func (obj *Lock) SetEditionAccount(edition common.PublicKey) *Lock {
	obj.AccountMetaSlice[5] = common.Meta(edition)
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Edition account
func (obj *Lock) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetTokenRecordAccount sets the "tokenRecord" parameter.
// Token record account
func (obj *Lock) SetTokenRecordAccount(tokenRecord common.PublicKey) *Lock {
	obj.AccountMetaSlice[6] = common.Meta(tokenRecord).WRITE()
	return obj
}

// GetTokenRecordAccount gets the "tokenRecord" parameter.
// Token record account
func (obj *Lock) GetTokenRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetPayerAccount sets the "payer" parameter.
// Payer
func (obj *Lock) SetPayerAccount(payer common.PublicKey) *Lock {
	obj.AccountMetaSlice[7] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Payer
func (obj *Lock) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *Lock) SetSystemProgramAccount(systemProgram common.PublicKey) *Lock {
	obj.AccountMetaSlice[8] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *Lock) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// System program
func (obj *Lock) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey) *Lock {
	obj.AccountMetaSlice[9] = common.Meta(sysvarInstructions)
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// System program
func (obj *Lock) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Lock) SetSplTokenProgramAccount(splTokenProgram common.PublicKey) *Lock {
	obj.AccountMetaSlice[10] = common.Meta(splTokenProgram)
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Lock) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetAuthorizationRulesProgramAccount sets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Lock) SetAuthorizationRulesProgramAccount(authorizationRulesProgram common.PublicKey) *Lock {
	obj.AccountMetaSlice[11] = common.Meta(authorizationRulesProgram)
	return obj
}

// GetAuthorizationRulesProgramAccount gets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Lock) GetAuthorizationRulesProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

// SetAuthorizationRulesAccount sets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Lock) SetAuthorizationRulesAccount(authorizationRules common.PublicKey, multiSigners ...common.PublicKey) *Lock {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[12] = common.Meta(authorizationRules)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[12] = common.Meta(authorizationRules)
	}
	return obj
}

// GetAuthorizationRulesAccount gets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Lock) GetAuthorizationRulesAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(12)
}

func (obj *Lock) SetProgramId(programId *common.PublicKey) *Lock {
	obj._programId = programId
	return obj
}

func (obj *Lock) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Lock}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Lock) Validate() error {
	if obj.LockArgs == nil {
		return errors.New("[Lock] lockArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Lock] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Lock] accounts.tokenOwner is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Lock] accounts.token is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Lock] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Lock] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Lock] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Lock] accounts.tokenRecord is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[Lock] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[Lock] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[Lock] accounts.sysvarInstructions is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[Lock] accounts.splTokenProgram is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[Lock] accounts.authorizationRulesProgram is not set")
	}
	if obj.AccountMetaSlice[12] == nil {
		return errors.New("[Lock] accounts.authorizationRules is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Lock) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Lock) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.LockArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Lock) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.LockArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Lock) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Lock")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("LockArgs", *obj.LockArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=13]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                authority", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("               tokenOwner", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                    token", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("                     mint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                 metadata", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                  edition", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("              tokenRecord", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("                    payer", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("            systemProgram", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("       sysvarInstructions", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("          splTokenProgram", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("authorizationRulesProgram", obj.AccountMetaSlice.Get(11)))
						accountsBranch.Child(common.FormatMeta("       authorizationRules", obj.AccountMetaSlice.Get(12)))
					})
				})
		})
}

// Unlock Instruction
type Unlock struct {
	UnlockArgs *UnlockArgs
	// [0] = [SIGNER] authority `Delegate or freeze authority`
	// [1] = [] tokenOwner `Token owner account`
	// [2] = [WRITE] token `Token account`
	// [3] = [] mint `Mint account`
	// [4] = [WRITE] metadata `Metadata account`
	// [5] = [] edition `Edition account`
	// [6] = [WRITE] tokenRecord `Token record account`
	// [7] = [WRITE, SIGNER] payer `Payer`
	// [8] = [] systemProgram `System program`
	// [9] = [] sysvarInstructions `System program`
	// [10] = [] splTokenProgram `SPL Token Program`
	// [11] = [] authorizationRulesProgram `Token Authorization Rules Program`
	// [12] = [] authorizationRules `Token Authorization Rules account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewUnlockInstructionBuilder creates a new `Unlock` instruction builder.
func NewUnlockInstructionBuilder() *Unlock {
	return &Unlock{
		AccountMetaSlice: make(common.AccountMetaSlice, 13),
	}
}

// NewUnlockInstruction
//
// Parameters:
//
//	unlockArgs:
//	authority: Delegate or freeze authority
//	tokenOwner: Token owner account
//	token: Token account
//	mint: Mint account
//	metadata: Metadata account
//	edition: Edition account
//	tokenRecord: Token record account
//	payer: Payer
//	systemProgram: System program
//	sysvarInstructions: System program
//	splTokenProgram: SPL Token Program
//	authorizationRulesProgram: Token Authorization Rules Program
//	authorizationRules: Token Authorization Rules account
func NewUnlockInstruction(
	unlockArgs UnlockArgs,
	authority common.PublicKey,
	tokenOwner common.PublicKey,
	token common.PublicKey,
	mint common.PublicKey,
	metadata common.PublicKey,
	edition common.PublicKey,
	tokenRecord common.PublicKey,
	payer common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
	splTokenProgram common.PublicKey,
	authorizationRulesProgram common.PublicKey,
	authorizationRules common.PublicKey,
) *Unlock {
	return NewUnlockInstructionBuilder().
		SetUnlockArgs(unlockArgs).
		SetAuthorityAccount(authority).
		SetTokenOwnerAccount(tokenOwner).
		SetTokenAccount(token).
		SetMintAccount(mint).
		SetMetadataAccount(metadata).
		SetEditionAccount(edition).
		SetTokenRecordAccount(tokenRecord).
		SetPayerAccount(payer).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions).
		SetSplTokenProgramAccount(splTokenProgram).
		SetAuthorizationRulesProgramAccount(authorizationRulesProgram).
		SetAuthorizationRulesAccount(authorizationRules)
}

// SetUnlockArgs sets the "unlockArgs" parameter.
func (obj *Unlock) SetUnlockArgs(unlockArgs UnlockArgs) *Unlock {
	obj.UnlockArgs = &unlockArgs
	return obj
}

// SetAuthorityAccount sets the "authority" parameter.
// Delegate or freeze authority
func (obj *Unlock) SetAuthorityAccount(authority common.PublicKey) *Unlock {
	obj.AccountMetaSlice[0] = common.Meta(authority).SIGNER()
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Delegate or freeze authority
func (obj *Unlock) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetTokenOwnerAccount sets the "tokenOwner" parameter.
// Token owner account
func (obj *Unlock) SetTokenOwnerAccount(tokenOwner common.PublicKey) *Unlock {
	obj.AccountMetaSlice[1] = common.Meta(tokenOwner)
	return obj
}

// GetTokenOwnerAccount gets the "tokenOwner" parameter.
// Token owner account
func (obj *Unlock) GetTokenOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetTokenAccount sets the "token" parameter.
// Token account
func (obj *Unlock) SetTokenAccount(token common.PublicKey) *Unlock {
	obj.AccountMetaSlice[2] = common.Meta(token).WRITE()
	return obj
}

// GetTokenAccount gets the "token" parameter.
// Token account
func (obj *Unlock) GetTokenAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMintAccount sets the "mint" parameter.
// Mint account
func (obj *Unlock) SetMintAccount(mint common.PublicKey) *Unlock {
	obj.AccountMetaSlice[3] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint account
func (obj *Unlock) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *Unlock) SetMetadataAccount(metadata common.PublicKey) *Unlock {
	obj.AccountMetaSlice[4] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *Unlock) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetEditionAccount sets the "edition" parameter.
// Edition account
func (obj *Unlock) SetEditionAccount(edition common.PublicKey) *Unlock {
	obj.AccountMetaSlice[5] = common.Meta(edition)
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Edition account
func (obj *Unlock) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetTokenRecordAccount sets the "tokenRecord" parameter.
// Token record account
func (obj *Unlock) SetTokenRecordAccount(tokenRecord common.PublicKey) *Unlock {
	obj.AccountMetaSlice[6] = common.Meta(tokenRecord).WRITE()
	return obj
}

// GetTokenRecordAccount gets the "tokenRecord" parameter.
// Token record account
func (obj *Unlock) GetTokenRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetPayerAccount sets the "payer" parameter.
// Payer
func (obj *Unlock) SetPayerAccount(payer common.PublicKey) *Unlock {
	obj.AccountMetaSlice[7] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Payer
func (obj *Unlock) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *Unlock) SetSystemProgramAccount(systemProgram common.PublicKey) *Unlock {
	obj.AccountMetaSlice[8] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *Unlock) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// System program
func (obj *Unlock) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey) *Unlock {
	obj.AccountMetaSlice[9] = common.Meta(sysvarInstructions)
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// System program
func (obj *Unlock) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Unlock) SetSplTokenProgramAccount(splTokenProgram common.PublicKey) *Unlock {
	obj.AccountMetaSlice[10] = common.Meta(splTokenProgram)
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Unlock) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetAuthorizationRulesProgramAccount sets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Unlock) SetAuthorizationRulesProgramAccount(authorizationRulesProgram common.PublicKey) *Unlock {
	obj.AccountMetaSlice[11] = common.Meta(authorizationRulesProgram)
	return obj
}

// GetAuthorizationRulesProgramAccount gets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Unlock) GetAuthorizationRulesProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

// SetAuthorizationRulesAccount sets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Unlock) SetAuthorizationRulesAccount(authorizationRules common.PublicKey, multiSigners ...common.PublicKey) *Unlock {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[12] = common.Meta(authorizationRules)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[12] = common.Meta(authorizationRules)
	}
	return obj
}

// GetAuthorizationRulesAccount gets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Unlock) GetAuthorizationRulesAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(12)
}

func (obj *Unlock) SetProgramId(programId *common.PublicKey) *Unlock {
	obj._programId = programId
	return obj
}

func (obj *Unlock) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Unlock}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Unlock) Validate() error {
	if obj.UnlockArgs == nil {
		return errors.New("[Unlock] unlockArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Unlock] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Unlock] accounts.tokenOwner is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Unlock] accounts.token is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Unlock] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Unlock] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Unlock] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Unlock] accounts.tokenRecord is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[Unlock] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[Unlock] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[Unlock] accounts.sysvarInstructions is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[Unlock] accounts.splTokenProgram is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[Unlock] accounts.authorizationRulesProgram is not set")
	}
	if obj.AccountMetaSlice[12] == nil {
		return errors.New("[Unlock] accounts.authorizationRules is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Unlock) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Unlock) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.UnlockArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Unlock) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.UnlockArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Unlock) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Unlock")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("UnlockArgs", *obj.UnlockArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=13]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                authority", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("               tokenOwner", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                    token", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("                     mint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                 metadata", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                  edition", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("              tokenRecord", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("                    payer", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("            systemProgram", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("       sysvarInstructions", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("          splTokenProgram", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("authorizationRulesProgram", obj.AccountMetaSlice.Get(11)))
						accountsBranch.Child(common.FormatMeta("       authorizationRules", obj.AccountMetaSlice.Get(12)))
					})
				})
		})
}

// Migrate Instruction
type Migrate struct {
	// [0] = [WRITE] metadata `Metadata account`
	// [1] = [WRITE] edition `Edition account`
	// [2] = [WRITE] token `Token account`
	// [3] = [] tokenOwner `Token account owner`
	// [4] = [] mint `Mint account`
	// [5] = [WRITE, SIGNER] payer `Payer`
	// [6] = [SIGNER] authority `Update authority`
	// [7] = [] collectionMetadata `Collection metadata account`
	// [8] = [] delegateRecord `Delegate record account`
	// [9] = [WRITE] tokenRecord `Token record account`
	// [10] = [] systemProgram `System program`
	// [11] = [] sysvarInstructions `Instruction sysvar account`
	// [12] = [] splTokenProgram `SPL Token Program`
	// [13] = [] authorizationRulesProgram `Token Authorization Rules Program`
	// [14] = [] authorizationRules `Token Authorization Rules account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewMigrateInstructionBuilder creates a new `Migrate` instruction builder.
func NewMigrateInstructionBuilder() *Migrate {
	return &Migrate{
		AccountMetaSlice: make(common.AccountMetaSlice, 15),
	}
}

// NewMigrateInstruction
//
// Parameters:
//
//	metadata: Metadata account
//	edition: Edition account
//	token: Token account
//	tokenOwner: Token account owner
//	mint: Mint account
//	payer: Payer
//	authority: Update authority
//	collectionMetadata: Collection metadata account
//	delegateRecord: Delegate record account
//	tokenRecord: Token record account
//	systemProgram: System program
//	sysvarInstructions: Instruction sysvar account
//	splTokenProgram: SPL Token Program
//	authorizationRulesProgram: Token Authorization Rules Program
//	authorizationRules: Token Authorization Rules account
func NewMigrateInstruction(
	metadata common.PublicKey,
	edition common.PublicKey,
	token common.PublicKey,
	tokenOwner common.PublicKey,
	mint common.PublicKey,
	payer common.PublicKey,
	authority common.PublicKey,
	collectionMetadata common.PublicKey,
	delegateRecord common.PublicKey,
	tokenRecord common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
	splTokenProgram common.PublicKey,
	authorizationRulesProgram common.PublicKey,
	authorizationRules common.PublicKey,
) *Migrate {
	return NewMigrateInstructionBuilder().
		SetMetadataAccount(metadata).
		SetEditionAccount(edition).
		SetTokenAccount(token).
		SetTokenOwnerAccount(tokenOwner).
		SetMintAccount(mint).
		SetPayerAccount(payer).
		SetAuthorityAccount(authority).
		SetCollectionMetadataAccount(collectionMetadata).
		SetDelegateRecordAccount(delegateRecord).
		SetTokenRecordAccount(tokenRecord).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions).
		SetSplTokenProgramAccount(splTokenProgram).
		SetAuthorizationRulesProgramAccount(authorizationRulesProgram).
		SetAuthorizationRulesAccount(authorizationRules)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *Migrate) SetMetadataAccount(metadata common.PublicKey) *Migrate {
	obj.AccountMetaSlice[0] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *Migrate) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetEditionAccount sets the "edition" parameter.
// Edition account
func (obj *Migrate) SetEditionAccount(edition common.PublicKey) *Migrate {
	obj.AccountMetaSlice[1] = common.Meta(edition).WRITE()
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Edition account
func (obj *Migrate) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetTokenAccount sets the "token" parameter.
// Token account
func (obj *Migrate) SetTokenAccount(token common.PublicKey) *Migrate {
	obj.AccountMetaSlice[2] = common.Meta(token).WRITE()
	return obj
}

// GetTokenAccount gets the "token" parameter.
// Token account
func (obj *Migrate) GetTokenAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetTokenOwnerAccount sets the "tokenOwner" parameter.
// Token account owner
func (obj *Migrate) SetTokenOwnerAccount(tokenOwner common.PublicKey) *Migrate {
	obj.AccountMetaSlice[3] = common.Meta(tokenOwner)
	return obj
}

// GetTokenOwnerAccount gets the "tokenOwner" parameter.
// Token account owner
func (obj *Migrate) GetTokenOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetMintAccount sets the "mint" parameter.
// Mint account
func (obj *Migrate) SetMintAccount(mint common.PublicKey) *Migrate {
	obj.AccountMetaSlice[4] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint account
func (obj *Migrate) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetPayerAccount sets the "payer" parameter.
// Payer
func (obj *Migrate) SetPayerAccount(payer common.PublicKey) *Migrate {
	obj.AccountMetaSlice[5] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Payer
func (obj *Migrate) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetAuthorityAccount sets the "authority" parameter.
// Update authority
func (obj *Migrate) SetAuthorityAccount(authority common.PublicKey) *Migrate {
	obj.AccountMetaSlice[6] = common.Meta(authority).SIGNER()
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Update authority
func (obj *Migrate) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetCollectionMetadataAccount sets the "collectionMetadata" parameter.
// Collection metadata account
func (obj *Migrate) SetCollectionMetadataAccount(collectionMetadata common.PublicKey) *Migrate {
	obj.AccountMetaSlice[7] = common.Meta(collectionMetadata)
	return obj
}

// GetCollectionMetadataAccount gets the "collectionMetadata" parameter.
// Collection metadata account
func (obj *Migrate) GetCollectionMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetDelegateRecordAccount sets the "delegateRecord" parameter.
// Delegate record account
func (obj *Migrate) SetDelegateRecordAccount(delegateRecord common.PublicKey) *Migrate {
	obj.AccountMetaSlice[8] = common.Meta(delegateRecord)
	return obj
}

// GetDelegateRecordAccount gets the "delegateRecord" parameter.
// Delegate record account
func (obj *Migrate) GetDelegateRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetTokenRecordAccount sets the "tokenRecord" parameter.
// Token record account
func (obj *Migrate) SetTokenRecordAccount(tokenRecord common.PublicKey) *Migrate {
	obj.AccountMetaSlice[9] = common.Meta(tokenRecord).WRITE()
	return obj
}

// GetTokenRecordAccount gets the "tokenRecord" parameter.
// Token record account
func (obj *Migrate) GetTokenRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *Migrate) SetSystemProgramAccount(systemProgram common.PublicKey) *Migrate {
	obj.AccountMetaSlice[10] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *Migrate) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// Instruction sysvar account
func (obj *Migrate) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey) *Migrate {
	obj.AccountMetaSlice[11] = common.Meta(sysvarInstructions)
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// Instruction sysvar account
func (obj *Migrate) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Migrate) SetSplTokenProgramAccount(splTokenProgram common.PublicKey) *Migrate {
	obj.AccountMetaSlice[12] = common.Meta(splTokenProgram)
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Migrate) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(12)
}

// SetAuthorizationRulesProgramAccount sets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Migrate) SetAuthorizationRulesProgramAccount(authorizationRulesProgram common.PublicKey) *Migrate {
	obj.AccountMetaSlice[13] = common.Meta(authorizationRulesProgram)
	return obj
}

// GetAuthorizationRulesProgramAccount gets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Migrate) GetAuthorizationRulesProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(13)
}

// SetAuthorizationRulesAccount sets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Migrate) SetAuthorizationRulesAccount(authorizationRules common.PublicKey, multiSigners ...common.PublicKey) *Migrate {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[14] = common.Meta(authorizationRules)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[14] = common.Meta(authorizationRules)
	}
	return obj
}

// GetAuthorizationRulesAccount gets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Migrate) GetAuthorizationRulesAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(14)
}

func (obj *Migrate) SetProgramId(programId *common.PublicKey) *Migrate {
	obj._programId = programId
	return obj
}

func (obj *Migrate) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Migrate}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Migrate) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Migrate] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Migrate] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Migrate] accounts.token is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Migrate] accounts.tokenOwner is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Migrate] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Migrate] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Migrate] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[Migrate] accounts.collectionMetadata is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[Migrate] accounts.delegateRecord is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[Migrate] accounts.tokenRecord is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[Migrate] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[Migrate] accounts.sysvarInstructions is not set")
	}
	if obj.AccountMetaSlice[12] == nil {
		return errors.New("[Migrate] accounts.splTokenProgram is not set")
	}
	if obj.AccountMetaSlice[13] == nil {
		return errors.New("[Migrate] accounts.authorizationRulesProgram is not set")
	}
	if obj.AccountMetaSlice[14] == nil {
		return errors.New("[Migrate] accounts.authorizationRules is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Migrate) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Migrate) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *Migrate) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *Migrate) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Migrate")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=15]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                 metadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("                  edition", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                    token", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("               tokenOwner", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                     mint", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                    payer", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("                authority", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("       collectionMetadata", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("           delegateRecord", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("              tokenRecord", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("            systemProgram", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("       sysvarInstructions", obj.AccountMetaSlice.Get(11)))
						accountsBranch.Child(common.FormatMeta("          splTokenProgram", obj.AccountMetaSlice.Get(12)))
						accountsBranch.Child(common.FormatMeta("authorizationRulesProgram", obj.AccountMetaSlice.Get(13)))
						accountsBranch.Child(common.FormatMeta("       authorizationRules", obj.AccountMetaSlice.Get(14)))
					})
				})
		})
}

// Transfer Instruction
type Transfer struct {
	TransferArgs *TransferArgs
	// [0] = [WRITE] token `Token account`
	// [1] = [] tokenOwner `Token account owner`
	// [2] = [WRITE] destination `Destination token account`
	// [3] = [] destinationOwner `Destination token account owner`
	// [4] = [] mint `Mint of token asset`
	// [5] = [WRITE] metadata `Metadata (pda of ['metadata', program id, mint id])`
	// [6] = [] edition `Edition of token asset`
	// [7] = [WRITE] ownerTokenRecord `Owner token record account`
	// [8] = [WRITE] destinationTokenRecord `Destination token record account`
	// [9] = [SIGNER] authority `Transfer authority (token owner or delegate)`
	// [10] = [WRITE, SIGNER] payer `Payer`
	// [11] = [] systemProgram `System Program`
	// [12] = [] sysvarInstructions `Instructions sysvar account`
	// [13] = [] splTokenProgram `SPL Token Program`
	// [14] = [] splAtaProgram `SPL Associated Token Account program`
	// [15] = [] authorizationRulesProgram `Token Authorization Rules Program`
	// [16] = [] authorizationRules `Token Authorization Rules account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewTransferInstructionBuilder creates a new `Transfer` instruction builder.
func NewTransferInstructionBuilder() *Transfer {
	return &Transfer{
		AccountMetaSlice: make(common.AccountMetaSlice, 17),
	}
}

// NewTransferInstruction
//
// Parameters:
//
//	transferArgs:
//	token: Token account
//	tokenOwner: Token account owner
//	destination: Destination token account
//	destinationOwner: Destination token account owner
//	mint: Mint of token asset
//	metadata: Metadata (pda of ['metadata', program id, mint id])
//	edition: Edition of token asset
//	ownerTokenRecord: Owner token record account
//	destinationTokenRecord: Destination token record account
//	authority: Transfer authority (token owner or delegate)
//	payer: Payer
//	systemProgram: System Program
//	sysvarInstructions: Instructions sysvar account
//	splTokenProgram: SPL Token Program
//	splAtaProgram: SPL Associated Token Account program
//	authorizationRulesProgram: Token Authorization Rules Program
//	authorizationRules: Token Authorization Rules account
func NewTransferInstruction(
	transferArgs TransferArgs,
	token common.PublicKey,
	tokenOwner common.PublicKey,
	destination common.PublicKey,
	destinationOwner common.PublicKey,
	mint common.PublicKey,
	metadata common.PublicKey,
	edition common.PublicKey,
	ownerTokenRecord common.PublicKey,
	destinationTokenRecord common.PublicKey,
	authority common.PublicKey,
	payer common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
	splTokenProgram common.PublicKey,
	splAtaProgram common.PublicKey,
	authorizationRulesProgram common.PublicKey,
	authorizationRules common.PublicKey,
) *Transfer {
	return NewTransferInstructionBuilder().
		SetTransferArgs(transferArgs).
		SetTokenAccount(token).
		SetTokenOwnerAccount(tokenOwner).
		SetDestinationAccount(destination).
		SetDestinationOwnerAccount(destinationOwner).
		SetMintAccount(mint).
		SetMetadataAccount(metadata).
		SetEditionAccount(edition).
		SetOwnerTokenRecordAccount(ownerTokenRecord).
		SetDestinationTokenRecordAccount(destinationTokenRecord).
		SetAuthorityAccount(authority).
		SetPayerAccount(payer).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions).
		SetSplTokenProgramAccount(splTokenProgram).
		SetSplAtaProgramAccount(splAtaProgram).
		SetAuthorizationRulesProgramAccount(authorizationRulesProgram).
		SetAuthorizationRulesAccount(authorizationRules)
}

// SetTransferArgs sets the "transferArgs" parameter.
func (obj *Transfer) SetTransferArgs(transferArgs TransferArgs) *Transfer {
	obj.TransferArgs = &transferArgs
	return obj
}

// SetTokenAccount sets the "token" parameter.
// Token account
func (obj *Transfer) SetTokenAccount(token common.PublicKey) *Transfer {
	obj.AccountMetaSlice[0] = common.Meta(token).WRITE()
	return obj
}

// GetTokenAccount gets the "token" parameter.
// Token account
func (obj *Transfer) GetTokenAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetTokenOwnerAccount sets the "tokenOwner" parameter.
// Token account owner
func (obj *Transfer) SetTokenOwnerAccount(tokenOwner common.PublicKey) *Transfer {
	obj.AccountMetaSlice[1] = common.Meta(tokenOwner)
	return obj
}

// GetTokenOwnerAccount gets the "tokenOwner" parameter.
// Token account owner
func (obj *Transfer) GetTokenOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetDestinationAccount sets the "destination" parameter.
// Destination token account
func (obj *Transfer) SetDestinationAccount(destination common.PublicKey) *Transfer {
	obj.AccountMetaSlice[2] = common.Meta(destination).WRITE()
	return obj
}

// GetDestinationAccount gets the "destination" parameter.
// Destination token account
func (obj *Transfer) GetDestinationAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetDestinationOwnerAccount sets the "destinationOwner" parameter.
// Destination token account owner
func (obj *Transfer) SetDestinationOwnerAccount(destinationOwner common.PublicKey) *Transfer {
	obj.AccountMetaSlice[3] = common.Meta(destinationOwner)
	return obj
}

// GetDestinationOwnerAccount gets the "destinationOwner" parameter.
// Destination token account owner
func (obj *Transfer) GetDestinationOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetMintAccount sets the "mint" parameter.
// Mint of token asset
func (obj *Transfer) SetMintAccount(mint common.PublicKey) *Transfer {
	obj.AccountMetaSlice[4] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint of token asset
func (obj *Transfer) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata (pda of ['metadata', program id, mint id])
func (obj *Transfer) SetMetadataAccount(metadata common.PublicKey) *Transfer {
	obj.AccountMetaSlice[5] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata (pda of ['metadata', program id, mint id])
func (obj *Transfer) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetEditionAccount sets the "edition" parameter.
// Edition of token asset
func (obj *Transfer) SetEditionAccount(edition common.PublicKey) *Transfer {
	obj.AccountMetaSlice[6] = common.Meta(edition)
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Edition of token asset
func (obj *Transfer) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetOwnerTokenRecordAccount sets the "ownerTokenRecord" parameter.
// Owner token record account
func (obj *Transfer) SetOwnerTokenRecordAccount(ownerTokenRecord common.PublicKey) *Transfer {
	obj.AccountMetaSlice[7] = common.Meta(ownerTokenRecord).WRITE()
	return obj
}

// GetOwnerTokenRecordAccount gets the "ownerTokenRecord" parameter.
// Owner token record account
func (obj *Transfer) GetOwnerTokenRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetDestinationTokenRecordAccount sets the "destinationTokenRecord" parameter.
// Destination token record account
func (obj *Transfer) SetDestinationTokenRecordAccount(destinationTokenRecord common.PublicKey) *Transfer {
	obj.AccountMetaSlice[8] = common.Meta(destinationTokenRecord).WRITE()
	return obj
}

// GetDestinationTokenRecordAccount gets the "destinationTokenRecord" parameter.
// Destination token record account
func (obj *Transfer) GetDestinationTokenRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetAuthorityAccount sets the "authority" parameter.
// Transfer authority (token owner or delegate)
func (obj *Transfer) SetAuthorityAccount(authority common.PublicKey) *Transfer {
	obj.AccountMetaSlice[9] = common.Meta(authority).SIGNER()
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Transfer authority (token owner or delegate)
func (obj *Transfer) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetPayerAccount sets the "payer" parameter.
// Payer
func (obj *Transfer) SetPayerAccount(payer common.PublicKey) *Transfer {
	obj.AccountMetaSlice[10] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Payer
func (obj *Transfer) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System Program
func (obj *Transfer) SetSystemProgramAccount(systemProgram common.PublicKey) *Transfer {
	obj.AccountMetaSlice[11] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System Program
func (obj *Transfer) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Transfer) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey) *Transfer {
	obj.AccountMetaSlice[12] = common.Meta(sysvarInstructions)
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Transfer) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(12)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Transfer) SetSplTokenProgramAccount(splTokenProgram common.PublicKey) *Transfer {
	obj.AccountMetaSlice[13] = common.Meta(splTokenProgram)
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Transfer) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(13)
}

// SetSplAtaProgramAccount sets the "splAtaProgram" parameter.
// SPL Associated Token Account program
func (obj *Transfer) SetSplAtaProgramAccount(splAtaProgram common.PublicKey) *Transfer {
	obj.AccountMetaSlice[14] = common.Meta(splAtaProgram)
	return obj
}

// GetSplAtaProgramAccount gets the "splAtaProgram" parameter.
// SPL Associated Token Account program
func (obj *Transfer) GetSplAtaProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(14)
}

// SetAuthorizationRulesProgramAccount sets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Transfer) SetAuthorizationRulesProgramAccount(authorizationRulesProgram common.PublicKey) *Transfer {
	obj.AccountMetaSlice[15] = common.Meta(authorizationRulesProgram)
	return obj
}

// GetAuthorizationRulesProgramAccount gets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Transfer) GetAuthorizationRulesProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(15)
}

// SetAuthorizationRulesAccount sets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Transfer) SetAuthorizationRulesAccount(authorizationRules common.PublicKey, multiSigners ...common.PublicKey) *Transfer {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[16] = common.Meta(authorizationRules)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[16] = common.Meta(authorizationRules)
	}
	return obj
}

// GetAuthorizationRulesAccount gets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Transfer) GetAuthorizationRulesAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(16)
}

func (obj *Transfer) SetProgramId(programId *common.PublicKey) *Transfer {
	obj._programId = programId
	return obj
}

func (obj *Transfer) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Transfer}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Transfer) Validate() error {
	if obj.TransferArgs == nil {
		return errors.New("[Transfer] transferArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Transfer] accounts.token is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Transfer] accounts.tokenOwner is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Transfer] accounts.destination is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Transfer] accounts.destinationOwner is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Transfer] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Transfer] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Transfer] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[Transfer] accounts.ownerTokenRecord is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[Transfer] accounts.destinationTokenRecord is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[Transfer] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[Transfer] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[Transfer] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[12] == nil {
		return errors.New("[Transfer] accounts.sysvarInstructions is not set")
	}
	if obj.AccountMetaSlice[13] == nil {
		return errors.New("[Transfer] accounts.splTokenProgram is not set")
	}
	if obj.AccountMetaSlice[14] == nil {
		return errors.New("[Transfer] accounts.splAtaProgram is not set")
	}
	if obj.AccountMetaSlice[15] == nil {
		return errors.New("[Transfer] accounts.authorizationRulesProgram is not set")
	}
	if obj.AccountMetaSlice[16] == nil {
		return errors.New("[Transfer] accounts.authorizationRules is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Transfer) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Transfer) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.TransferArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Transfer) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.TransferArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Transfer) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Transfer")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("TransferArgs", *obj.TransferArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=17]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                    token", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("               tokenOwner", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("              destination", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("         destinationOwner", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                     mint", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                 metadata", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("                  edition", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("         ownerTokenRecord", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("   destinationTokenRecord", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("                authority", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("                    payer", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("            systemProgram", obj.AccountMetaSlice.Get(11)))
						accountsBranch.Child(common.FormatMeta("       sysvarInstructions", obj.AccountMetaSlice.Get(12)))
						accountsBranch.Child(common.FormatMeta("          splTokenProgram", obj.AccountMetaSlice.Get(13)))
						accountsBranch.Child(common.FormatMeta("            splAtaProgram", obj.AccountMetaSlice.Get(14)))
						accountsBranch.Child(common.FormatMeta("authorizationRulesProgram", obj.AccountMetaSlice.Get(15)))
						accountsBranch.Child(common.FormatMeta("       authorizationRules", obj.AccountMetaSlice.Get(16)))
					})
				})
		})
}

// Update Instruction
type Update struct {
	UpdateArgs *UpdateArgs
	// [0] = [SIGNER] authority `Update authority or delegate`
	// [1] = [] delegateRecord `Delegate record PDA`
	// [2] = [] token `Token account`
	// [3] = [] mint `Mint account`
	// [4] = [WRITE] metadata `Metadata account`
	// [5] = [] edition `Edition account`
	// [6] = [WRITE, SIGNER] payer `Payer`
	// [7] = [] systemProgram `System program`
	// [8] = [] sysvarInstructions `Instructions sysvar account`
	// [9] = [] authorizationRulesProgram `Token Authorization Rules Program`
	// [10] = [] authorizationRules `Token Authorization Rules account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewUpdateInstructionBuilder creates a new `Update` instruction builder.
func NewUpdateInstructionBuilder() *Update {
	return &Update{
		AccountMetaSlice: make(common.AccountMetaSlice, 11),
	}
}

// NewUpdateInstruction
//
// Parameters:
//
//	updateArgs:
//	authority: Update authority or delegate
//	delegateRecord: Delegate record PDA
//	token: Token account
//	mint: Mint account
//	metadata: Metadata account
//	edition: Edition account
//	payer: Payer
//	systemProgram: System program
//	sysvarInstructions: Instructions sysvar account
//	authorizationRulesProgram: Token Authorization Rules Program
//	authorizationRules: Token Authorization Rules account
func NewUpdateInstruction(
	updateArgs UpdateArgs,
	authority common.PublicKey,
	delegateRecord common.PublicKey,
	token common.PublicKey,
	mint common.PublicKey,
	metadata common.PublicKey,
	edition common.PublicKey,
	payer common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
	authorizationRulesProgram common.PublicKey,
	authorizationRules common.PublicKey,
) *Update {
	return NewUpdateInstructionBuilder().
		SetUpdateArgs(updateArgs).
		SetAuthorityAccount(authority).
		SetDelegateRecordAccount(delegateRecord).
		SetTokenAccount(token).
		SetMintAccount(mint).
		SetMetadataAccount(metadata).
		SetEditionAccount(edition).
		SetPayerAccount(payer).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions).
		SetAuthorizationRulesProgramAccount(authorizationRulesProgram).
		SetAuthorizationRulesAccount(authorizationRules)
}

// SetUpdateArgs sets the "updateArgs" parameter.
func (obj *Update) SetUpdateArgs(updateArgs UpdateArgs) *Update {
	obj.UpdateArgs = &updateArgs
	return obj
}

// SetAuthorityAccount sets the "authority" parameter.
// Update authority or delegate
func (obj *Update) SetAuthorityAccount(authority common.PublicKey) *Update {
	obj.AccountMetaSlice[0] = common.Meta(authority).SIGNER()
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Update authority or delegate
func (obj *Update) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetDelegateRecordAccount sets the "delegateRecord" parameter.
// Delegate record PDA
func (obj *Update) SetDelegateRecordAccount(delegateRecord common.PublicKey) *Update {
	obj.AccountMetaSlice[1] = common.Meta(delegateRecord)
	return obj
}

// GetDelegateRecordAccount gets the "delegateRecord" parameter.
// Delegate record PDA
func (obj *Update) GetDelegateRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetTokenAccount sets the "token" parameter.
// Token account
func (obj *Update) SetTokenAccount(token common.PublicKey) *Update {
	obj.AccountMetaSlice[2] = common.Meta(token)
	return obj
}

// GetTokenAccount gets the "token" parameter.
// Token account
func (obj *Update) GetTokenAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMintAccount sets the "mint" parameter.
// Mint account
func (obj *Update) SetMintAccount(mint common.PublicKey) *Update {
	obj.AccountMetaSlice[3] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint account
func (obj *Update) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *Update) SetMetadataAccount(metadata common.PublicKey) *Update {
	obj.AccountMetaSlice[4] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *Update) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetEditionAccount sets the "edition" parameter.
// Edition account
func (obj *Update) SetEditionAccount(edition common.PublicKey) *Update {
	obj.AccountMetaSlice[5] = common.Meta(edition)
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Edition account
func (obj *Update) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetPayerAccount sets the "payer" parameter.
// Payer
func (obj *Update) SetPayerAccount(payer common.PublicKey) *Update {
	obj.AccountMetaSlice[6] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Payer
func (obj *Update) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *Update) SetSystemProgramAccount(systemProgram common.PublicKey) *Update {
	obj.AccountMetaSlice[7] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *Update) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Update) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey) *Update {
	obj.AccountMetaSlice[8] = common.Meta(sysvarInstructions)
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Update) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetAuthorizationRulesProgramAccount sets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Update) SetAuthorizationRulesProgramAccount(authorizationRulesProgram common.PublicKey) *Update {
	obj.AccountMetaSlice[9] = common.Meta(authorizationRulesProgram)
	return obj
}

// GetAuthorizationRulesProgramAccount gets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Update) GetAuthorizationRulesProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetAuthorizationRulesAccount sets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Update) SetAuthorizationRulesAccount(authorizationRules common.PublicKey, multiSigners ...common.PublicKey) *Update {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[10] = common.Meta(authorizationRules)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[10] = common.Meta(authorizationRules)
	}
	return obj
}

// GetAuthorizationRulesAccount gets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Update) GetAuthorizationRulesAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

func (obj *Update) SetProgramId(programId *common.PublicKey) *Update {
	obj._programId = programId
	return obj
}

func (obj *Update) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Update}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Update) Validate() error {
	if obj.UpdateArgs == nil {
		return errors.New("[Update] updateArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Update] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Update] accounts.delegateRecord is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Update] accounts.token is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Update] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Update] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Update] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Update] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[Update] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[Update] accounts.sysvarInstructions is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[Update] accounts.authorizationRulesProgram is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[Update] accounts.authorizationRules is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Update) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Update) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.UpdateArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Update) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.UpdateArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Update) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Update")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("UpdateArgs", *obj.UpdateArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=11]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                authority", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("           delegateRecord", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                    token", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("                     mint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                 metadata", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                  edition", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("                    payer", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("            systemProgram", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("       sysvarInstructions", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("authorizationRulesProgram", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("       authorizationRules", obj.AccountMetaSlice.Get(10)))
					})
				})
		})
}

// Use Instruction
type Use struct {
	UseArgs *UseArgs
	// [0] = [SIGNER] authority `Token owner or delegate`
	// [1] = [WRITE] delegateRecord `Delegate record PDA`
	// [2] = [WRITE] token `Token account`
	// [3] = [] mint `Mint account`
	// [4] = [WRITE] metadata `Metadata account`
	// [5] = [WRITE] edition `Edition account`
	// [6] = [SIGNER] payer `Payer`
	// [7] = [] systemProgram `System program`
	// [8] = [] sysvarInstructions `System program`
	// [9] = [] splTokenProgram `SPL Token Program`
	// [10] = [] authorizationRulesProgram `Token Authorization Rules Program`
	// [11] = [] authorizationRules `Token Authorization Rules account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewUseInstructionBuilder creates a new `Use` instruction builder.
func NewUseInstructionBuilder() *Use {
	return &Use{
		AccountMetaSlice: make(common.AccountMetaSlice, 12),
	}
}

// NewUseInstruction
//
// Parameters:
//
//	useArgs:
//	authority: Token owner or delegate
//	delegateRecord: Delegate record PDA
//	token: Token account
//	mint: Mint account
//	metadata: Metadata account
//	edition: Edition account
//	payer: Payer
//	systemProgram: System program
//	sysvarInstructions: System program
//	splTokenProgram: SPL Token Program
//	authorizationRulesProgram: Token Authorization Rules Program
//	authorizationRules: Token Authorization Rules account
func NewUseInstruction(
	useArgs UseArgs,
	authority common.PublicKey,
	delegateRecord common.PublicKey,
	token common.PublicKey,
	mint common.PublicKey,
	metadata common.PublicKey,
	edition common.PublicKey,
	payer common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
	splTokenProgram common.PublicKey,
	authorizationRulesProgram common.PublicKey,
	authorizationRules common.PublicKey,
) *Use {
	return NewUseInstructionBuilder().
		SetUseArgs(useArgs).
		SetAuthorityAccount(authority).
		SetDelegateRecordAccount(delegateRecord).
		SetTokenAccount(token).
		SetMintAccount(mint).
		SetMetadataAccount(metadata).
		SetEditionAccount(edition).
		SetPayerAccount(payer).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions).
		SetSplTokenProgramAccount(splTokenProgram).
		SetAuthorizationRulesProgramAccount(authorizationRulesProgram).
		SetAuthorizationRulesAccount(authorizationRules)
}

// SetUseArgs sets the "useArgs" parameter.
func (obj *Use) SetUseArgs(useArgs UseArgs) *Use {
	obj.UseArgs = &useArgs
	return obj
}

// SetAuthorityAccount sets the "authority" parameter.
// Token owner or delegate
func (obj *Use) SetAuthorityAccount(authority common.PublicKey) *Use {
	obj.AccountMetaSlice[0] = common.Meta(authority).SIGNER()
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Token owner or delegate
func (obj *Use) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetDelegateRecordAccount sets the "delegateRecord" parameter.
// Delegate record PDA
func (obj *Use) SetDelegateRecordAccount(delegateRecord common.PublicKey) *Use {
	obj.AccountMetaSlice[1] = common.Meta(delegateRecord).WRITE()
	return obj
}

// GetDelegateRecordAccount gets the "delegateRecord" parameter.
// Delegate record PDA
func (obj *Use) GetDelegateRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetTokenAccount sets the "token" parameter.
// Token account
func (obj *Use) SetTokenAccount(token common.PublicKey) *Use {
	obj.AccountMetaSlice[2] = common.Meta(token).WRITE()
	return obj
}

// GetTokenAccount gets the "token" parameter.
// Token account
func (obj *Use) GetTokenAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetMintAccount sets the "mint" parameter.
// Mint account
func (obj *Use) SetMintAccount(mint common.PublicKey) *Use {
	obj.AccountMetaSlice[3] = common.Meta(mint)
	return obj
}

// GetMintAccount gets the "mint" parameter.
// Mint account
func (obj *Use) GetMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *Use) SetMetadataAccount(metadata common.PublicKey) *Use {
	obj.AccountMetaSlice[4] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *Use) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetEditionAccount sets the "edition" parameter.
// Edition account
func (obj *Use) SetEditionAccount(edition common.PublicKey) *Use {
	obj.AccountMetaSlice[5] = common.Meta(edition).WRITE()
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// Edition account
func (obj *Use) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetPayerAccount sets the "payer" parameter.
// Payer
func (obj *Use) SetPayerAccount(payer common.PublicKey) *Use {
	obj.AccountMetaSlice[6] = common.Meta(payer).SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// Payer
func (obj *Use) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *Use) SetSystemProgramAccount(systemProgram common.PublicKey) *Use {
	obj.AccountMetaSlice[7] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *Use) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// System program
func (obj *Use) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey) *Use {
	obj.AccountMetaSlice[8] = common.Meta(sysvarInstructions)
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// System program
func (obj *Use) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Use) SetSplTokenProgramAccount(splTokenProgram common.PublicKey) *Use {
	obj.AccountMetaSlice[9] = common.Meta(splTokenProgram)
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// SPL Token Program
func (obj *Use) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetAuthorizationRulesProgramAccount sets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Use) SetAuthorizationRulesProgramAccount(authorizationRulesProgram common.PublicKey) *Use {
	obj.AccountMetaSlice[10] = common.Meta(authorizationRulesProgram)
	return obj
}

// GetAuthorizationRulesProgramAccount gets the "authorizationRulesProgram" parameter.
// Token Authorization Rules Program
func (obj *Use) GetAuthorizationRulesProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetAuthorizationRulesAccount sets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Use) SetAuthorizationRulesAccount(authorizationRules common.PublicKey, multiSigners ...common.PublicKey) *Use {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[11] = common.Meta(authorizationRules)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[11] = common.Meta(authorizationRules)
	}
	return obj
}

// GetAuthorizationRulesAccount gets the "authorizationRules" parameter.
// Token Authorization Rules account
func (obj *Use) GetAuthorizationRulesAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

func (obj *Use) SetProgramId(programId *common.PublicKey) *Use {
	obj._programId = programId
	return obj
}

func (obj *Use) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Use}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Use) Validate() error {
	if obj.UseArgs == nil {
		return errors.New("[Use] useArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Use] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Use] accounts.delegateRecord is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Use] accounts.token is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Use] accounts.mint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Use] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Use] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Use] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[Use] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[Use] accounts.sysvarInstructions is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[Use] accounts.splTokenProgram is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[Use] accounts.authorizationRulesProgram is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[Use] accounts.authorizationRules is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Use) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Use) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.UseArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Use) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.UseArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Use) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Use")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("UseArgs", *obj.UseArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=12]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("                authority", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("           delegateRecord", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("                    token", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("                     mint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("                 metadata", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("                  edition", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("                    payer", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("            systemProgram", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("       sysvarInstructions", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("          splTokenProgram", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta("authorizationRulesProgram", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("       authorizationRules", obj.AccountMetaSlice.Get(11)))
					})
				})
		})
}

// Verify Instruction
type Verify struct {
	VerificationArgs *VerificationArgs
	// [0] = [SIGNER] authority `Creator to verify, collection update authority or delegate`
	// [1] = [] delegateRecord `Delegate record PDA`
	// [2] = [WRITE] metadata `Metadata account`
	// [3] = [] collectionMint `Mint of the Collection`
	// [4] = [WRITE] collectionMetadata `Metadata Account of the Collection`
	// [5] = [] collectionMasterEdition `Master Edition Account of the Collection Token`
	// [6] = [] systemProgram `System program`
	// [7] = [] sysvarInstructions `Instructions sysvar account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewVerifyInstructionBuilder creates a new `Verify` instruction builder.
func NewVerifyInstructionBuilder() *Verify {
	return &Verify{
		AccountMetaSlice: make(common.AccountMetaSlice, 8),
	}
}

// NewVerifyInstruction
//
// Parameters:
//
//	verificationArgs:
//	authority: Creator to verify, collection update authority or delegate
//	delegateRecord: Delegate record PDA
//	metadata: Metadata account
//	collectionMint: Mint of the Collection
//	collectionMetadata: Metadata Account of the Collection
//	collectionMasterEdition: Master Edition Account of the Collection Token
//	systemProgram: System program
//	sysvarInstructions: Instructions sysvar account
func NewVerifyInstruction(
	verificationArgs VerificationArgs,
	authority common.PublicKey,
	delegateRecord common.PublicKey,
	metadata common.PublicKey,
	collectionMint common.PublicKey,
	collectionMetadata common.PublicKey,
	collectionMasterEdition common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
) *Verify {
	return NewVerifyInstructionBuilder().
		SetVerificationArgs(verificationArgs).
		SetAuthorityAccount(authority).
		SetDelegateRecordAccount(delegateRecord).
		SetMetadataAccount(metadata).
		SetCollectionMintAccount(collectionMint).
		SetCollectionMetadataAccount(collectionMetadata).
		SetCollectionMasterEditionAccount(collectionMasterEdition).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions)
}

// SetVerificationArgs sets the "verificationArgs" parameter.
func (obj *Verify) SetVerificationArgs(verificationArgs VerificationArgs) *Verify {
	obj.VerificationArgs = &verificationArgs
	return obj
}

// SetAuthorityAccount sets the "authority" parameter.
// Creator to verify, collection update authority or delegate
func (obj *Verify) SetAuthorityAccount(authority common.PublicKey) *Verify {
	obj.AccountMetaSlice[0] = common.Meta(authority).SIGNER()
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Creator to verify, collection update authority or delegate
func (obj *Verify) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetDelegateRecordAccount sets the "delegateRecord" parameter.
// Delegate record PDA
func (obj *Verify) SetDelegateRecordAccount(delegateRecord common.PublicKey) *Verify {
	obj.AccountMetaSlice[1] = common.Meta(delegateRecord)
	return obj
}

// GetDelegateRecordAccount gets the "delegateRecord" parameter.
// Delegate record PDA
func (obj *Verify) GetDelegateRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *Verify) SetMetadataAccount(metadata common.PublicKey) *Verify {
	obj.AccountMetaSlice[2] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *Verify) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetCollectionMintAccount sets the "collectionMint" parameter.
// Mint of the Collection
func (obj *Verify) SetCollectionMintAccount(collectionMint common.PublicKey) *Verify {
	obj.AccountMetaSlice[3] = common.Meta(collectionMint)
	return obj
}

// GetCollectionMintAccount gets the "collectionMint" parameter.
// Mint of the Collection
func (obj *Verify) GetCollectionMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetCollectionMetadataAccount sets the "collectionMetadata" parameter.
// Metadata Account of the Collection
func (obj *Verify) SetCollectionMetadataAccount(collectionMetadata common.PublicKey) *Verify {
	obj.AccountMetaSlice[4] = common.Meta(collectionMetadata).WRITE()
	return obj
}

// GetCollectionMetadataAccount gets the "collectionMetadata" parameter.
// Metadata Account of the Collection
func (obj *Verify) GetCollectionMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetCollectionMasterEditionAccount sets the "collectionMasterEdition" parameter.
// Master Edition Account of the Collection Token
func (obj *Verify) SetCollectionMasterEditionAccount(collectionMasterEdition common.PublicKey) *Verify {
	obj.AccountMetaSlice[5] = common.Meta(collectionMasterEdition)
	return obj
}

// GetCollectionMasterEditionAccount gets the "collectionMasterEdition" parameter.
// Master Edition Account of the Collection Token
func (obj *Verify) GetCollectionMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *Verify) SetSystemProgramAccount(systemProgram common.PublicKey) *Verify {
	obj.AccountMetaSlice[6] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *Verify) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Verify) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey, multiSigners ...common.PublicKey) *Verify {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[7] = common.Meta(sysvarInstructions)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[7] = common.Meta(sysvarInstructions)
	}
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Verify) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

func (obj *Verify) SetProgramId(programId *common.PublicKey) *Verify {
	obj._programId = programId
	return obj
}

func (obj *Verify) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Verify}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Verify) Validate() error {
	if obj.VerificationArgs == nil {
		return errors.New("[Verify] verificationArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Verify] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Verify] accounts.delegateRecord is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Verify] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Verify] accounts.collectionMint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Verify] accounts.collectionMetadata is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Verify] accounts.collectionMasterEdition is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Verify] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[Verify] accounts.sysvarInstructions is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Verify) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Verify) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.VerificationArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Verify) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.VerificationArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Verify) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Verify")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("VerificationArgs", *obj.VerificationArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=8]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("              authority", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("         delegateRecord", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("               metadata", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("         collectionMint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("     collectionMetadata", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("collectionMasterEdition", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("          systemProgram", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("     sysvarInstructions", obj.AccountMetaSlice.Get(7)))
					})
				})
		})
}

// Unverify Instruction
type Unverify struct {
	VerificationArgs *VerificationArgs
	// [0] = [SIGNER] authority `Creator to verify, collection (or metadata if parent burned) update authority or delegate`
	// [1] = [] delegateRecord `Delegate record PDA`
	// [2] = [WRITE] metadata `Metadata account`
	// [3] = [] collectionMint `Mint of the Collection`
	// [4] = [WRITE] collectionMetadata `Metadata Account of the Collection`
	// [5] = [] systemProgram `System program`
	// [6] = [] sysvarInstructions `Instructions sysvar account`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewUnverifyInstructionBuilder creates a new `Unverify` instruction builder.
func NewUnverifyInstructionBuilder() *Unverify {
	return &Unverify{
		AccountMetaSlice: make(common.AccountMetaSlice, 7),
	}
}

// NewUnverifyInstruction
//
// Parameters:
//
//	verificationArgs:
//	authority: Creator to verify, collection (or metadata if parent burned) update authority or delegate
//	delegateRecord: Delegate record PDA
//	metadata: Metadata account
//	collectionMint: Mint of the Collection
//	collectionMetadata: Metadata Account of the Collection
//	systemProgram: System program
//	sysvarInstructions: Instructions sysvar account
func NewUnverifyInstruction(
	verificationArgs VerificationArgs,
	authority common.PublicKey,
	delegateRecord common.PublicKey,
	metadata common.PublicKey,
	collectionMint common.PublicKey,
	collectionMetadata common.PublicKey,
	systemProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
) *Unverify {
	return NewUnverifyInstructionBuilder().
		SetVerificationArgs(verificationArgs).
		SetAuthorityAccount(authority).
		SetDelegateRecordAccount(delegateRecord).
		SetMetadataAccount(metadata).
		SetCollectionMintAccount(collectionMint).
		SetCollectionMetadataAccount(collectionMetadata).
		SetSystemProgramAccount(systemProgram).
		SetSysvarInstructionsAccount(sysvarInstructions)
}

// SetVerificationArgs sets the "verificationArgs" parameter.
func (obj *Unverify) SetVerificationArgs(verificationArgs VerificationArgs) *Unverify {
	obj.VerificationArgs = &verificationArgs
	return obj
}

// SetAuthorityAccount sets the "authority" parameter.
// Creator to verify, collection (or metadata if parent burned) update authority or delegate
func (obj *Unverify) SetAuthorityAccount(authority common.PublicKey) *Unverify {
	obj.AccountMetaSlice[0] = common.Meta(authority).SIGNER()
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Creator to verify, collection (or metadata if parent burned) update authority or delegate
func (obj *Unverify) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetDelegateRecordAccount sets the "delegateRecord" parameter.
// Delegate record PDA
func (obj *Unverify) SetDelegateRecordAccount(delegateRecord common.PublicKey) *Unverify {
	obj.AccountMetaSlice[1] = common.Meta(delegateRecord)
	return obj
}

// GetDelegateRecordAccount gets the "delegateRecord" parameter.
// Delegate record PDA
func (obj *Unverify) GetDelegateRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetMetadataAccount sets the "metadata" parameter.
// Metadata account
func (obj *Unverify) SetMetadataAccount(metadata common.PublicKey) *Unverify {
	obj.AccountMetaSlice[2] = common.Meta(metadata).WRITE()
	return obj
}

// GetMetadataAccount gets the "metadata" parameter.
// Metadata account
func (obj *Unverify) GetMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetCollectionMintAccount sets the "collectionMint" parameter.
// Mint of the Collection
func (obj *Unverify) SetCollectionMintAccount(collectionMint common.PublicKey) *Unverify {
	obj.AccountMetaSlice[3] = common.Meta(collectionMint)
	return obj
}

// GetCollectionMintAccount gets the "collectionMint" parameter.
// Mint of the Collection
func (obj *Unverify) GetCollectionMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetCollectionMetadataAccount sets the "collectionMetadata" parameter.
// Metadata Account of the Collection
func (obj *Unverify) SetCollectionMetadataAccount(collectionMetadata common.PublicKey) *Unverify {
	obj.AccountMetaSlice[4] = common.Meta(collectionMetadata).WRITE()
	return obj
}

// GetCollectionMetadataAccount gets the "collectionMetadata" parameter.
// Metadata Account of the Collection
func (obj *Unverify) GetCollectionMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *Unverify) SetSystemProgramAccount(systemProgram common.PublicKey) *Unverify {
	obj.AccountMetaSlice[5] = common.Meta(systemProgram)
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *Unverify) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Unverify) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey, multiSigners ...common.PublicKey) *Unverify {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[6] = common.Meta(sysvarInstructions)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[6] = common.Meta(sysvarInstructions)
	}
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Unverify) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

func (obj *Unverify) SetProgramId(programId *common.PublicKey) *Unverify {
	obj._programId = programId
	return obj
}

func (obj *Unverify) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Unverify}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Unverify) Validate() error {
	if obj.VerificationArgs == nil {
		return errors.New("[Unverify] verificationArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Unverify] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Unverify] accounts.delegateRecord is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Unverify] accounts.metadata is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Unverify] accounts.collectionMint is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Unverify] accounts.collectionMetadata is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Unverify] accounts.systemProgram is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Unverify] accounts.sysvarInstructions is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Unverify) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Unverify) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.VerificationArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Unverify) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.VerificationArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Unverify) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Unverify")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("VerificationArgs", *obj.VerificationArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=7]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("         authority", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("    delegateRecord", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("          metadata", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("    collectionMint", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("collectionMetadata", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("     systemProgram", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("sysvarInstructions", obj.AccountMetaSlice.Get(6)))
					})
				})
		})
}

// Collect Instruction
type Collect struct {
	// [0] = [SIGNER] authority `Authority to collect fees`
	// [1] = [] recipient `The account to transfer collected fees to`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewCollectInstructionBuilder creates a new `Collect` instruction builder.
func NewCollectInstructionBuilder() *Collect {
	return &Collect{
		AccountMetaSlice: make(common.AccountMetaSlice, 2),
	}
}

// NewCollectInstruction
//
// Parameters:
//
//	authority: Authority to collect fees
//	recipient: The account to transfer collected fees to
func NewCollectInstruction(
	authority common.PublicKey,
	recipient common.PublicKey,
) *Collect {
	return NewCollectInstructionBuilder().
		SetAuthorityAccount(authority).
		SetRecipientAccount(recipient)
}

// SetAuthorityAccount sets the "authority" parameter.
// Authority to collect fees
func (obj *Collect) SetAuthorityAccount(authority common.PublicKey) *Collect {
	obj.AccountMetaSlice[0] = common.Meta(authority).SIGNER()
	return obj
}

// GetAuthorityAccount gets the "authority" parameter.
// Authority to collect fees
func (obj *Collect) GetAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetRecipientAccount sets the "recipient" parameter.
// The account to transfer collected fees to
func (obj *Collect) SetRecipientAccount(recipient common.PublicKey, multiSigners ...common.PublicKey) *Collect {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[1] = common.Meta(recipient)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[1] = common.Meta(recipient)
	}
	return obj
}

// GetRecipientAccount gets the "recipient" parameter.
// The account to transfer collected fees to
func (obj *Collect) GetRecipientAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

func (obj *Collect) SetProgramId(programId *common.PublicKey) *Collect {
	obj._programId = programId
	return obj
}

func (obj *Collect) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Collect}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Collect) Validate() error {

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Collect] accounts.authority is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Collect] accounts.recipient is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Collect) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Collect) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *Collect) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *Collect) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Collect")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=0]").ParentFunc(func(paramsBranch treeout.Branches) {})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=2]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("authority", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("recipient", obj.AccountMetaSlice.Get(1)))
					})
				})
		})
}

// Print Instruction
type Print struct {
	PrintArgs *PrintArgs
	// [0] = [WRITE] editionMetadata `New Metadata key (pda of ['metadata', program id, mint id])`
	// [1] = [WRITE] edition `New Edition (pda of ['metadata', program id, mint id, 'edition'])`
	// [2] = [WRITE] editionMint `Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY`
	// [3] = [] editionTokenAccountOwner `Owner of the token account of new token`
	// [4] = [WRITE] editionTokenAccount `Token account of new token`
	// [5] = [SIGNER] editionMintAuthority `Mint authority of new mint`
	// [6] = [WRITE] editionTokenRecord `Token record account`
	// [7] = [WRITE] masterEdition `Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition'])`
	// [8] = [WRITE] editionMarkerPda `Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE).`
	// [9] = [WRITE, SIGNER] payer `payer`
	// [10] = [SIGNER] masterTokenAccountOwner `owner of token account containing master token`
	// [11] = [] masterTokenAccount `token account containing token from master metadata mint`
	// [12] = [] masterMetadata `Master record metadata account`
	// [13] = [] updateAuthority `The update authority of the master edition.`
	// [14] = [] splTokenProgram `Token program`
	// [15] = [] splAtaProgram `SPL Associated Token Account program`
	// [16] = [] sysvarInstructions `Instructions sysvar account`
	// [17] = [] systemProgram `System program`
	common.AccountMetaSlice `bin:"-"`
	_programId              *common.PublicKey
}

// NewPrintInstructionBuilder creates a new `Print` instruction builder.
func NewPrintInstructionBuilder() *Print {
	return &Print{
		AccountMetaSlice: make(common.AccountMetaSlice, 18),
	}
}

// NewPrintInstruction
//
// Parameters:
//
//	printArgs:
//	editionMetadata: New Metadata key (pda of ['metadata', program id, mint id])
//	edition: New Edition (pda of ['metadata', program id, mint id, 'edition'])
//	editionMint: Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
//	editionTokenAccountOwner: Owner of the token account of new token
//	editionTokenAccount: Token account of new token
//	editionMintAuthority: Mint authority of new mint
//	editionTokenRecord: Token record account
//	masterEdition: Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition'])
//	editionMarkerPda: Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE).
//	payer: payer
//	masterTokenAccountOwner: owner of token account containing master token
//	masterTokenAccount: token account containing token from master metadata mint
//	masterMetadata: Master record metadata account
//	updateAuthority: The update authority of the master edition.
//	splTokenProgram: Token program
//	splAtaProgram: SPL Associated Token Account program
//	sysvarInstructions: Instructions sysvar account
//	systemProgram: System program
func NewPrintInstruction(
	printArgs PrintArgs,
	editionMetadata common.PublicKey,
	edition common.PublicKey,
	editionMint common.PublicKey,
	editionTokenAccountOwner common.PublicKey,
	editionTokenAccount common.PublicKey,
	editionMintAuthority common.PublicKey,
	editionTokenRecord common.PublicKey,
	masterEdition common.PublicKey,
	editionMarkerPda common.PublicKey,
	payer common.PublicKey,
	masterTokenAccountOwner common.PublicKey,
	masterTokenAccount common.PublicKey,
	masterMetadata common.PublicKey,
	updateAuthority common.PublicKey,
	splTokenProgram common.PublicKey,
	splAtaProgram common.PublicKey,
	sysvarInstructions common.PublicKey,
	systemProgram common.PublicKey,
) *Print {
	return NewPrintInstructionBuilder().
		SetPrintArgs(printArgs).
		SetEditionMetadataAccount(editionMetadata).
		SetEditionAccount(edition).
		SetEditionMintAccount(editionMint).
		SetEditionTokenAccountOwnerAccount(editionTokenAccountOwner).
		SetEditionTokenAccountAccount(editionTokenAccount).
		SetEditionMintAuthorityAccount(editionMintAuthority).
		SetEditionTokenRecordAccount(editionTokenRecord).
		SetMasterEditionAccount(masterEdition).
		SetEditionMarkerPdaAccount(editionMarkerPda).
		SetPayerAccount(payer).
		SetMasterTokenAccountOwnerAccount(masterTokenAccountOwner).
		SetMasterTokenAccountAccount(masterTokenAccount).
		SetMasterMetadataAccount(masterMetadata).
		SetUpdateAuthorityAccount(updateAuthority).
		SetSplTokenProgramAccount(splTokenProgram).
		SetSplAtaProgramAccount(splAtaProgram).
		SetSysvarInstructionsAccount(sysvarInstructions).
		SetSystemProgramAccount(systemProgram)
}

// SetPrintArgs sets the "printArgs" parameter.
func (obj *Print) SetPrintArgs(printArgs PrintArgs) *Print {
	obj.PrintArgs = &printArgs
	return obj
}

// SetEditionMetadataAccount sets the "editionMetadata" parameter.
// New Metadata key (pda of ['metadata', program id, mint id])
func (obj *Print) SetEditionMetadataAccount(editionMetadata common.PublicKey) *Print {
	obj.AccountMetaSlice[0] = common.Meta(editionMetadata).WRITE()
	return obj
}

// GetEditionMetadataAccount gets the "editionMetadata" parameter.
// New Metadata key (pda of ['metadata', program id, mint id])
func (obj *Print) GetEditionMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(0)
}

// SetEditionAccount sets the "edition" parameter.
// New Edition (pda of ['metadata', program id, mint id, 'edition'])
func (obj *Print) SetEditionAccount(edition common.PublicKey) *Print {
	obj.AccountMetaSlice[1] = common.Meta(edition).WRITE()
	return obj
}

// GetEditionAccount gets the "edition" parameter.
// New Edition (pda of ['metadata', program id, mint id, 'edition'])
func (obj *Print) GetEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(1)
}

// SetEditionMintAccount sets the "editionMint" parameter.
// Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
func (obj *Print) SetEditionMintAccount(editionMint common.PublicKey) *Print {
	obj.AccountMetaSlice[2] = common.Meta(editionMint).WRITE()
	return obj
}

// GetEditionMintAccount gets the "editionMint" parameter.
// Mint of new token - THIS WILL TRANSFER AUTHORITY AWAY FROM THIS KEY
func (obj *Print) GetEditionMintAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(2)
}

// SetEditionTokenAccountOwnerAccount sets the "editionTokenAccountOwner" parameter.
// Owner of the token account of new token
func (obj *Print) SetEditionTokenAccountOwnerAccount(editionTokenAccountOwner common.PublicKey) *Print {
	obj.AccountMetaSlice[3] = common.Meta(editionTokenAccountOwner)
	return obj
}

// GetEditionTokenAccountOwnerAccount gets the "editionTokenAccountOwner" parameter.
// Owner of the token account of new token
func (obj *Print) GetEditionTokenAccountOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(3)
}

// SetEditionTokenAccountAccount sets the "editionTokenAccount" parameter.
// Token account of new token
func (obj *Print) SetEditionTokenAccountAccount(editionTokenAccount common.PublicKey) *Print {
	obj.AccountMetaSlice[4] = common.Meta(editionTokenAccount).WRITE()
	return obj
}

// GetEditionTokenAccountAccount gets the "editionTokenAccount" parameter.
// Token account of new token
func (obj *Print) GetEditionTokenAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(4)
}

// SetEditionMintAuthorityAccount sets the "editionMintAuthority" parameter.
// Mint authority of new mint
func (obj *Print) SetEditionMintAuthorityAccount(editionMintAuthority common.PublicKey) *Print {
	obj.AccountMetaSlice[5] = common.Meta(editionMintAuthority).SIGNER()
	return obj
}

// GetEditionMintAuthorityAccount gets the "editionMintAuthority" parameter.
// Mint authority of new mint
func (obj *Print) GetEditionMintAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(5)
}

// SetEditionTokenRecordAccount sets the "editionTokenRecord" parameter.
// Token record account
func (obj *Print) SetEditionTokenRecordAccount(editionTokenRecord common.PublicKey) *Print {
	obj.AccountMetaSlice[6] = common.Meta(editionTokenRecord).WRITE()
	return obj
}

// GetEditionTokenRecordAccount gets the "editionTokenRecord" parameter.
// Token record account
func (obj *Print) GetEditionTokenRecordAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(6)
}

// SetMasterEditionAccount sets the "masterEdition" parameter.
// Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition'])
func (obj *Print) SetMasterEditionAccount(masterEdition common.PublicKey) *Print {
	obj.AccountMetaSlice[7] = common.Meta(masterEdition).WRITE()
	return obj
}

// GetMasterEditionAccount gets the "masterEdition" parameter.
// Master Record Edition V2 (pda of ['metadata', program id, master metadata mint id, 'edition'])
func (obj *Print) GetMasterEditionAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(7)
}

// SetEditionMarkerPdaAccount sets the "editionMarkerPda" parameter.
// Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE).
func (obj *Print) SetEditionMarkerPdaAccount(editionMarkerPda common.PublicKey) *Print {
	obj.AccountMetaSlice[8] = common.Meta(editionMarkerPda).WRITE()
	return obj
}

// GetEditionMarkerPdaAccount gets the "editionMarkerPda" parameter.
// Edition pda to mark creation - will be checked for pre-existence. (pda of ['metadata', program id, master metadata mint id, 'edition', edition_number]) where edition_number is NOT the edition number you pass in args but actually edition_number = floor(edition/EDITION_MARKER_BIT_SIZE).
func (obj *Print) GetEditionMarkerPdaAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(8)
}

// SetPayerAccount sets the "payer" parameter.
// payer
func (obj *Print) SetPayerAccount(payer common.PublicKey) *Print {
	obj.AccountMetaSlice[9] = common.Meta(payer).WRITE().SIGNER()
	return obj
}

// GetPayerAccount gets the "payer" parameter.
// payer
func (obj *Print) GetPayerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(9)
}

// SetMasterTokenAccountOwnerAccount sets the "masterTokenAccountOwner" parameter.
// owner of token account containing master token
func (obj *Print) SetMasterTokenAccountOwnerAccount(masterTokenAccountOwner common.PublicKey) *Print {
	obj.AccountMetaSlice[10] = common.Meta(masterTokenAccountOwner).SIGNER()
	return obj
}

// GetMasterTokenAccountOwnerAccount gets the "masterTokenAccountOwner" parameter.
// owner of token account containing master token
func (obj *Print) GetMasterTokenAccountOwnerAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(10)
}

// SetMasterTokenAccountAccount sets the "masterTokenAccount" parameter.
// token account containing token from master metadata mint
func (obj *Print) SetMasterTokenAccountAccount(masterTokenAccount common.PublicKey) *Print {
	obj.AccountMetaSlice[11] = common.Meta(masterTokenAccount)
	return obj
}

// GetMasterTokenAccountAccount gets the "masterTokenAccount" parameter.
// token account containing token from master metadata mint
func (obj *Print) GetMasterTokenAccountAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(11)
}

// SetMasterMetadataAccount sets the "masterMetadata" parameter.
// Master record metadata account
func (obj *Print) SetMasterMetadataAccount(masterMetadata common.PublicKey) *Print {
	obj.AccountMetaSlice[12] = common.Meta(masterMetadata)
	return obj
}

// GetMasterMetadataAccount gets the "masterMetadata" parameter.
// Master record metadata account
func (obj *Print) GetMasterMetadataAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(12)
}

// SetUpdateAuthorityAccount sets the "updateAuthority" parameter.
// The update authority of the master edition.
func (obj *Print) SetUpdateAuthorityAccount(updateAuthority common.PublicKey) *Print {
	obj.AccountMetaSlice[13] = common.Meta(updateAuthority)
	return obj
}

// GetUpdateAuthorityAccount gets the "updateAuthority" parameter.
// The update authority of the master edition.
func (obj *Print) GetUpdateAuthorityAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(13)
}

// SetSplTokenProgramAccount sets the "splTokenProgram" parameter.
// Token program
func (obj *Print) SetSplTokenProgramAccount(splTokenProgram common.PublicKey) *Print {
	obj.AccountMetaSlice[14] = common.Meta(splTokenProgram)
	return obj
}

// GetSplTokenProgramAccount gets the "splTokenProgram" parameter.
// Token program
func (obj *Print) GetSplTokenProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(14)
}

// SetSplAtaProgramAccount sets the "splAtaProgram" parameter.
// SPL Associated Token Account program
func (obj *Print) SetSplAtaProgramAccount(splAtaProgram common.PublicKey) *Print {
	obj.AccountMetaSlice[15] = common.Meta(splAtaProgram)
	return obj
}

// GetSplAtaProgramAccount gets the "splAtaProgram" parameter.
// SPL Associated Token Account program
func (obj *Print) GetSplAtaProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(15)
}

// SetSysvarInstructionsAccount sets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Print) SetSysvarInstructionsAccount(sysvarInstructions common.PublicKey) *Print {
	obj.AccountMetaSlice[16] = common.Meta(sysvarInstructions)
	return obj
}

// GetSysvarInstructionsAccount gets the "sysvarInstructions" parameter.
// Instructions sysvar account
func (obj *Print) GetSysvarInstructionsAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(16)
}

// SetSystemProgramAccount sets the "systemProgram" parameter.
// System program
func (obj *Print) SetSystemProgramAccount(systemProgram common.PublicKey, multiSigners ...common.PublicKey) *Print {
	if len(multiSigners) > 0 {
		obj.AccountMetaSlice[17] = common.Meta(systemProgram)
		for _, value := range multiSigners {
			obj.AccountMetaSlice.Append(common.NewAccountMeta(value, false, true))
		}
	} else {
		obj.AccountMetaSlice[17] = common.Meta(systemProgram)
	}
	return obj
}

// GetSystemProgramAccount gets the "systemProgram" parameter.
// System program
func (obj *Print) GetSystemProgramAccount() *common.AccountMeta {
	return obj.AccountMetaSlice.Get(17)
}

func (obj *Print) SetProgramId(programId *common.PublicKey) *Print {
	obj._programId = programId
	return obj
}

func (obj *Print) Build() *Instruction {
	return &Instruction{
		BaseVariant: binary.BaseVariant{
			Impl:   obj,
			TypeID: binary.TypeIDFromBytes([]byte{Instruction_Print}),
		},
		programId: obj._programId,
		typeIdLen: 1,
	}
}

func (obj *Print) Validate() error {
	if obj.PrintArgs == nil {
		return errors.New("[Print] printArgs param is not set")
	}

	if obj.AccountMetaSlice[0] == nil {
		return errors.New("[Print] accounts.editionMetadata is not set")
	}
	if obj.AccountMetaSlice[1] == nil {
		return errors.New("[Print] accounts.edition is not set")
	}
	if obj.AccountMetaSlice[2] == nil {
		return errors.New("[Print] accounts.editionMint is not set")
	}
	if obj.AccountMetaSlice[3] == nil {
		return errors.New("[Print] accounts.editionTokenAccountOwner is not set")
	}
	if obj.AccountMetaSlice[4] == nil {
		return errors.New("[Print] accounts.editionTokenAccount is not set")
	}
	if obj.AccountMetaSlice[5] == nil {
		return errors.New("[Print] accounts.editionMintAuthority is not set")
	}
	if obj.AccountMetaSlice[6] == nil {
		return errors.New("[Print] accounts.editionTokenRecord is not set")
	}
	if obj.AccountMetaSlice[7] == nil {
		return errors.New("[Print] accounts.masterEdition is not set")
	}
	if obj.AccountMetaSlice[8] == nil {
		return errors.New("[Print] accounts.editionMarkerPda is not set")
	}
	if obj.AccountMetaSlice[9] == nil {
		return errors.New("[Print] accounts.payer is not set")
	}
	if obj.AccountMetaSlice[10] == nil {
		return errors.New("[Print] accounts.masterTokenAccountOwner is not set")
	}
	if obj.AccountMetaSlice[11] == nil {
		return errors.New("[Print] accounts.masterTokenAccount is not set")
	}
	if obj.AccountMetaSlice[12] == nil {
		return errors.New("[Print] accounts.masterMetadata is not set")
	}
	if obj.AccountMetaSlice[13] == nil {
		return errors.New("[Print] accounts.updateAuthority is not set")
	}
	if obj.AccountMetaSlice[14] == nil {
		return errors.New("[Print] accounts.splTokenProgram is not set")
	}
	if obj.AccountMetaSlice[15] == nil {
		return errors.New("[Print] accounts.splAtaProgram is not set")
	}
	if obj.AccountMetaSlice[16] == nil {
		return errors.New("[Print] accounts.sysvarInstructions is not set")
	}
	if obj.AccountMetaSlice[17] == nil {
		return errors.New("[Print] accounts.systemProgram is not set")
	}
	return nil
}

// ValidateAndBuild validates the instruction parameters and accounts;
// if there is a validation error, it returns the error.
// Otherwise, it builds and returns the instruction.
func (obj *Print) ValidateAndBuild() (*Instruction, error) {
	if err := obj.Validate(); err != nil {
		return nil, err
	}
	return obj.Build(), nil
}

func (obj *Print) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	if err = encoder.Encode(&obj.PrintArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Print) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	if err = decoder.Decode(&obj.PrintArgs); err != nil {
		return err
	}
	return nil
}

func (obj *Print) EncodeToTree(parent treeout.Branches) {
	parent.Child(format.Program(ProgramName, common.As(ProgramID))).
		ParentFunc(func(programBranch treeout.Branches) {
			programBranch.Child(format.Instruction("Print")).
				ParentFunc(func(instructionBranch treeout.Branches) {
					// Parameters of the instruction:
					instructionBranch.Child("Params[len=1]").ParentFunc(func(paramsBranch treeout.Branches) {
						paramsBranch.Child(format.Param("PrintArgs", *obj.PrintArgs))
					})
					// Accounts of the instruction:
					instructionBranch.Child("Accounts[len=18]").ParentFunc(func(accountsBranch treeout.Branches) {
						accountsBranch.Child(common.FormatMeta("         editionMetadata", obj.AccountMetaSlice.Get(0)))
						accountsBranch.Child(common.FormatMeta("                 edition", obj.AccountMetaSlice.Get(1)))
						accountsBranch.Child(common.FormatMeta("             editionMint", obj.AccountMetaSlice.Get(2)))
						accountsBranch.Child(common.FormatMeta("editionTokenAccountOwner", obj.AccountMetaSlice.Get(3)))
						accountsBranch.Child(common.FormatMeta("     editionTokenAccount", obj.AccountMetaSlice.Get(4)))
						accountsBranch.Child(common.FormatMeta("    editionMintAuthority", obj.AccountMetaSlice.Get(5)))
						accountsBranch.Child(common.FormatMeta("      editionTokenRecord", obj.AccountMetaSlice.Get(6)))
						accountsBranch.Child(common.FormatMeta("           masterEdition", obj.AccountMetaSlice.Get(7)))
						accountsBranch.Child(common.FormatMeta("        editionMarkerPda", obj.AccountMetaSlice.Get(8)))
						accountsBranch.Child(common.FormatMeta("                   payer", obj.AccountMetaSlice.Get(9)))
						accountsBranch.Child(common.FormatMeta(" masterTokenAccountOwner", obj.AccountMetaSlice.Get(10)))
						accountsBranch.Child(common.FormatMeta("      masterTokenAccount", obj.AccountMetaSlice.Get(11)))
						accountsBranch.Child(common.FormatMeta("          masterMetadata", obj.AccountMetaSlice.Get(12)))
						accountsBranch.Child(common.FormatMeta("         updateAuthority", obj.AccountMetaSlice.Get(13)))
						accountsBranch.Child(common.FormatMeta("         splTokenProgram", obj.AccountMetaSlice.Get(14)))
						accountsBranch.Child(common.FormatMeta("           splAtaProgram", obj.AccountMetaSlice.Get(15)))
						accountsBranch.Child(common.FormatMeta("      sysvarInstructions", obj.AccountMetaSlice.Get(16)))
						accountsBranch.Child(common.FormatMeta("           systemProgram", obj.AccountMetaSlice.Get(17)))
					})
				})
		})
}
